diff --git a/__pycache__/gs2_data.cpython-36.pyc b/__pycache__/gs2_data.cpython-36.pyc
deleted file mode 100644
index a97591d..0000000
Binary files a/__pycache__/gs2_data.cpython-36.pyc and /dev/null differ
diff --git a/__pycache__/gs2_fft.cpython-36.pyc b/__pycache__/gs2_fft.cpython-36.pyc
deleted file mode 100644
index 7678d6d..0000000
Binary files a/__pycache__/gs2_fft.cpython-36.pyc and /dev/null differ
diff --git a/__pycache__/gs2_fields.cpython-36.pyc b/__pycache__/gs2_fields.cpython-36.pyc
deleted file mode 100644
index 6cf58ef..0000000
Binary files a/__pycache__/gs2_fields.cpython-36.pyc and /dev/null differ
diff --git a/__pycache__/gs2_grids.cpython-36.pyc b/__pycache__/gs2_grids.cpython-36.pyc
deleted file mode 100644
index c330e95..0000000
Binary files a/__pycache__/gs2_grids.cpython-36.pyc and /dev/null differ
diff --git a/__pycache__/gs2_plotting.cpython-36.pyc b/__pycache__/gs2_plotting.cpython-36.pyc
deleted file mode 100644
index 4c5a93b..0000000
Binary files a/__pycache__/gs2_plotting.cpython-36.pyc and /dev/null differ
diff --git a/__pycache__/gs2_quick_parameters.cpython-36.pyc b/__pycache__/gs2_quick_parameters.cpython-36.pyc
deleted file mode 100644
index 7ca0d95..0000000
Binary files a/__pycache__/gs2_quick_parameters.cpython-36.pyc and /dev/null differ
diff --git a/__pycache__/gs2_run_parameters.cpython-36.pyc b/__pycache__/gs2_run_parameters.cpython-36.pyc
deleted file mode 100644
index 0673e32..0000000
Binary files a/__pycache__/gs2_run_parameters.cpython-36.pyc and /dev/null differ
diff --git a/__pycache__/gs2_tasks.cpython-36.pyc b/__pycache__/gs2_tasks.cpython-36.pyc
deleted file mode 100644
index 33b551d..0000000
Binary files a/__pycache__/gs2_tasks.cpython-36.pyc and /dev/null differ
diff --git a/__pycache__/gs2_time.cpython-36.pyc b/__pycache__/gs2_time.cpython-36.pyc
deleted file mode 100644
index 9a909a0..0000000
Binary files a/__pycache__/gs2_time.cpython-36.pyc and /dev/null differ
diff --git a/diff.txt b/diff.txt
deleted file mode 100644
index e5d5e5c..0000000
--- a/diff.txt
+++ /dev/null
@@ -1,4918 +0,0 @@
-diff --git a/gs2_analysis.py b/gs2_analysis.py
-index a1c20ed..3d7dd2f 100644
---- a/gs2_analysis.py
-+++ b/gs2_analysis.py
-@@ -1,15 +1,16 @@
-+import gs2_plotting as gplot
- import gs2_run_parameters as grunpar
- import gs2_data as gdata
- import gs2_grids as ggrids
- import gs2_time as gtime
- import gs2_fields as gfields
--import gs2_plotting as gplot
- import gs2_tasks as gtasks
- 
- import copy
- 
- # TODO: add 'your_task' to the array.
--tasks_choices = ['fluxes', 'zonal', 'tcorr', 'flowtest', 'floquet','lingrowth','fluxes_stitch','potential']
-+tasks_choices = ['fluxes', 'zonal', 'tcorr', 'flowtest', 'floquet', \
-+        'linrange','fluxes_stitch','potential']
- 
- # Fom command-line arguments, get info about this analysis run (filenames, tasks to complete ...)
- run = grunpar.runobj(tasks_choices)
-diff --git a/gs2_data.py b/gs2_data.py
-index caa0918..cf35da6 100644
---- a/gs2_data.py
-+++ b/gs2_data.py
-@@ -50,6 +50,10 @@ out_varnames = [
-         'tpar_igomega_by_mode',
-         # complex perpendicular temperature fluctuation for a given theta, usually outboard mid-plane [t,spec,ky,kx,imag]
-         'tperp_igomega_by_mode',
-+        # total density at last time step [spec,ky,kx,theta,imag]
-+        'ntot',
-+        # non-adiabatic part of the density at last time step [spec,ky,kx,theta,imag]
-+        'density',
-         'gds2',
-         'gds21',
-         'gds22',
-diff --git a/gs2_data.pyc b/gs2_data.pyc
-new file mode 100644
-index 0000000..4690e61
-Binary files /dev/null and b/gs2_data.pyc differ
-diff --git a/gs2_plotting.py b/gs2_plotting.py
-index f61446b..70d41b9 100644
---- a/gs2_plotting.py
-+++ b/gs2_plotting.py
-@@ -1,15 +1,53 @@
--import numpy as np
-+import matplotlib
-+matplotlib.use('PDF')
-+from matplotlib import rcParams
- import matplotlib.pyplot as plt
- import matplotlib.colors as mcolors
--from matplotlib import rcParams
-+import numpy as np
- from PyPDF2 import PdfFileMerger, PdfFileReader
- import os
-+import scipy.interpolate as scinterp
-+from math import pi
- 
- myred = [183./255, 53./255, 53./255]
- myblue = [53./255, 118./255, 183./255]
- oxblue = [0.,33./255,71./255]
- oxbluel = [68./255,104./255,125./255]
- oxbluell = [72./255,145./255,220./255]
-+midLoRed = [255./255,178./255,172./255]
-+midHiRed = [179./255,26./255,0./255]
-+darkRed = [102./255,26./255,0./255]
-+midLoBlue = [179./255,217./255,255./255]
-+midHiBlue = [0./255,115./255,153./255]
-+darkBlue = [0./255,0./255,77./255]
-+
-+def RdBu_centered(minVal, maxVal):
-+
-+    if minVal<0 and maxVal>0:
-+        bluePart = abs(minVal)/(maxVal-minVal)
-+    elif minVal>0:
-+        bluePart = 0.0
-+    elif maxVal<0:
-+        bluePart = 1.0
-+    c = mcolors.ColorConverter().to_rgb
-+    seq = [darkBlue, midHiBlue, bluePart/3.0, \
-+            midHiBlue, midLoBlue, 2.0*bluePart/3.0, \
-+            midLoBlue, c('white'), bluePart, \
-+            c('white'), midLoRed, (1.0-bluePart)/3.0+bluePart, \
-+            midLoRed, midHiRed, 2.0*(1.0-bluePart)/3.0+bluePart, \
-+            midHiRed, darkRed]
-+    #print(bluePart)
-+    #seq = [c('blue'), c('white'), bluePart, c('white'), c('red')]
-+    seq = [(None,) * 3, 0.0] + list(seq) + [1.0, (None,) * 3]
-+    cdict = {'red': [], 'green': [], 'blue': []}
-+    for i, item in enumerate(seq):
-+        if isinstance(item, float):
-+            r1, g1, b1 = seq[i - 1]
-+            r2, g2, b2 = seq[i + 1]
-+            cdict['red'].append([item, r1, r2])
-+            cdict['green'].append([item, g1, g2])
-+            cdict['blue'].append([item, b1, b2])
-+    return mcolors.LinearSegmentedColormap('CustomMap', cdict)
- 
- def save_plot(pdfname, run, ifile = None):
- 
-@@ -55,7 +93,7 @@ def merge_pdfs(in_namelist, out_name, run, ifile = None):
- def set_plot_defaults():
- 
-     # setup some plot defaults
--    plt.rc('text', usetex=False)
-+    plt.rc('text', usetex=True)
-     plt.rc('font', family='serif')
-     plt.rc('font', size=30)
-     rcParams.update({'figure.autolayout': True})
-@@ -63,6 +101,33 @@ def set_plot_defaults():
-     rcParams.update({'legend.frameon': False})
-     #rcParams.update({'animation.ffmpeg_path':'/marconi/home/userexternal/nchriste/codes/ffmpeg'}) # for HPC use only
- 
-+
-+
-+def nearNeighb_interp_1d(x,y,xout):
-+
-+    if isinstance(x,(list)):
-+        n = len(x)
-+    elif isinstance(x,(np.ndarray)):
-+        n = x.size
-+    if isinstance(xout,(list)):
-+        nout = len(xout)
-+        yout = [0*i for i in range(nout)]
-+    elif isinstance(xout,(np.ndarray)):
-+        nout = xout.size
-+        yout = np.zeros(nout)
-+
-+    i = 0
-+    iout = 0
-+    for i in range(n-1):
-+        while xout[iout]-x[i] < (x[i+1]-x[i])/2.0:
-+            yout[iout] = y[i]
-+            iout += 1
-+    yout[iout:] = y[-1]
-+
-+    return yout
-+
-+
-+
- def plot_1d(x,y,xlab,title='',ylab=''):
- 
-     fig = plt.figure(figsize=(12,8))
-@@ -79,6 +144,10 @@ def plot_2d(z,xin,yin,zmin,zmax,xlab='',ylab='',title='',cmp='RdBu',use_logcolor
-     fig = plt.figure(figsize=(12,8))
-     x,y = np.meshgrid(xin,yin)
- 
-+    # Centered blue->red color map
-+    if cmp=='RdBu_c':
-+        cmp = RdBu_centered(zmin, zmax)
-+
-     if use_logcolor:
-         color_norm = mcolors.LogNorm(zmin,zmax)
-     else:
-@@ -95,6 +164,26 @@ def plot_2d(z,xin,yin,zmin,zmax,xlab='',ylab='',title='',cmp='RdBu',use_logcolor
-     plt.title(title)
-     return fig
- 
-+# Input:
-+# x = x[iy][ix]
-+# y = y[iy]
-+# z = z[iy][ix]
-+def plot_2d_uneven_xgrid(x, y, z, xmin, xmax, cbarmin, cbarmax, xlabel, ylabel, title, ngrid_fine = 1001):
-+
-+    # Here we assume that the scan uses a fixed set of ky.
-+    ny = y.size
-+
-+    # Finer and regular x mesh
-+    ntheta0_fine = 1001
-+    x_fine = np.linspace(xmin, xmax, ngrid_fine)
-+    z_fine = np.zeros((ny, ngrid_fine))
-+
-+    # For each ky, interpolate to nearest neighbour in x
-+    for iy in range(ny):
-+        z_fine[iy,:] = nearNeighb_interp_1d(x[iy],z[iy],x_fine)
-+
-+    plot_2d(z_fine, x_fine, y, cbarmin, cbarmax, xlabel, ylabel, title, 'RdBu_c')
-+
- def movie_2d(z,xin,yin,zmin,zmax,nframes,outfile,xlab='',ylab='',title='',step=1,cmp='RdBu'):
- 
-     from matplotlib import animation
-@@ -140,3 +229,36 @@ def movie_1d(x,y,xmin,xmax,ymin,ymax,nframes):
-                                  frames=nframes, interval=200)
- 
-     return anim
-+
-+def str_tt0(theta0):
-+
-+    n = int(round(theta0/(2.0*pi)))
-+
-+    txt = '{: .2f}'.format(theta0 - 2*pi*n)
-+
-+    if n > 0:
-+        txt += '$+' + str(2*n) + '\\pi$'
-+    elif n < 0:
-+        txt += '$-' + str(abs(2*n)) + '\\pi$'
-+
-+    return txt
-+
-+def str_t(time):
-+
-+    return '${:.2E}$'.format(time)
-+
-+def str_ky(ky):
-+
-+    return '{: .2f}'.format(ky)
-+
-+def legend_matlab(my_legend=None):
-+
-+    if my_legend:
-+        legend = plt.legend(my_legend, frameon=True, fancybox=False)
-+    else:
-+        legend = plt.legend(frameon=True, fancybox=False)
-+    frame = legend.get_frame()
-+    frame.set_facecolor('white')
-+    frame.set_edgecolor('black')
-+    frame.set_linewidth(0.5)
-+    frame.set_alpha(1)
-diff --git a/gs2_plotting.pyc b/gs2_plotting.pyc
-new file mode 100644
-index 0000000..e5cc483
-Binary files /dev/null and b/gs2_plotting.pyc differ
-diff --git a/gs2_quick_parameters.pyc b/gs2_quick_parameters.pyc
-new file mode 100644
-index 0000000..e3a771c
-Binary files /dev/null and b/gs2_quick_parameters.pyc differ
-diff --git a/gs2_run_parameters.pyc b/gs2_run_parameters.pyc
-new file mode 100644
-index 0000000..75b8eb3
-Binary files /dev/null and b/gs2_run_parameters.pyc differ
-diff --git a/gs2_tasks.py b/gs2_tasks.py
-index 7762fbe..784af2d 100644
---- a/gs2_tasks.py
-+++ b/gs2_tasks.py
-@@ -10,8 +10,8 @@ import fluxes
- import time_correlation as tcorr
- # TODO: save your python script in the task/ folder and import it here.
- import flowtest
--import floquet
--import lingrowth
-+import linbox
-+import linrange
- import potential
- import boxballoon
- 
-@@ -77,13 +77,13 @@ def complete_task_single(ifile, task, run, myin, myout, mygrids, mytime, myfield
- 
-         flowtest.store(myin, myout, task_space)
- 
--    if (task == 'floquet'):
-+    if (task == 'floquet' or task == 'linbox'):
- 
--        floquet.my_task_single(ifile, run, myin, myout, task_space)
-+        linbox.my_task_single(ifile, run, myin, myout, mytime, task_space)
- 
--    if (task == 'lingrowth'):
-+    if (task == 'linrange'):
- 
--        lingrowth.my_task_single(ifile, run, myin, myout)
-+        linrange.my_task_single(ifile, run, myin, myout, mytime)
- 
-     if (task == 'potential'):
- 
-@@ -119,9 +119,9 @@ def complete_task_scan(task, run, full_space):
- 
-         flowtest.plot(run, full_space)
- 
--    if (task == 'floquet_scan'):
-+    if (task == 'floquet_scan' or task == 'linbox_scan'):
- 
--        floquet.task_scan(run, full_space)
-+        linbox.task_scan(run, full_space)
- 
-     if (task == 'fluxes_stitch'):
-        
-diff --git a/plot_misc/.plot_scan_lingrowth_nogexb.py.swp b/plot_misc/.plot_scan_lingrowth_nogexb.py.swp
-new file mode 100644
-index 0000000..3bc072d
-Binary files /dev/null and b/plot_misc/.plot_scan_lingrowth_nogexb.py.swp differ
-diff --git a/plot_misc/algos_vs_delt_dkx.py b/plot_misc/algos_vs_delt_dkx.py
-new file mode 100644
-index 0000000..a7f6ef3
---- /dev/null
-+++ b/plot_misc/algos_vs_delt_dkx.py
-@@ -0,0 +1,149 @@
-+import numpy as np
-+import os
-+from matplotlib import pyplot as plt
-+import pickle
-+import scipy.optimize as opt
-+import sys
-+import scipy.interpolate as scinterp
-+
-+# Add path to directory where pygs2 files are stored
-+maindir = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..')
-+sys.path.insert(0, maindir)
-+
-+import gs2_plotting as gplot
-+
-+def main():
-+
-+    delt_scan = np.round(np.linspace(0.1,1.0,10),1)
-+    Ndelt = delt_scan.size
-+    jtwist_scan = [12,6,4,3,2,1] # [24,12,6,4,3,2,1]
-+    dkx_scan = np.array([0.125,0.25,0.375,0.5,0.75,1.5]) # [0.1,0.2,0.4,0.6,0.8,1.2,2.4]
-+    Ndkx = dkx_scan.size
-+
-+    gamma_nrmed_scan = np.zeros((Ndelt, Ndkx))
-+    gamma_hires = 1.0
-+
-+    for fname in os.listdir('.'):
-+
-+        if fname.endswith('.floquet.dat'):
-+
-+            my_vars = read_from_dat(fname)
-+
-+            t = my_vars['t']
-+            delt = my_vars['delt']
-+            nwrite = my_vars['nwrite']
-+            jtwist = my_vars['jtwist']
-+            g_exb = my_vars['g_exb']
-+            Nf = my_vars['Nf']
-+            iky_list = my_vars['iky_list']
-+            sum_phi2bloon = my_vars['sum_phi2bloon']
-+
-+            Tf = Nf*delt
-+            nt = t.size
-+
-+            # Determine where this file will go in gamma array
-+            idelt = int(round(delt/0.1))-1
-+            idkx = jtwist_scan.index(jtwist)
-+
-+            # Start comparing simulations at time-step it_start = N_start*Tfloquet/dt
-+            # ie after N_start Floquet oscillations
-+            # Normalise sum_phi2 by sum_phi2[it_start] for each run
-+            if g_exb != 0.0:
-+                N_start = 10 # TODO
-+                it_start = int(round((N_start*Tf/delt)/nwrite))
-+            else:
-+                fac = 0.5 # TODO
-+                it_start = round(fac*nt) # adapt this
-+
-+            iiky = 0 # Look at smallest nonzero ky
-+            iky = iky_list[iiky]
-+
-+            # Crop out first few Floquet periods
-+            sum_phi2_tmp = np.zeros(len(sum_phi2bloon[iiky])-it_start)
-+            for it in range(sum_phi2_tmp.size):
-+                sum_phi2_tmp[it] = sum_phi2bloon[iiky][it_start+it]
-+            # Nomalise sum_phi by its initial value
-+            if it_start > 0:
-+                sum_phi2_tmp = sum_phi2_tmp/sum_phi2_tmp[0]
-+            
-+            # Crop time array
-+            t_tmp = np.zeros(len(t)-it_start)
-+            for it in range(t_tmp.size):
-+                t_tmp[it] = t[it_start+it]
-+
-+            # Compute growthrate
-+            [slope,dummy] = leastsq_lin(t_tmp,np.log(sum_phi2_tmp))
-+            gamma_nrmed_scan[idelt, idkx] = slope/2. # divide by 2 because fitted square
-+
-+            # Check if this is the converged gamma to use for normalisations
-+            if idelt==0 and idkx==0:
-+                gamma_hires = slope/2.
-+
-+    # Normalise growthrates to converged value
-+    gamma_nrmed_scan = gamma_nrmed_scan/gamma_hires
-+
-+    # interpolate to nearest neighbour on fine, regular mesh ...
-+    grid_1d_dkx = np.zeros(Ndkx*Ndelt)
-+    grid_1d_delt = np.zeros(Ndkx*Ndelt)
-+    gamma_1d = np.zeros(Ndkx*Ndelt)
-+    idx_1d = 0
-+    for idkx in range(Ndkx):
-+        for idelt in range(Ndelt):
-+            grid_1d_dkx[idx_1d] = dkx_scan[idkx]
-+            grid_1d_delt[idx_1d] = delt_scan[idelt]
-+            gamma_1d[idx_1d] = gamma_nrmed_scan[idelt, idkx]
-+            idx_1d = idx_1d + 1
-+    Ndkx_fine = 1000
-+    dkx_scan_fine = np.linspace(dkx_scan.min(),dkx_scan.max(),Ndkx_fine)
-+    gamma_fine = scinterp.griddata((grid_1d_dkx, grid_1d_delt), gamma_1d, \
-+            (dkx_scan_fine[None,:], delt_scan[:,None]), method='nearest')
-+
-+    # Set up potting defaults
-+    gplot.set_plot_defaults()
-+
-+    myfig = plt.figure(figsize=(12,8))
-+    cmap = 'RdBu_r'
-+    my_xlabel = '$(\\Delta k_x)\\rho_i$'
-+    my_ylabel = '$(\\Delta t)v_{th,i}/a$'
-+    my_title = '$\\langle \\gamma \\rangle_t$'
-+    use_logcolor = False
-+    z = gamma_fine # gamma_nrmed_scan
-+    z_min, z_max = 1.0, z.max()
-+    gplot.plot_2d(z,dkx_scan_fine,delt_scan,z_min,z_max,my_xlabel,my_ylabel,my_title,cmap,use_logcolor)
-+    plt.xticks(np.round(np.array([0.25,0.5,0.75,1.5]),2))
-+    plt.yticks(delt_scan)
-+
-+    figname = 'algo_mix_vs_delt_dkx.pdf' # TODO
-+    plt.savefig(figname)
-+    
-+
-+def read_from_dat(datfile_name):
-+
-+    with open(datfile_name, 'rb') as infile: # 'rb' stands for read bytes
-+        my_vars = pickle.load(infile)
-+
-+    return my_vars
-+
-+def leastsq_lin(x, y):
-+    
-+    # y_fit = a*x + b
-+    # minimising sum((y - f_fit)^2)
-+    N_x = x.size
-+
-+    a = 1./(N_x*np.sum(np.power(x,2)) - np.sum(x)**2) * (N_x*np.sum(np.multiply(x,y)) - np.sum(x)*np.sum(y))
-+    
-+    b = 1./(N_x*np.sum(np.power(x,2)) - np.sum(x)**2) * (-1.*np.sum(x)*np.sum(np.multiply(x,y)) + np.sum(np.power(x,2))*np.sum(y))
-+
-+    return [a, b]
-+
-+def get_growthrate(t,tofit,it_start):
-+   
-+    popt, pcov = opt.curve_fit(lin_func, t[it_start:], np.log(tofit[it_start:]))
-+    return popt[0]
-+
-+def lin_func(x,a,b):
-+    return a*x+b
-+
-+# Execute main
-+if __name__ == '__main__':
-+    main()
-diff --git a/plot_misc/badshear_flx_old_vs_new.py b/plot_misc/badshear_flx_old_vs_new.py
-new file mode 100644
-index 0000000..27e5b17
---- /dev/null
-+++ b/plot_misc/badshear_flx_old_vs_new.py
-@@ -0,0 +1,146 @@
-+import sys
-+import os
-+
-+# Add path to directory where pygs2 files are stored
-+maindir = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..')
-+sys.path.insert(0, maindir)
-+
-+import pickle
-+from matplotlib import pyplot as plt
-+import gs2_plotting as gplot
-+
-+# set plotting defaults
-+gplot.set_plot_defaults()
-+
-+ispec = 0 # main ion
-+
-+dirname = 'postproc/'
-+
-+fname_new = dirname+'ollie_badshear_fexp_stitch'
-+fname_old = dirname+'ollie_badshear_old_stitch3'
-+
-+# Read in flux quantities
-+with open(fname_new+'.fluxes.dat','rb') as datfile:
-+    fluxdict_new = pickle.load(datfile)
-+with open(fname_old+'.fluxes.dat','rb') as datfile:
-+    fluxdict_old = pickle.load(datfile)
-+
-+vflx_new = fluxdict_new['vflx']
-+vflx_old = fluxdict_old['vflx']
-+qflx_new = fluxdict_new['qflx']
-+qflx_old = fluxdict_old['qflx']
-+vflx_tavg_new = fluxdict_new['vflx_tavg'][ispec]
-+qflx_tavg_new = fluxdict_new['qflx_tavg'][ispec]
-+vflx_tavg_old = fluxdict_old['vflx_tavg'][ispec]
-+qflx_tavg_old = fluxdict_old['qflx_tavg'][ispec]
-+
-+# Read in time quantities
-+with open(fname_new+'.time.dat','rb') as datfile:
-+    mytime_new = pickle.load(datfile)
-+with open(fname_old+'.time.dat','rb') as datfile:
-+    mytime_old = pickle.load(datfile)
-+
-+time_new = mytime_new.time
-+time_old = mytime_old.time
-+
-+##########################
-+## PLOT MOMENTUM FLUX
-+##########################
-+
-+fig=plt.figure(figsize=(12,8))
-+
-+# indicating area of saturation
-+plt.axvline(x=mytime_new.time_steady[0], color='grey', linestyle='-')
-+ax = plt.gca()
-+ax.axvspan(mytime_new.time_steady[0], max(mytime_new.time_steady[-1],mytime_old.time_steady[-1]), alpha=0.1, color='grey')
-+
-+# plot time-traces for each species
-+my_curves = []
-+my_labels = ['discrete-in-time','continuous-in-time']
-+crv_old, = plt.plot(mytime_old.time,vflx_old[:,ispec],color=gplot.myblue,linewidth=3.0)
-+my_curves.append(crv_old)
-+crv_new, = plt.plot(mytime_new.time,vflx_new[:,ispec],color=gplot.myred,linewidth=3.0)
-+my_curves.append(crv_new)
-+
-+plt.xlabel('$t [a/v_{th,i}]$',FontSize='35')
-+plt.ylabel('$\Pi_i/\Pi_{gB}$',FontSize='35')
-+plt.xlim([mytime_new.time[0],max(mytime_new.time[-1],mytime_old.time[-1])])
-+plt.ylim([-0.1,2.0])
-+plt.grid(True)
-+
-+my_legend = plt.legend(my_curves,my_labels,frameon=True,fancybox=False,framealpha=1.0,loc='lower right',prop={'size': 28})
-+my_legend.get_frame().set_facecolor('w')
-+my_legend.get_frame().set_edgecolor('k')
-+my_legend.get_frame().set_linewidth(1.0)
-+
-+# Annotate
-+xpos = mytime_new.time[-1]*0.05
-+ypos_new = vflx_tavg_new
-+note_str_new = 'avg = {:.2f}'.format(vflx_tavg_new)
-+ypos_old = vflx_tavg_old
-+note_str_old = 'avg = {:.2f}'.format(vflx_tavg_old)
-+
-+note_coords = 'data'
-+note_xy_new = (xpos, ypos_new)
-+note_xy_old = (xpos, ypos_old)
-+
-+plt.annotate(note_str_old, xy=note_xy_old, xycoords=note_coords, color=gplot.myblue, \
-+        fontsize=30, backgroundcolor='w', \
-+        bbox=dict(facecolor='w', edgecolor=gplot.myblue, alpha=1.0))
-+plt.annotate(note_str_new, xy=note_xy_new, xycoords=note_coords, color=gplot.myred, \
-+        fontsize=30, backgroundcolor='w', \
-+        bbox=dict(facecolor='w', edgecolor=gplot.myred, alpha=1.0))
-+
-+filename = dirname + 'badshear_vflx_old_vs_new_final' + '.pdf'
-+plt.savefig(filename)
-+
-+##########################
-+## PLOT HEAT FLUX
-+##########################
-+
-+fig=plt.figure(figsize=(12,8))
-+
-+# indicating area of saturation
-+plt.axvline(x=mytime_new.time_steady[0], color='grey', linestyle='-')
-+ax = plt.gca()
-+ax.axvspan(mytime_new.time_steady[0], max(mytime_new.time_steady[-1],mytime_old.time_steady[-1]), alpha=0.1, color='grey')
-+
-+# plot time-traces for each species
-+my_curves = []
-+my_labels = ['discrete-in-time','continuous-in-time']
-+crv_old, = plt.plot(mytime_old.time,qflx_old[:,ispec],color=gplot.myblue,linewidth=3.0)
-+my_curves.append(crv_old)
-+crv_new, = plt.plot(mytime_new.time,qflx_new[:,ispec],color=gplot.myred,linewidth=3.0)
-+my_curves.append(crv_new)
-+
-+plt.xlabel('$t [a/v_{th,i}]$',FontSize='35')
-+plt.ylabel('$Q_i/Q_{gB}$',FontSize='35')
-+plt.xlim([mytime_new.time[0],max(mytime_new.time[-1],mytime_old.time[-1])])
-+plt.ylim([-0.1,4.0])
-+plt.grid(True)
-+
-+my_legend = plt.legend(my_curves,my_labels,frameon=True,fancybox=False,framealpha=1.0,loc='lower right',prop={'size': 28})
-+my_legend.get_frame().set_facecolor('w')
-+my_legend.get_frame().set_edgecolor('k')
-+my_legend.get_frame().set_linewidth(1.0)
-+
-+# Annotate
-+xpos = mytime_new.time[-1]*0.1
-+ypos_new = qflx_tavg_new
-+note_str_new = 'avg = {:.2f}'.format(qflx_tavg_new)
-+ypos_old = qflx_tavg_old
-+note_str_old = 'avg = {:.2f}'.format(qflx_tavg_old)
-+
-+note_coords = 'data'
-+note_xy_new = (xpos, ypos_new)
-+note_xy_old = (xpos, ypos_old)
-+
-+plt.annotate(note_str_old, xy=note_xy_old, xycoords=note_coords, color=gplot.myblue, \
-+        fontsize=30, backgroundcolor='w', \
-+        bbox=dict(facecolor='w', edgecolor=gplot.myblue, alpha=1.0))
-+plt.annotate(note_str_new, xy=note_xy_new, xycoords=note_coords, color=gplot.myred, \
-+        fontsize=30, backgroundcolor='w', \
-+        bbox=dict(facecolor='w', edgecolor=gplot.myred, alpha=1.0))
-+
-+filename = dirname + 'badshear_qflx_old_vs_new_final' + '.pdf'
-+plt.savefig(filename)
-diff --git a/plot_misc/badshear_zonal_compare.py b/plot_misc/badshear_zonal_compare.py
-new file mode 100644
-index 0000000..4558e2c
---- /dev/null
-+++ b/plot_misc/badshear_zonal_compare.py
-@@ -0,0 +1,101 @@
-+import sys
-+import os
-+
-+# Add path to directory where pygs2 files are stored
-+maindir = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..')
-+sys.path.insert(0, maindir)
-+
-+import pickle
-+from matplotlib import pyplot as plt
-+import gs2_plotting as gplot
-+import numpy as np
-+
-+# set plotting defaults
-+gplot.set_plot_defaults()
-+
-+ispec = 0 # main ion
-+
-+dirname = 'postproc/'
-+
-+fname_new = dirname+'ollie_badshear_fexp_stitch'
-+fname_old = dirname+'ollie_badshear_old_stitch3'
-+
-+# Read in flux quantities
-+with open(fname_new+'.fluxes.dat','rb') as datfile:
-+    fluxdict_new = pickle.load(datfile)
-+with open(fname_old+'.fluxes.dat','rb') as datfile:
-+    fluxdict_old = pickle.load(datfile)
-+
-+phi2_by_ky_new = fluxdict_new['phi2_by_ky']
-+phi2_by_ky_old = fluxdict_old['phi2_by_ky']
-+
-+# Read in time quantities
-+with open(fname_new+'.time.dat','rb') as datfile:
-+    mytime_new = pickle.load(datfile)
-+with open(fname_old+'.time.dat','rb') as datfile:
-+    mytime_old = pickle.load(datfile)
-+
-+time_new = mytime_new.time
-+time_old = mytime_old.time
-+
-+# Read in grids
-+with open('postproc/ollie_badshear_fexp_id_1.grids.dat','rb') as datfile:
-+    mygrids = pickle.load(datfile)
-+
-+ky = mygrids.ky
-+
-+##########################
-+## PLOT PHI2 FOR EVERY KY
-+##########################
-+
-+## NEW
-+clr_new = plt.cm.YlOrBr(np.linspace(0.2,1,4))
-+clr_old = plt.cm.YlGnBu(np.linspace(0.2,1,4))
-+my_linewidth = 4.0
-+my_xlim = [mytime_new.time[0],max(mytime_new.time[-1],mytime_old.time[-1])]
-+my_ylim = [1.e-6, 1.e3]
-+my_xlabel = '$t [a/v_{th,i}]$'
-+my_ylabel = '$\\vert \\langle \\hat{\\varphi}\\rangle _{\\theta,k_x}\\vert ^2$'
-+
-+fig = plt.figure(figsize=(10,10))
-+
-+plt.semilogy(time_new,phi2_by_ky_new[:,0],label='$\\rho k_y = {:.2f}$'.format(ky[0]),linestyle='dashed',
-+        color=clr_new[3],linewidth=my_linewidth)
-+plt.semilogy(time_new,phi2_by_ky_new[:,1],label='$\\rho k_y = {:.2f}$'.format(ky[1]),
-+        color=clr_new[2],linewidth=my_linewidth)
-+
-+plt.xlabel(my_xlabel,FontSize='38')
-+plt.ylabel(my_ylabel,FontSize='40')
-+plt.xlim(my_xlim)
-+plt.ylim(my_ylim)
-+plt.grid(True)
-+
-+my_legend = plt.legend(frameon=True,fancybox=False,framealpha=1.0,loc='lower right',prop={'size': 35})
-+my_legend.get_frame().set_facecolor('w')
-+my_legend.get_frame().set_edgecolor('k')
-+my_legend.get_frame().set_linewidth(1.0)
-+
-+filename = dirname + 'badshear_zonal_new' + '.pdf'
-+plt.savefig(filename)
-+
-+## OLD
-+fig = plt.figure(figsize=(10,10))
-+
-+plt.semilogy(time_old,phi2_by_ky_old[:,0],label='$\\rho k_y = {:.2f}$'.format(ky[0]),linestyle='dashed',
-+        color=clr_old[3],linewidth=my_linewidth)
-+plt.semilogy(time_old,phi2_by_ky_old[:,1],label='$\\rho k_y = {:.2f}$'.format(ky[1]),
-+        color=clr_old[2],linewidth=my_linewidth)
-+
-+plt.xlabel(my_xlabel,FontSize='38')
-+plt.ylabel(my_ylabel,FontSize='40')
-+plt.xlim(my_xlim)
-+plt.ylim(my_ylim)
-+plt.grid(True)
-+
-+my_legend = plt.legend(frameon=True,fancybox=False,framealpha=1.0,loc='lower right',prop={'size': 35})
-+my_legend.get_frame().set_facecolor('w')
-+my_legend.get_frame().set_edgecolor('k')
-+my_legend.get_frame().set_linewidth(1.0)
-+
-+filename = dirname + 'badshear_zonal_old' + '.pdf'
-+plt.savefig(filename)
-diff --git a/plot_misc/linbox_scan.py b/plot_misc/linbox_scan.py
-new file mode 100644
-index 0000000..5f28cbf
---- /dev/null
-+++ b/plot_misc/linbox_scan.py
-@@ -0,0 +1,562 @@
-+import sys
-+import os
-+
-+# Add path to directory where scan-files are stored
-+sys.path.insert(1, '/marconi/home/userexternal/nchriste/codes/scan_gs2/paramfiles')
-+# Add path to directory where gs2_plotting is stored
-+sys.path.insert(1, '/marconi/home/userexternal/nchriste/codes/diagnostics_gs2')
-+
-+import f90nml as fnml
-+import numpy as np
-+import copy as cp
-+import pickle
-+import matplotlib.pyplot as plt
-+from matplotlib import rcParams
-+from math import pi
-+import scipy.interpolate as scinterp
-+import scipy.optimize as opt
-+import gs2_plotting as gplot
-+from PyPDF2 import PdfFileMerger, PdfFileReader
-+
-+plt.rc('text', usetex=True)
-+plt.rc('font', family='serif')
-+plt.rc('font', size=20)
-+rcParams.update({'figure.autolayout': True})
-+rcParams.update({'legend.fontsize': 12, 'legend.handlelength': 4})
-+rcParams.update({'legend.frameon': False})
-+
-+ONE = 'one'
-+TWO = 'two'
-+NDIM_MAX = TWO
-+
-+# Dict that will contain every parameter to scan
-+scan = {ONE:[],TWO:[]}
-+
-+
-+
-+
-+
-+
-+# vvv USER PARAMETERS vvv
-+
-+# Import all parameters from paramfiles/myfile.py
-+base_name = 'rpsi_0.6'  
-+pf = __import__('scan_ky_kxmax_fixed_dkx_ijp_950_rpsi_06')  
-+
-+# Number of dimensions in the scan
-+# e.g. vs (ky, R/LTi) -> ndim = TWO
-+ndim = TWO
-+
-+# Define which dmid to use when plotting quant vs ky.
-+# dmid is the number of dkx between kx=0 and the
-+# smallest kx>0 that is a member of a particular
-+# twist and shift chain at t=0, ie it identifies that chain.
-+dmid_for_plots_vs_ky = 0
-+
-+# Define first dimension of the scan
-+firstdim_label = '$\\rho_i k_y$' # for plotting
-+firstdim_var = 'ky' # name of variable to append to figure names
-+firstdim = pf.ky # variable name in paramfiles/myfile.py
-+
-+# Define second dimension of the scan
-+if ndim == TWO:
-+
-+    #seconddim_label = '$N_x = {0:d}$'.format(seconddim[ival]))  
-+    #seconddim_label = '$N_{2\\pi}$'
-+    seconddim_label = '$k_{x,max}$'
-+    #seconddim_label = '$\\Delta k_x$'
-+    #seconddim_label = '$\\rho k_y$'
-+    #seconddim_label = '$N_\\theta$'
-+    #seconddim_label = '$N_\\varepsilon$'
-+    #seconddim_label = '$v_{max}$'
-+    #seconddim_label = '$N_{\\lambda,untrap}$'
-+    #seconddim_label = '$a/L_{T_e}$'
-+    #seconddim_label = '$\gamma_E$$'
-+
-+    seconddim_var = 'nx'  
-+
-+    #seconddim = (2*np.round((pf.nx-1)/3)+1).astype(int) # nakx
-+    seconddim = np.round((pf.nx-1)/3) * pf.dkx  # kxmax
-+    #seconddim = np.round((2*np.round((pf.nx-1)/3))/(2*pi*pf.shat*firstdim[-1]/pf.dkx)+1,2) # Ntwopi
-+    #seconddim = pf.negrid  
-+
-+elif ndim == ONE:
-+
-+    seconddim_label = '_dummy'
-+    seconddim_var = 'dummy'
-+    seconddim = np.array([0])
-+
-+# Does the scan have only a single ky ?
-+scan_with_single_ky = False  
-+
-+# Apply limits to axis when plotting ?
-+use_my_xlim = False
-+my_xlim = (0.0, 2.0)  
-+
-+use_my_ylim = False
-+my_ylim_max = (0.0, 0.35)
-+my_ylim_avg = (-0.05, 0.15)
-+
-+# Fix colorbar limits ?
-+fix_cbarlim = True
-+my_cbarmin = -0.015
-+my_cbarmax = 0.105
-+
-+# Original code was written for kyas second dim of scan (not first).
-+# To restore this, set invert_dims = True
-+invert_dims = False  
-+
-+# ^^^ USER PARAMETERS ^^^
-+
-+
-+
-+
-+
-+
-+def main():
-+
-+    if scan_with_single_ky:
-+        valdim = firstdim.size
-+    else:
-+        valdim = seconddim.size
-+
-+    # Add all parameters to the current scan
-+    nparams = len(pf.name)
-+    for iparam in range(nparams):
-+        add_param_to_scan(scan, pf.name[iparam], pf.dim[iparam], pf.namelist[iparam], pf.scandim[iparam], pf.func[iparam])
-+
-+    # Read data from .dat files for every file in scan
-+    g_exb_vs_v2_ky_tt0 = []
-+    dmid_list_vs_v2_ky_tt0 = []
-+    itheta0_list_vs_v2_ky_tt0 = []
-+    theta0_vs_v2_ky_tt0 = []
-+    firstdim_vs_v2_ky_tt0 = []
-+    gamma_avg_vs_v2_ky_tt0 = []
-+    gamma_max_vs_v2_ky_tt0 = []
-+    Qratio_avg_vs_v2_ky_tt0 = []
-+    scandim=ONE
-+    ival_firstdim = -1
-+    valtree = [0*i for i in range(nparams)]
-+    read_data(base_name, valtree, scandim, ival_firstdim, dmid_list_vs_v2_ky_tt0, itheta0_list_vs_v2_ky_tt0, theta0_vs_v2_ky_tt0, \
-+            firstdim_vs_v2_ky_tt0, gamma_avg_vs_v2_ky_tt0, gamma_max_vs_v2_ky_tt0, Qratio_avg_vs_v2_ky_tt0, g_exb_vs_v2_ky_tt0)
-+
-+
-+
-+
-+    # Re-organise data
-+
-+    if not invert_dims:
-+
-+        # Arrays for data with all theta0
-+        dmid_list_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-+        itheta0_list_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-+        theta0_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-+        firstdim_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-+        gamma_avg_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-+        gamma_max_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-+        Qratio_avg_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-+        g_exb_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-+
-+        # Arrays for data with only theta0 = 0
-+        firstdim_vs_v2_ky = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-+        gamma_avg_vs_v2_ky = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-+        gamma_max_vs_v2_ky = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-+        Qratio_avg_vs_v2_ky = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-+        g_exb_vs_v2_ky = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-+
-+        for ival_first in range(firstdim.size):
-+
-+            for ival_scnd in range(seconddim.size):
-+
-+                # Rearrange keeping all theta0
-+                dmid_list_vs_v2_ky_tt0_new[ival_scnd][ival_first] = dmid_list_vs_v2_ky_tt0[ival_first][ival_scnd]
-+                itheta0_list_vs_v2_ky_tt0_new[ival_scnd][ival_first] = itheta0_list_vs_v2_ky_tt0[ival_first][ival_scnd]
-+                theta0_vs_v2_ky_tt0_new[ival_scnd][ival_first] = theta0_vs_v2_ky_tt0[ival_first][ival_scnd]
-+                firstdim_vs_v2_ky_tt0_new[ival_scnd][ival_first] = firstdim_vs_v2_ky_tt0[ival_first][ival_scnd]
-+                gamma_avg_vs_v2_ky_tt0_new[ival_scnd][ival_first] = gamma_avg_vs_v2_ky_tt0[ival_first][ival_scnd]
-+                gamma_max_vs_v2_ky_tt0_new[ival_scnd][ival_first] = gamma_max_vs_v2_ky_tt0[ival_first][ival_scnd]
-+                Qratio_avg_vs_v2_ky_tt0_new[ival_scnd][ival_first] = Qratio_avg_vs_v2_ky_tt0[ival_first][ival_scnd]
-+                g_exb_vs_v2_ky_tt0_new[ival_scnd][ival_first] = g_exb_vs_v2_ky_tt0[ival_first][ival_scnd]
-+
-+                # try to find the index of theta0 = 0
-+                idmid = 0
-+                try:
-+                    while dmid_list_vs_v2_ky_tt0[ival_first][ival_scnd][idmid] != dmid_for_plots_vs_ky:
-+                        idmid += 1
-+                except:
-+                    idmid = 0
-+
-+                # Rearrange keeping only theta0 = 0
-+                firstdim_vs_v2_ky[ival_scnd][ival_first] = firstdim_vs_v2_ky_tt0[ival_first][ival_scnd]
-+                gamma_avg_vs_v2_ky[ival_scnd][ival_first] = gamma_avg_vs_v2_ky_tt0[ival_first][ival_scnd][idmid]
-+                gamma_max_vs_v2_ky[ival_scnd][ival_first] = gamma_max_vs_v2_ky_tt0[ival_first][ival_scnd][idmid]
-+                Qratio_avg_vs_v2_ky[ival_scnd][ival_first] = Qratio_avg_vs_v2_ky_tt0[ival_first][ival_scnd]
-+                g_exb_vs_v2_ky[ival_scnd][ival_first] = g_exb_vs_v2_ky_tt0[ival_first][ival_scnd]
-+
-+        # Overwrite old arrays
-+        dmid_list_vs_v2_ky_tt0 = dmid_list_vs_v2_ky_tt0_new
-+        itheta0_list_vs_v2_ky_tt0 = itheta0_list_vs_v2_ky_tt0_new
-+        theta0_vs_v2_ky_tt0 = theta0_vs_v2_ky_tt0_new
-+        firstdim_vs_v2_ky_tt0 = firstdim_vs_v2_ky_tt0_new
-+        gamma_avg_vs_v2_ky_tt0 = gamma_avg_vs_v2_ky_tt0_new
-+        gamma_max_vs_v2_ky_tt0 = gamma_max_vs_v2_ky_tt0_new
-+        Qratio_avg_vs_v2_ky_tt0 = Qratio_avg_vs_v2_ky_tt0_new
-+        g_exb_vs_v2_ky_tt0 = g_exb_vs_v2_ky_tt0_new
-+
-+        # Get rid of extra dimension if ndim=1
-+        if ndim == ONE:
-+
-+            dmid_list_vs_v2_ky_tt0 = dmid_list_vs_v2_ky_tt0[0]
-+            dmid_list_vs_v2_ky = dmid_list_vs_v2_ky[0]
-+            itheta0_list_vs_v2_ky_tt0 = itheta0_list_vs_v2_ky_tt0[0]
-+            itheta0_list_vs_v2_ky = itheta0_list_vs_v2_ky[0]
-+            theta0_vs_v2_ky_tt0 = theta0_vs_v2_ky_tt0[0]
-+            theta0_vs_v2_ky = theta0_vs_v2_ky[0]
-+            firstdim_vs_v2_ky_tt0 = firstdim_vs_v2_ky_tt0[0]
-+            firstdim_vs_v2_ky = firstdim_vs_v2_ky[0]
-+            gamma_avg_vs_v2_ky_tt0 = gamma_avg_vs_v2_ky_tt0[0]
-+            gamma_avg_vs_v2_ky = gamma_avg_vs_v2_ky[0]
-+            gamma_max_vs_v2_ky_tt0 = gamma_max_vs_v2_ky_tt0[0]
-+            gamma_max_vs_v2_ky = gamma_max_vs_v2_ky[0]
-+            Qratio_avg_vs_v2_ky_tt0 = Qratio_avg_vs_v2_ky_tt0[0]
-+            Qratio_avg_vs_v2_ky = Qratio_avg_vs_v2_ky[0]
-+            g_exb_vs_v2_ky = g_exb_vs_v2_ky[0]
-+
-+    # Save data vs var2,ky with all theta0
-+    vardict = {}
-+    vardict['dmid_list_vs_v2_ky_tt0'] = dmid_list_vs_v2_ky_tt0
-+    vardict['itheta0_list_vs_v2_ky_tt0'] = itheta0_list_vs_v2_ky_tt0
-+    vardict['theta0_vs_v2_ky_tt0'] = theta0_vs_v2_ky_tt0
-+    vardict['firstdim_vs_v2_ky_tt0'] = firstdim_vs_v2_ky_tt0
-+    vardict['gamma_avg_vs_v2_ky_tt0'] = gamma_avg_vs_v2_ky_tt0
-+    vardict['gamma_max_vs_v2_ky_tt0'] = gamma_max_vs_v2_ky_tt0
-+    vardict['Qratio_avg_vs_v2_ky_tt0'] = Qratio_avg_vs_v2_ky_tt0
-+    vardict['g_exb_vs_v2_ky_tt0'] = g_exb_vs_v2_ky_tt0
-+    write_to_file(vardict)
-+
-+    # Here we assume that all runs have the same g_exb
-+    g_exb = g_exb_vs_v2_ky[0][0]
-+
-+
-+
-+
-+
-+
-+    # Plotting
-+
-+    # Plots vs ky and vs seconddim
-+
-+    if ndim == ONE:
-+
-+        pdfname = 'postproc/linbox_gamma_avg_scan_'+firstdim_var+'.pdf'
-+        plt.figure()
-+        my_legend = []
-+        plt.grid(True)
-+        plt.xlabel(firstdim_label)
-+        if g_exb == 0.0:
-+            plt.ylabel('$\\gamma [v_{th}/a]$')
-+        else:
-+            plt.ylabel('$\\langle\\gamma\\rangle_t [v_{th}/a]$')
-+        plt.plot(firstdim_vs_v2_ky, gamma_avg_vs_v2_ky, linewidth=2.0, color='k')
-+        if use_my_ylim:
-+            plt.ylim(my_ylim_avg)
-+        plt.savefig(pdfname)
-+
-+        pdfname = 'postproc/linbox_gamma_max_scan_'+firstdim_var+'.pdf'
-+        plt.figure()
-+        my_legend = []
-+        plt.grid(True)
-+        plt.xlabel(firstdim_label)
-+        if g_exb == 0.0:
-+            plt.ylabel('$\\gamma [v_{th}/a]$')
-+        else:
-+            plt.ylabel('$\\langle\\gamma\\rangle_t [v_{th}/a]$')
-+        plt.plot(firstdim_vs_v2_ky, gamma_max_vs_v2_ky, linewidth=2.0, color='k')
-+        if use_my_ylim:
-+            plt.ylim(my_ylim_max)
-+        plt.savefig(pdfname)
-+
-+    elif ndim == TWO:
-+
-+        color_vs_v2_ky = plt.cm.gnuplot_r(np.linspace(0.05,0.9,seconddim.size))
-+        if scan_with_single_ky:
-+            color_vs_v2_ky = ['blue']
-+
-+        pdfname = 'postproc/linbox_gamma_avg_scan_'+firstdim_var+'_'+seconddim_var+'.pdf'
-+        plt.figure()
-+        my_legend = []
-+        plt.grid(True)
-+        plt.xlabel(firstdim_label)
-+        if g_exb == 0.0:
-+            plt.ylabel('$\\gamma [v_{th}/a]$')
-+        else:
-+            plt.ylabel('$\\langle\\gamma\\rangle_t [v_{th}/a]$')
-+        for ival in range(valdim):
-+            if scan_with_single_ky:
-+                plt.plot(seconddim, gamma_avg_vs_v2_ky, linewidth=2.0, color=color_vs_v2_ky[ival])
-+            else:
-+                plt.plot(firstdim_vs_v2_ky[ival], gamma_avg_vs_v2_ky[ival], linewidth=2.0, color=color_vs_v2_ky[ival])
-+            my_legend.append(seconddim_label + '$=' + str(seconddim[ival]) + '$')
-+        if use_my_ylim:
-+            plt.ylim(my_ylim_avg)
-+        if use_my_xlim:
-+            plt.xlim(my_xlim)
-+        legend = plt.legend(my_legend, frameon = True, fancybox = False)
-+        frame = legend.get_frame()
-+        frame.set_facecolor('white')
-+        frame.set_edgecolor('black')
-+        frame.set_linewidth(0.5)
-+        frame.set_alpha(1)
-+        plt.savefig(pdfname)
-+
-+        pdfname = 'postproc/linbox_gamma_max_scan_'+firstdim_var+'_'+seconddim_var+'.pdf'
-+        plt.figure()
-+        my_legend = []
-+        plt.grid(True)
-+        plt.xlabel(firstdim_label)
-+        if g_exb == 0.0:
-+            plt.ylabel('$\\gamma [v_{th}/a]$')
-+        else:
-+            plt.ylabel('$\\gamma_{max}\ [v_{th}/a]$')
-+        for ival in range(valdim):
-+            if scan_with_single_ky:
-+                plt.plot(seconddim, gamma_max_vs_v2_ky, linewidth=2.0, color=color_vs_v2_ky[ival])
-+            else:
-+                plt.plot(firstdim_vs_v2_ky[ival], gamma_max_vs_v2_ky[ival], linewidth=2.0, color=color_vs_v2_ky[ival])
-+            my_legend.append(seconddim_label + '$=' + str(seconddim[ival]) + '$')
-+        if use_my_ylim:
-+            plt.ylim(my_ylim_max)
-+        if use_my_xlim:
-+            plt.xlim(my_xlim)
-+        legend = plt.legend(my_legend, frameon = True, fancybox = False, fontsize=8)
-+        frame = legend.get_frame()
-+        frame.set_facecolor('white')
-+        frame.set_edgecolor('black')
-+        frame.set_linewidth(0.5)
-+        frame.set_alpha(1)
-+        plt.savefig(pdfname)
-+
-+        try:
-+            pdfname = 'postproc/linbox_qe_vs_qi_scan_'+seconddim_var+'.pdf'
-+            plt.figure()
-+            my_legend = []
-+            plt.grid(True)
-+            plt.xlabel(seconddim_label)
-+            plt.ylabel('$\\langle Q_e/Q_i\\rangle_t$')
-+            plt.plot(seconddim, Qratio_avg_vs_v2_ky, linewidth=2.0, color='k')
-+            plt.savefig(pdfname)
-+        except:
-+            print('Fluxes cannot be found in the output.')
-+
-+    # When g_exb = 0, plot gamma vs (theta0, ky),
-+    # for every value of the second dimension in the scan.
-+    
-+    if firstdim_var == 'ky' and g_exb == 0.0:
-+
-+        # Preparing to stitch multiple pdfs together
-+        tmp_pdf_id = 1
-+        pdflist = []
-+
-+        # Here we assume that the scan uses a fixed set of ky.
-+        ky = np.array(firstdim_vs_v2_ky_tt0[0])
-+        naky = ky.size
-+
-+        for ival in range(valdim):
-+
-+            gamma_min = 1e20
-+            gamma_max = -1e20
-+
-+            theta0 = []
-+            gamma = []
-+
-+            for iky in range(naky):
-+
-+                theta0.append([])
-+                gamma.append([])
-+
-+                ntheta0 = len(itheta0_list_vs_v2_ky_tt0[ival][iky])
-+
-+                for iitheta0 in range(ntheta0):
-+
-+                    this_theta0 = theta0_vs_v2_ky_tt0[ival][iky][itheta0_list_vs_v2_ky_tt0[ival][iky][iitheta0]]
-+                    this_gamma = gamma_avg_vs_v2_ky_tt0[ival][iky][iitheta0]
-+
-+                    theta0[iky].append(this_theta0)
-+                    gamma[iky].append(this_gamma)
-+
-+                    # Update min and max gamma
-+                    if this_gamma < gamma_min:
-+                        gamma_min = this_gamma
-+                    if this_gamma > gamma_max:
-+                        gamma_max = this_gamma
-+
-+            xlabel = '$\\theta_0$'
-+            ylabel = '$k_y$'
-+            title = '$\\gamma\ [v_{th}/a]$' + ', ' + seconddim_label + '$= {:.2f}$'.format(seconddim[ival])
-+            if fix_cbarlim:
-+                cbarmin = my_cbarmin
-+                cbarmax = my_cbarmax
-+            else:
-+                cbarmin = gamma_min
-+                cbarmax = gamma_max
-+            gplot.plot_2d_uneven_xgrid(theta0, ky, gamma, -pi, pi, \
-+                    cbarmin, cbarmax, xlabel, ylabel, title, 1001)
-+
-+            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-+            plt.savefig('postproc/'+tmp_pdfname+'.pdf')
-+            pdflist.append(tmp_pdfname)
-+            tmp_pdf_id = tmp_pdf_id+1
-+
-+        # Stitch the pdfs together
-+        merged_pdfname = 'linbox_gam_vs_theta0_ky'
-+        merge_pdfs(pdflist, merged_pdfname, 'postproc/')
-+
-+
-+
-+
-+
-+
-+class gs2_param:
-+    def __init__(self, var='', dim=np.array([]), in_list='', func=None):
-+        self.name = var
-+        self.dim = dim
-+        self.namelist = in_list
-+        self.func = func
-+
-+
-+
-+
-+
-+def add_param_to_scan(scan, name, dim, namelist, scandim, func):
-+    newparam = gs2_param(name, dim, namelist, func)
-+    if scandim == ONE:
-+        scan[ONE].append(newparam)
-+    elif scandim == TWO:
-+        scan[TWO].append(newparam)
-+    else:
-+        sys.exit('ERROR: this code only supports up to '+NDIM_MAX+' dimensions for a scan.')
-+
-+
-+
-+
-+
-+def increment_dim(scandim):
-+    if scandim == ONE:
-+        scandim = TWO
-+    else:
-+        scandim = END
-+    return scandim
-+
-+
-+
-+
-+
-+def read_data(fname, valtree, scandim, ival_firstdim, dmid_list_vs_v2_ky, itheta0_list_vs_v2_ky, theta0_vs_v2_ky, \
-+        firstdim_vs_v2_ky, gamma_avg_vs_v2_ky, gamma_max_vs_v2_ky, Qratio_avg_vs_v2_ky, g_exb_vs_v2_ky):
-+
-+    # Iterate over every set of values taken by parameters in this dimension of the scan.
-+    for ival in range(scan[scandim][0].dim):
-+    
-+        # Name-base and patch to be modified for this ival.
-+        my_fname = fname
-+
-+        # For every new value of firstdim, append elements
-+        if scandim==ONE and ival_firstdim!=ival:
-+            ival_firstdim = ival
-+            g_exb_vs_v2_ky.append([])
-+            dmid_list_vs_v2_ky.append([])
-+            itheta0_list_vs_v2_ky.append([])
-+            theta0_vs_v2_ky.append([])
-+            firstdim_vs_v2_ky.append([])
-+            gamma_avg_vs_v2_ky.append([])
-+            gamma_max_vs_v2_ky.append([])
-+            Qratio_avg_vs_v2_ky.append([])
-+
-+        # For every parameter in this dimension of the scan, modify the files.
-+        for iparam in range(len(scan[scandim])):
-+            # Append parameter to namelist for in-file patching
-+            var = scan[scandim][iparam].name
-+            val = scan[scandim][iparam].func(ival,valtree)
-+            # Append parameter to the filenames
-+            my_fname = my_fname + '_' + var + '_' + str(val)
-+            # Update history tree
-+            if scandim == ONE:
-+                iparam_all = iparam
-+            if scandim == TWO:
-+                iparam_all = len(scan[ONE]) + iparam
-+            valtree[iparam_all] = val
-+        
-+        # If we are at the bottom of the tree, then read from the file.
-+        if scandim == ndim:
-+            my_vars = read_from_file(my_fname)
-+            g_exb_vs_v2_ky[ival_firstdim].append(my_vars['g_exb'])
-+            dmid_list_vs_v2_ky[ival_firstdim].append(my_vars['dmid_list'])
-+            itheta0_list_vs_v2_ky[ival_firstdim].append(my_vars['itheta0_list'])
-+            theta0_vs_v2_ky[ival_firstdim].append(my_vars['theta0'])
-+            firstdim_vs_v2_ky[ival_firstdim].append(my_vars[firstdim_var])
-+            gamma_avg_vs_v2_ky[ival_firstdim].append(my_vars['gamma_avg'])
-+            gamma_max_vs_v2_ky[ival_firstdim].append(my_vars['gamma_max'])
-+            Qratio_avg_vs_v2_ky[ival_firstdim].append(my_vars['Qratio_avg'])
-+        # Or move on to the next dimension of the scan by calling function recursively
-+        else:
-+            next_scandim = increment_dim(scandim)
-+            read_data(my_fname, valtree, next_scandim, ival_firstdim, dmid_list_vs_v2_ky, itheta0_list_vs_v2_ky, theta0_vs_v2_ky, \
-+                    firstdim_vs_v2_ky, gamma_avg_vs_v2_ky, gamma_max_vs_v2_ky, Qratio_avg_vs_v2_ky, g_exb_vs_v2_ky)
-+
-+
-+
-+
-+def read_from_file(fname):
-+
-+    datfile_name = 'postproc/' + fname + '.linbox.dat' ### USER ###
-+
-+    my_vars = {}
-+
-+    if os.path.getsize(datfile_name) > 0:
-+        with open(datfile_name, 'rb') as infile: # 'rb' stands for read bytes
-+            unpickler = pickle.Unpickler(infile)
-+            my_vars = unpickler.load()
-+            #my_vars = pickle.load(infile)
-+    else:
-+        print("Cannot open file: " + "'" + datfile_name + "'\n")
-+
-+    return my_vars
-+
-+
-+
-+
-+def write_to_file(vardict):
-+
-+    datfile_name = 'postproc/linbox_scan.dat'
-+    with open(datfile_name, 'wb') as outfile: # 'wb' stands for write bytes
-+        pickle.dump(vardict,outfile)
-+
-+
-+
-+def merge_pdfs(in_namelist, out_name, out_dir):
-+
-+    # read all tmp pdfs to be merged
-+    merger = PdfFileMerger()
-+    for pdfname in in_namelist:
-+        file_name = out_dir + pdfname + '.pdf'
-+        with open(file_name, 'rb') as pdffile:
-+            merger.append(PdfFileReader(pdffile))
-+
-+    # write and save output pdf
-+    out_name = out_dir + out_name + '.pdf'
-+    merger.write(out_name)
-+
-+    # remove tmp pdfs
-+    for pdfname in in_namelist:
-+        file_name = out_dir + pdfname
-+        os.system('rm -f '+file_name)
-+
-+    plt.cla()
-+    plt.clf()
-+
-+
-+
-+
-+# Execute main
-+if __name__ == '__main__':
-+    main()
-diff --git a/plot_misc/linrange_scan.py b/plot_misc/linrange_scan.py
-new file mode 100644
-index 0000000..282fe55
---- /dev/null
-+++ b/plot_misc/linrange_scan.py
-@@ -0,0 +1,275 @@
-+import sys
-+import os
-+
-+# Add path to directory where scan-files are stored
-+sys.path.insert(1, '/marconi/home/userexternal/nchriste/codes/scan_gs2/paramfiles')
-+
-+import f90nml as fnml
-+import numpy as np
-+import copy as cp
-+import pickle
-+import matplotlib.pyplot as plt
-+from matplotlib import rcParams
-+from math import pi
-+
-+plt.rc('text', usetex=True)
-+plt.rc('font', family='serif')
-+plt.rc('font', size=20)
-+rcParams.update({'figure.autolayout': True})
-+rcParams.update({'legend.fontsize': 12, 'legend.handlelength': 4})
-+rcParams.update({'legend.frameon': False})
-+
-+ONE = 'one'
-+TWO = 'two'
-+NDIM_MAX = TWO
-+
-+# Dict that will contain every parameter to scan
-+scan = {ONE:[],TWO:[]}
-+
-+
-+
-+
-+
-+
-+# vvv User parameters vvv
-+
-+# Import all parameters from paramfiles/myfile.py
-+base_name = 'rpsi_0.6'  
-+pf = __import__('scan_linrange_tprimi_ijp_950_rpsi_06')  
-+
-+# Number of dimensions in the scan
-+# e.g. vs R/LTi -> ndim = ONE
-+ndim = ONE
-+
-+# Define first dimension of the scan
-+firstdim_label = '$a/L_{T_i}$' # for plotting
-+firstdim_var = 'tprimi' # name of variable to append to figure names
-+firstdim = pf.tprimi # variable name in paramfiles/myfile.py
-+
-+# Apply limits to axis when plotting ?
-+use_my_xlim = False
-+my_xlim = (0.0, 2.0)  
-+
-+use_my_ylim = False
-+my_ylim_max = (0.0, 0.50)
-+my_ylim_avg = (-0.1, 0.15)
-+
-+# ^^^ User parameters ^^^
-+
-+
-+
-+
-+
-+
-+
-+def main():
-+
-+
-+    # Add all parameters to the current scan
-+
-+    nparams = len(pf.name)
-+    for iparam in range(nparams):
-+        add_param_to_scan(scan, pf.name[iparam], pf.dim[iparam], pf.namelist[iparam], pf.scandim[iparam], pf.func[iparam])
-+
-+
-+    # Read data from .dat files for every file in scan
-+
-+    tt0_collec = []
-+    ky_collec = []
-+    gamma_collec = []
-+    omega_collec = []
-+    qe_vs_qi_collec = []
-+    scandim=ONE
-+    valtree = [0*i for i in range(nparams)]
-+    read_data(base_name, valtree, scandim, tt0_collec, ky_collec, gamma_collec, omega_collec, qe_vs_qi_collec)
-+
-+
-+    # Save data for whole scan in file
-+
-+    vardict = {}
-+    vardict['tt0_collec'] = tt0_collec
-+    vardict['ky_collec'] = ky_collec
-+    vardict['gamma_collec'] = gamma_collec
-+    vardict['omega_collec'] = omega_collec
-+    vardict['qe_vs_qi_collec'] = qe_vs_qi_collec
-+    write_to_file(vardict)
-+
-+
-+
-+
-+
-+    # Plotting
-+
-+    naky = gamma_collec[0].shape[0]
-+    ntt0 = gamma_collec[0].shape[1]
-+    valdim = firstdim.size
-+
-+    # Check whether to plot vs ky, theta0, or both.
-+    # Squeeze out unsuseful dimensions.
-+    if ntt0 > 1 and naky > 1:
-+        plot1d = False
-+        plot2d = True
-+    else:
-+        if ntt0 > 1:
-+            xlabel = '$\\theta_0$'
-+            xvar = 'theta0'
-+            xvar_collec = tt0_collec
-+        else:
-+            xlabel = '$k_y\\rho_i$'
-+            xvar = 'ky'
-+            xvar_collec = ky_collec
-+        for ival in range(valdim):
-+            gamma_collec[ival] = np.squeeze(gamma_collec[ival])
-+            omega_collec[ival] = np.squeeze(omega_collec[ival])
-+        plot1d = True
-+        plot2d = False
-+
-+
-+    # Plots vs xvar
-+
-+    if plot1d:
-+
-+        color_collec = plt.cm.gnuplot_r(np.linspace(0.05,0.9,firstdim.size))
-+
-+
-+        # Plot gamma vs xvar
-+
-+        pdfname = 'postproc/linrange_gamma_scan_'+firstdim_var+'_vs_'+xvar+'.pdf'
-+        plt.figure()
-+        my_legend = []
-+        plt.grid(True)
-+        plt.xlabel(xlabel)
-+        plt.ylabel('$\\gamma\ [v_{th}/a]$')
-+        valdim = firstdim.size
-+        for ival in range(valdim):
-+            plt.plot(xvar_collec[ival], gamma_collec[ival], linewidth=2.0, color=color_collec[ival])
-+            my_legend.append(firstdim_label+'$ = '+str(firstdim[ival])+'$')
-+        if use_my_ylim:
-+            plt.ylim(my_ylim_avg)
-+        if use_my_xlim:
-+            plt.xlim(my_xlim)
-+        legend = plt.legend(my_legend, frameon = True, fancybox = False, fontsize=10)
-+        frame = legend.get_frame()
-+        frame.set_facecolor('white')
-+        frame.set_edgecolor('black')
-+        frame.set_linewidth(0.5)
-+        frame.set_alpha(1)
-+        plt.savefig(pdfname)
-+
-+        
-+        # Plot real frequency vs xvar
-+
-+        pdfname = 'postproc/linrange_omega_scan_'+firstdim_var+'_vs_'+xvar+'.pdf'
-+        plt.figure()
-+        my_legend = []
-+        plt.grid(True)
-+        plt.xlabel(xlabel)
-+        plt.ylabel('$\\omega\ [v_{th}/a]$')
-+        valdim = firstdim.size
-+        for ival in range(valdim):
-+            plt.plot(xvar_collec[ival], omega_collec[ival], linewidth=2.0, color=color_collec[ival])
-+            my_legend.append(firstdim_label+'$ = '+str(firstdim[ival])+'$')
-+        if use_my_ylim:
-+            plt.ylim(my_ylim_avg)
-+        if use_my_xlim:
-+            plt.xlim(my_xlim)
-+        legend = plt.legend(my_legend, frameon = True, fancybox = False)
-+        frame = legend.get_frame()
-+        frame.set_facecolor('white')
-+        frame.set_edgecolor('black')
-+        frame.set_linewidth(0.5)
-+        frame.set_alpha(1)
-+        plt.savefig(pdfname)
-+
-+
-+        # Plot Qe/Qi vs first scan dimension
-+
-+        pdfname = 'postproc/linrange_qe_vs_qi_scan_'+firstdim_var+'.pdf'
-+        plt.figure()
-+        my_legend = []
-+        plt.grid(True)
-+        plt.xlabel(firstdim_label)
-+        plt.ylabel('$\\langle Q_e/Q_i \\rangle_t$')
-+        plt.plot(firstdim , qe_vs_qi_collec, linewidth=2.0, color='k')
-+        plt.savefig(pdfname)
-+
-+
-+
-+
-+
-+class gs2_param:
-+    def __init__(self, var='', dim=np.array([]), in_list='', func=None):
-+        self.name = var
-+        self.dim = dim
-+        self.namelist = in_list
-+        self.func = func
-+
-+def add_param_to_scan(scan, name, dim, namelist, scandim, func):
-+    newparam = gs2_param(name, dim, namelist, func)
-+    if scandim == ONE:
-+        scan[ONE].append(newparam)
-+    elif scandim == TWO:
-+        scan[TWO].append(newparam)
-+    else:
-+        sys.exit('ERROR: this code only supports up to '+NDIM_MAX+' dimensions for a scan.')
-+
-+def increment_dim(scandim):
-+    if scandim == ONE:
-+        scandim = TWO
-+    else:
-+        scandim = END
-+    return scandim
-+
-+def read_data(fname, valtree, scandim, tt0_collec, ky_collec, gamma_collec, omega_collec, qe_vs_qi_collec):
-+
-+    # Iterate over every set of values taken by parameters in this dimension of the scan.
-+    for ival in range(scan[scandim][0].dim):
-+    
-+        # Name-base and patch to be modified for this ival.
-+        my_fname = fname
-+
-+        # For every parameter in this dimension of the scan, modify the files.
-+        for iparam in range(len(scan[scandim])):
-+            # Append parameter to namelist for in-file patching
-+            var = scan[scandim][iparam].name
-+            val = scan[scandim][iparam].func(ival,valtree)
-+            # Append parameter to the filenames
-+            my_fname = my_fname + '_' + var + '_' + str(val)
-+            # Update history tree
-+            if scandim == ONE:
-+                iparam_all = iparam
-+            if scandim == TWO:
-+                iparam_all = len(scan[ONE]) + iparam
-+            valtree[iparam_all] = val
-+        
-+        # If we are at the bottom of the tree, then read from the file.
-+        if scandim == ndim:
-+            [tt0,ky,gamma,omega,Qratio_avg] = read_from_file(my_fname)
-+            tt0_collec.append(tt0)
-+            ky_collec.append(ky)
-+            gamma_collec.append(gamma)
-+            omega_collec.append(omega)
-+            qe_vs_qi_collec.append(Qratio_avg)
-+        # Or move on to the next dimension of the scan by calling function recursively
-+        else:
-+            next_scandim = increment_dim(scandim)
-+            read_data(my_fname, valtree, next_scandim, tt0_collec, ky_collec, gamma_collec, omega_collec, qe_vs_qi_collec)
-+
-+def read_from_file(fname):
-+
-+    datfile_name = 'postproc/' + fname + '.linrange.dat' ### USER ###
-+
-+    with open(datfile_name, 'rb') as infile: # 'rb' stands for read bytes
-+        my_vars = pickle.load(infile)
-+
-+    return my_vars
-+
-+def write_to_file(vardict):
-+
-+    datfile_name = 'postproc/linscan.dat'
-+    with open(datfile_name, 'wb') as outfile: # 'wb' stands for write bytes
-+        pickle.dump(vardict,outfile)
-+
-+# Execute main
-+if __name__ == '__main__':
-+    main()
-diff --git a/plot_misc/plot_flowshear_lingrowth_scan.py b/plot_misc/plot_flowshear_lingrowth_scan.py
-new file mode 100644
-index 0000000..49092e7
---- /dev/null
-+++ b/plot_misc/plot_flowshear_lingrowth_scan.py
-@@ -0,0 +1,178 @@
-+import sys
-+import os
-+
-+# Add path to directory where scan-files are stored
-+taskdir = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'paramfiles')
-+sys.path.insert(0, taskdir)
-+
-+import f90nml as fnml
-+import numpy as np
-+import copy as cp
-+import fileinput as fin
-+from shutil import copyfile
-+import subprocess
-+import run_parameters as runpar
-+import importlib
-+
-+plt.rc('text', usetex=True)
-+plt.rc('font', family='serif')
-+plt.rc('font', size=20)
-+rcParams.update({'figure.autolayout': True})
-+rcParams.update({'legend.fontsize': 12, 'legend.handlelength': 4})
-+rcParams.update({'legend.frameon': False})
-+
-+ONE = 'one'
-+TWO = 'two'
-+NDIM_MAX = TWO
-+ndim = TWO
-+
-+# Dict that will contain every parameter to scan
-+scan = {ONE:[],TWO:[]}
-+
-+# From command-line arguments, get info about this analysis run (filenames, tasks to complete ...)
-+run = runpar.runobj()
-+
-+# Import all parameters from paramfiles/myfile.py
-+pf = __import__(run.paramfile)
-+
-+def main():
-+
-+    base_name = 'psin_0.85' ### USER ###
-+    firstdim_var = 'ky' ### USER ###
-+    firstdim = pf.ky ### USER ###
-+    seconddim_var = 'jtwist' ### USER ###
-+    seconddim = pf.jtwist ### USER ###
-+
-+    my_ylim = (-0.05, 0.3) ### USER ###
-+
-+    # Add all parameters to the current scan
-+    nparams = len(pf.name)
-+    for iparam in range(nparams):
-+        add_param_to_scan(scan, pf.name[iparam], pf.dim[iparam], pf.namelist[iparam], pf.scandim[iparam], pf.func[iparam])
-+
-+    # Read data from .dat files for every file in scan
-+    firstdim_collec = []
-+    gamma_avg_collec = []
-+    gamma_max_collec = []
-+    scandim=ONE
-+    ival_firstdim = -1
-+    valtree = [0*i for i in range(nparams)]
-+    read_data(base_name, valtree, scandim, ival_firstdim,ival_firstdim, firstdim_collec, gamma_avg_collec, gamma_max_collec)
-+
-+    # Save data for whole scan in file
-+    vardict = {}
-+    vardict['firstdim_collec'] = firstdim_collec
-+    vardict['gamma_avg_collec'] = gamma_avg_collec
-+    vardict['gamma_max_collec'] = gamma_max_collec
-+    write_to_file(vardict)
-+
-+    # Plotting
-+    color_collec = plt.cm.gnuplot_r(np.linspace(0,1,seconddim.size))
-+
-+    pdfname = 'postproc/flowshear_gamma_avg_scan_'+firstdim_var+'_'+seconddim_var+'.pdf'
-+    plt.figure()
-+    my_legend = []
-+    plt.grid(True)
-+    plt.xlabel('$\\rho k_y$') ### USER ###
-+    plt.ylabel('$\\langle\\gamma\\rangle_t [v_{th}/a]$')
-+    for ival in range(firstdim.size):
-+        plt.plot(firstdim_collec[ival], gamma_avg_collec[ival], linewidth=2.0, color=color_collec[ival])
-+        my_legend.append('$N_\\theta = {:d}$'.format(val_firstdim[ival])) ### USER ###
-+    plt.ylim(my_ylim)
-+    plt.legend(my_legend)
-+    plt.savefig(pdfname)
-+
-+    pdfname = 'postproc/flowshear_gamma_max_scan_'+firstdim_var+'_'+seconddim_var+'.pdf'
-+    plt.figure()
-+    my_legend = []
-+    plt.grid(True)
-+    plt.xlabel('$\\rho k_y$') ### USER ###
-+    plt.ylabel('$\\gamma_{max} [v_{th}/a]$')
-+    for ival in range(firstdim.size):
-+        plt.plot(firstdim_collec[ival], gamma_avg_collec[ival], linewidth=2.0, color=color_collec[ival])
-+        my_legend.append('$N_\\theta = {:d}$'.format(val_firstdim[ival])) ### USER ###
-+    plt.ylim(my_ylim)
-+    plt.legend(my_legend)
-+    plt.savefig(pdfname)
-+
-+class gs2_param:
-+    def __init__(self, var='', dim=np.array([]), in_list='', func=None):
-+        self.name = var
-+        self.dim = dim
-+        self.namelist = in_list
-+        self.func = func
-+
-+def add_param_to_scan(scan, name, dim, namelist, scandim, func):
-+    newparam = gs2_param(name, dim, namelist, func)
-+    if scandim == ONE:
-+        scan[ONE].append(newparam)
-+    elif scandim == TWO:
-+        scan[TWO].append(newparam)
-+    else:
-+        sys.exit('ERROR: this code only supports up to '+NDIM_MAX+' dimensions for a scan.')
-+
-+def increment_dim(scandim):
-+    if scandim == ONE:
-+        scandim = TWO
-+    else:
-+        scandim = END
-+    return scandim
-+
-+def read_data(fname, valtree, scandim, ival_firstdim, firstdim_collec, gamma_avg_collec, gamma_max_collec):
-+
-+    # Iterate over every set of values taken by parameters in this dimension of the scan.
-+    for ival in range(scan[scandim][0].dim):
-+    
-+        # Name-base and patch to be modified for this ival.
-+        my_fname = fname
-+
-+        # For every new value of firstdim, append elements
-+        if scandim==ONE and ival_firstdim!=ival:
-+            ival_firstdim = ival
-+            firstdim_collec.append([])
-+            gamma_avg_collec.append([])
-+            gamma_max_collec.append([])
-+
-+        # For every parameter in this dimension of the scan, modify the files.
-+        for iparam in range(len(scan[scandim])):
-+            # Append parameter to namelist for in-file patching
-+            var = scan[scandim][iparam].name
-+            val = scan[scandim][iparam].func(ival,valtree)
-+            # Append parameter to the filenames
-+            my_fname = my_fname + '_' + var + '_' + str(val)
-+            # Update history tree
-+            if scandim == ONE:
-+                iparam_all = iparam
-+            if scandim == TWO:
-+                iparam_all = len(scan[ONE]) + iparam
-+            valtree[iparam_all] = val
-+        
-+        # If we are at the bottom of the tree, then read from the file.
-+        if scandim == ndim:
-+            my_vars = read_from_file(my_fname)
-+            firstdim_collec[ival_firstdim].append(my_vars[firstdim_var][0])
-+            gamma_avg_collec[ival_firstdim].append(my_vars['gamma_avg'][0])
-+            gamma_max_collec[ival_firstdim].append(my_vars['gamma_max'][0])
-+        # Or move on to the next dimension of the scan by calling function recursively
-+        else:
-+            next_scandim = increment_dim(scandim)
-+            read_data(my_fname, valtree, next_scandim, ival_firstdim, firstdim_collec, gamma_avg_collec, gamma_max_collec)
-+
-+def read_from_file(fname):
-+
-+    datfile_name = 'postproc/' + fname + '.flowshear_lingrowth.dat' ### USER ###
-+
-+    with open(datfile_name, 'rb') as infile: # 'rb' stands for read bytes
-+        my_vars = pickle.load(infile)
-+
-+    return my_vars
-+
-+def write_to_file(vardict):
-+
-+    datfile_name = 'postproc/flowshear_lingrowth_scan2D.dat'
-+    with open(datfile_name, 'wb') as outfile: # 'wb' stands for write bytes
-+        pickle.dump(vardict,outfile)
-+
-+# Execute main
-+if __name__ == '__main__':
-+    main()
-diff --git a/plot_misc/plot_flowshear_lingrowth_scan1D.py b/plot_misc/plot_flowshear_lingrowth_scan1D.py
-new file mode 100644
-index 0000000..21d32b2
---- /dev/null
-+++ b/plot_misc/plot_flowshear_lingrowth_scan1D.py
-@@ -0,0 +1,125 @@
-+import sys
-+import os
-+
-+# Add path to directory where scan-files are stored
-+sys.path.insert(1, '/marconi/home/userexternal/nchriste/codes/scan_gs2/paramfiles')
-+
-+import f90nml as fnml
-+import numpy as np
-+import copy as cp
-+import pickle
-+import matplotlib.pyplot as plt
-+
-+ONE = 'one'
-+TWO = 'two'
-+NDIM_MAX = TWO
-+ndim = ONE
-+
-+# Dict that will contain every parameter to scan
-+scan = {ONE:[],TWO:[]}
-+
-+# Import all parameters from paramfiles/myfile.py
-+pf = __import__('ky_scan_psin_085_new') ### USER ###
-+
-+def main():
-+
-+    base_name = 'psin_0.85' ### USER ###
-+
-+    # Add all parameters to the current scan
-+    nparams = len(pf.name)
-+    for iparam in range(nparams):
-+        add_param_to_scan(pf.name[iparam], pf.val[iparam], pf.namelist[iparam], scan, pf.scandim[iparam])
-+
-+    # Read data from .dat files for every file in scan
-+    ky = []
-+    gamma_avg = []
-+    gamma_max = []
-+    scandim=ONE
-+    read_data(base_name, scandim, ky, gamma_avg, gamma_max)
-+
-+    # Save data for whole scan in file
-+    vardict = {}
-+    vardict['ky'] = ky
-+    vardict['gamma_avg'] = gamma_avg
-+    vardict['gamma_max'] = gamma_max
-+    write_to_file(vardict)
-+
-+    pdfname = 'postproc/flowshear_lingrowth.pdf'
-+    plt.figure()
-+    my_legend = []
-+    plt.grid(True)
-+    plt.xlabel('$\\rho k_y$')
-+    plt.ylabel('$[v_{th}/a]$')
-+    plt.plot(ky, gamma_avg, linewidth=3.0, color='k', linestyle=':')
-+    my_legend.append('$\\langle\\gamma\\rangle_t$')
-+    plt.plot(ky, gamma_max, linewidth=3.0, color='k', linestyle='--')
-+    my_legend.append('$\\gamma_{max}$')
-+    plt.legend(my_legend)
-+    plt.savefig(pdfname)
-+
-+class gs2_param:
-+    def __init__(self, var='', val=np.array([]), in_list=''):
-+        self.name = var
-+        self.value = val
-+        self.namelist = in_list
-+
-+def add_param_to_scan(name, values, namelist, scan, scandim):
-+    newparam = gs2_param(name, values, namelist)
-+    if scandim == ONE:
-+        scan[ONE].append(newparam)
-+    elif scandim == TWO:
-+        scan[TWO].append(newparam)
-+    else:
-+        sys.exit('ERROR: this code only supports up to '+NDIM_MAX+' dimensions for a scan.')
-+
-+def increment_dim(scandim):
-+    if scandim == ONE:
-+        scandim = TWO
-+    else:
-+        scandim = END
-+    return scandim
-+
-+def read_data(fname, scandim, ky, gamma_avg, gamma_max):
-+
-+    # Iterate over every set of values taken by parameters in this dimension of the scan.
-+    for ival in range(scan[scandim][0].value.size):
-+    
-+        # Name-base and patch to be modified for this ival.
-+        my_fname = fname
-+
-+        for iparam in range(len(scan[scandim])):
-+            var = scan[scandim][iparam].name
-+            val = scan[scandim][iparam].value[ival]
-+            # Append parameter to the filenames
-+            my_fname = my_fname + '_' + var + '_' + str(val)
-+        
-+        # If we are at the last dimension of the scan, then read from the file.
-+        if scandim == ndim:
-+            my_vars = read_from_file(my_fname)
-+            ky.append(my_vars['ky'][0])
-+            gamma_avg.append(my_vars['gamma_avg'][0])
-+            gamma_max.append(my_vars['gamma_max'][0])
-+
-+        # Or move on to the next dimension of the scan by calling function recursively
-+        else:
-+            next_scandim = increment_dim(scandim)
-+            modify_files(my_fname, next_scandim)
-+
-+def read_from_file(fname):
-+
-+    datfile_name = 'postproc/' + fname + '.flowshear_lingrowth.dat' ### USER ###
-+
-+    with open(datfile_name, 'rb') as infile: # 'rb' stands for read bytes
-+        my_vars = pickle.load(infile)
-+
-+    return my_vars
-+
-+def write_to_file(vardict):
-+
-+    datfile_name = 'postproc/flowshear_lingrowth_kyscan.dat'
-+    with open(datfile_name, 'wb') as outfile: # 'wb' stands for write bytes
-+        pickle.dump(vardict,outfile)
-+
-+# Execute main
-+if __name__ == '__main__':
-+    main()
-diff --git a/plot_misc/plot_flowshear_lingrowth_scan1D_new.py b/plot_misc/plot_flowshear_lingrowth_scan1D_new.py
-new file mode 100644
-index 0000000..77c0791
---- /dev/null
-+++ b/plot_misc/plot_flowshear_lingrowth_scan1D_new.py
-@@ -0,0 +1,200 @@
-+import sys
-+import os
-+
-+# Add path to directory where scan-files are stored
-+taskdir = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'paramfiles')
-+sys.path.insert(0, taskdir)
-+
-+import f90nml as fnml
-+import numpy as np
-+import copy as cp
-+import fileinput as fin
-+from shutil import copyfile
-+import subprocess
-+import run_parameters as runpar
-+import importlib
-+
-+plt.rc('text', usetex=True)
-+plt.rc('font', family='serif')
-+plt.rc('font', size=20)
-+rcParams.update({'figure.autolayout': True})
-+rcParams.update({'legend.fontsize': 12, 'legend.handlelength': 4})
-+rcParams.update({'legend.frameon': False})
-+
-+ONE = 'one'
-+TWO = 'two'
-+NDIM_MAX = TWO
-+ndim = ONE ### USER ###
-+
-+# Dict that will contain every parameter to scan
-+scan = {ONE:[],TWO:[]}
-+
-+# From command-line arguments, get info about this analysis run (filenames, tasks to complete ...)
-+run = runpar.runobj()
-+
-+# Import all parameters from paramfiles/myfile.py
-+pf = __import__(run.paramfile)
-+
-+def main():
-+
-+    base_name = 'psin_0.85' ### USER ###
-+    firstdim_var = 'ky' ### USER ###
-+    firstdim = pf.ky ### USER ###
-+    seconddim_var = 'jtwist' ### USER ###
-+    seconddim = pf.jtwist ### USER ###
-+
-+    my_ylim = (-0.05, 0.3) ### USER ###
-+
-+    # Add all parameters to the current scan
-+    nparams = len(pf.name)
-+    for iparam in range(nparams):
-+        add_param_to_scan(scan, pf.name[iparam], pf.dim[iparam], pf.namelist[iparam], pf.scandim[iparam], pf.func[iparam])
-+
-+    # Read data from .dat files for every file in scan
-+    firstdim_collec = []
-+    gamma_avg_collec = []
-+    gamma_max_collec = []
-+    scandim=ONE
-+    ival_firstdim = -1
-+    valtree = [0*i for i in range(nparams)]
-+    read_data(base_name, valtree, scandim, ival_firstdim,ival_firstdim, firstdim_collec, gamma_avg_collec, gamma_max_collec)
-+
-+    # Save data for whole scan in file
-+    vardict = {}
-+    vardict['firstdim_collec'] = firstdim_collec
-+    vardict['gamma_avg_collec'] = gamma_avg_collec
-+    vardict['gamma_max_collec'] = gamma_max_collec
-+    write_to_file(vardict)
-+
-+    # Plotting
-+    if ndim == ONE:
-+
-+        pdfname = 'postproc/flowshear_gamma_avg_scan_'+firstdim_var+'.pdf'
-+        plt.figure()
-+        my_legend = []
-+        plt.grid(True)
-+        plt.xlabel('$\\rho k_y$') ### USER ###
-+        plt.ylabel('$\\langle\\gamma\\rangle_t [v_{th}/a]$')
-+        plt.plot(firstdim_collec[0], gamma_avg_collec[0], linewidth=3.0, color='k', linestyle=':')
-+        plt.savefig(pdfname)
-+
-+        pdfname = 'postproc/flowshear_gamma_max_scan_'+firstdim_var+'.pdf'
-+        plt.figure()
-+        my_legend = []
-+        plt.grid(True)
-+        plt.xlabel('$\\rho k_y$') ### USER ###
-+        plt.ylabel('$\\gamma_{max} [v_{th}/a]$')
-+        plt.plot(firstdim_collec[0], gamma_max_collec[0], linewidth=3.0, color='k', linestyle=':')
-+        plt.savefig(pdfname)
-+
-+    elif ndim == TWO:
-+
-+        color_collec = plt.cm.gnuplot_r(np.linspace(0,1,seconddim.size))
-+
-+        pdfname = 'postproc/flowshear_gamma_avg_scan_'+firstdim_var+'_'+seconddim_var+'.pdf'
-+        plt.figure()
-+        my_legend = []
-+        plt.grid(True)
-+        plt.xlabel('$\\rho k_y$') ### USER ###
-+        plt.ylabel('$\\langle\\gamma\\rangle_t [v_{th}/a]$')
-+        for ival in range(seconddim.size):
-+            plt.plot(firstdim_collec[ival], gamma_avg_collec[ival], linewidth=2.0, color=color_collec[ival])
-+            my_legend.append('$N_\\theta = {:d}$'.format(val_firstdim[ival])) ### USER ###
-+        plt.ylim(my_ylim)
-+        plt.legend(my_legend)
-+        plt.savefig(pdfname)
-+
-+        pdfname = 'postproc/flowshear_gamma_max_scan_'+firstdim_var+'_'+seconddim_var+'.pdf'
-+        plt.figure()
-+        my_legend = []
-+        plt.grid(True)
-+        plt.xlabel('$\\rho k_y$') ### USER ###
-+        plt.ylabel('$\\gamma_{max} [v_{th}/a]$')
-+        for ival in range(seconddim.size):
-+            plt.plot(firstdim_collec[ival], gamma_avg_collec[ival], linewidth=2.0, color=color_collec[ival])
-+            my_legend.append('$N_\\theta = {:d}$'.format(val_firstdim[ival])) ### USER ###
-+        plt.ylim(my_ylim)
-+        plt.legend(my_legend)
-+        plt.savefig(pdfname)
-+
-+class gs2_param:
-+    def __init__(self, var='', dim=np.array([]), in_list='', func=None):
-+        self.name = var
-+        self.dim = dim
-+        self.namelist = in_list
-+        self.func = func
-+
-+def add_param_to_scan(scan, name, dim, namelist, scandim, func):
-+    newparam = gs2_param(name, dim, namelist, func)
-+    if scandim == ONE:
-+        scan[ONE].append(newparam)
-+    elif scandim == TWO:
-+        scan[TWO].append(newparam)
-+    else:
-+        sys.exit('ERROR: this code only supports up to '+NDIM_MAX+' dimensions for a scan.')
-+
-+def increment_dim(scandim):
-+    if scandim == ONE:
-+        scandim = TWO
-+    else:
-+        scandim = END
-+    return scandim
-+
-+def read_data(fname, valtree, scandim, ival_firstdim, firstdim_collec, gamma_avg_collec, gamma_max_collec):
-+
-+    # Iterate over every set of values taken by parameters in this dimension of the scan.
-+    for ival in range(scan[scandim][0].dim):
-+    
-+        # Name-base and patch to be modified for this ival.
-+        my_fname = fname
-+
-+        # For every new value of firstdim, append elements
-+        if scandim==ONE and ival_firstdim!=ival:
-+            ival_firstdim = ival
-+            firstdim_collec.append([])
-+            gamma_avg_collec.append([])
-+            gamma_max_collec.append([])
-+
-+        # For every parameter in this dimension of the scan, modify the files.
-+        for iparam in range(len(scan[scandim])):
-+            # Append parameter to namelist for in-file patching
-+            var = scan[scandim][iparam].name
-+            val = scan[scandim][iparam].func(ival,valtree)
-+            # Append parameter to the filenames
-+            my_fname = my_fname + '_' + var + '_' + str(val)
-+            # Update history tree
-+            if scandim == ONE:
-+                iparam_all = iparam
-+            if scandim == TWO:
-+                iparam_all = len(scan[ONE]) + iparam
-+            valtree[iparam_all] = val
-+        
-+        # If we are at the bottom of the tree, then read from the file.
-+        if scandim == ndim:
-+            my_vars = read_from_file(my_fname)
-+            firstdim_collec[ival_firstdim].append(my_vars[firstdim_var][0])
-+            gamma_avg_collec[ival_firstdim].append(my_vars['gamma_avg'][0])
-+            gamma_max_collec[ival_firstdim].append(my_vars['gamma_max'][0])
-+        # Or move on to the next dimension of the scan by calling function recursively
-+        else:
-+            next_scandim = increment_dim(scandim)
-+            read_data(my_fname, valtree, next_scandim, ival_firstdim, firstdim_collec, gamma_avg_collec, gamma_max_collec)
-+
-+def read_from_file(fname):
-+
-+    datfile_name = 'postproc/' + fname + '.flowshear_lingrowth.dat' ### USER ###
-+
-+    with open(datfile_name, 'rb') as infile: # 'rb' stands for read bytes
-+        my_vars = pickle.load(infile)
-+
-+    return my_vars
-+
-+def write_to_file(vardict):
-+
-+    datfile_name = 'postproc/flowshear_lingrowth_scan2D.dat'
-+    with open(datfile_name, 'wb') as outfile: # 'wb' stands for write bytes
-+        pickle.dump(vardict,outfile)
-+
-+# Execute main
-+if __name__ == '__main__':
-+    main()
-diff --git a/plot_misc/plot_flowshear_lingrowth_scan2D.py b/plot_misc/plot_flowshear_lingrowth_scan2D.py
-new file mode 100644
-index 0000000..d95c1a8
---- /dev/null
-+++ b/plot_misc/plot_flowshear_lingrowth_scan2D.py
-@@ -0,0 +1,164 @@
-+import sys
-+import os
-+
-+# Add path to directory where scan-files are stored
-+sys.path.insert(1, '/marconi/home/userexternal/nchriste/codes/scan_gs2/paramfiles')
-+
-+import f90nml as fnml
-+import numpy as np
-+import copy as cp
-+import pickle
-+import matplotlib.pyplot as plt
-+from matplotlib import rcParams
-+
-+plt.rc('text', usetex=True)
-+plt.rc('font', family='serif')
-+plt.rc('font', size=20)
-+rcParams.update({'figure.autolayout': True})
-+rcParams.update({'legend.fontsize': 12, 'legend.handlelength': 4})
-+rcParams.update({'legend.frameon': False})
-+
-+ONE = 'one'
-+TWO = 'two'
-+NDIM_MAX = TWO
-+ndim = TWO
-+
-+# Dict that will contain every parameter to scan
-+scan = {ONE:[],TWO:[]}
-+
-+# Import all parameters from paramfiles/myfile.py
-+pf = __import__('ntheta_ky_scan_085_new') ### USER ###
-+
-+def main():
-+
-+    base_name = 'psin_0.85' ### USER ###
-+    my_ylim = (-0.05, 0.3) ### USER ###
-+
-+    # Add all parameters to the current scan
-+    nparams = len(pf.name)
-+    for iparam in range(nparams):
-+        add_param_to_scan(pf.name[iparam], pf.val[iparam], pf.namelist[iparam], scan, pf.scandim[iparam])
-+
-+    # Read data from .dat files for every file in scan
-+    var_firstdim = scan[ONE][0].name
-+    val_firstdim = scan[ONE][0].value
-+    ky_collec = []
-+    gamma_avg_collec = []
-+    gamma_max_collec = []
-+    scandim=ONE
-+    ival_firstdim = -1
-+    read_data(base_name, scandim, ival_firstdim, ky_collec, gamma_avg_collec, gamma_max_collec)
-+
-+    # Save data for whole scan in file
-+    vardict = {}
-+    vardict['var_firstdim'] = var_firstdim
-+    vardict['val_firstdim'] = val_firstdim
-+    vardict['ky_collec'] = ky_collec
-+    vardict['gamma_avg_collec'] = gamma_avg_collec
-+    vardict['gamma_max_collec'] = gamma_max_collec
-+    write_to_file(vardict)
-+
-+    # Plotting
-+    color_collec = plt.cm.gnuplot_r(np.linspace(0,1,val_firstdim.size)) # for newalgo
-+
-+    pdfname = 'postproc/flowshear_scan2D_gamma_avg.pdf'
-+    plt.figure()
-+    my_legend = []
-+    plt.grid(True)
-+    plt.xlabel('$\\rho k_y$')
-+    plt.ylabel('$\\langle\\gamma\\rangle_t [v_{th}/a]$')
-+    for ival in range(val_firstdim.size):
-+        plt.plot(ky_collec[ival], gamma_avg_collec[ival], linewidth=2.0, color=color_collec[ival])
-+        my_legend.append('$N_\\theta = {:d}$'.format(val_firstdim[ival]))
-+    plt.ylim(my_ylim)
-+    plt.legend(my_legend)
-+    plt.savefig(pdfname)
-+
-+    pdfname = 'postproc/flowshear_scan2D_gamma_max.pdf'
-+    plt.figure()
-+    my_legend = []
-+    plt.grid(True)
-+    plt.xlabel('$\\rho k_y$')
-+    plt.ylabel('$\\gamma_{max} [v_{th}/a]$')
-+    for ival in range(val_firstdim.size):
-+        plt.plot(ky_collec[ival], gamma_max_collec[ival], linewidth=2.0, color=color_collec[ival])
-+        my_legend.append('$N_\\theta = {:d}$'.format(val_firstdim[ival]))
-+    plt.ylim(my_ylim)
-+    plt.legend(my_legend)
-+    plt.savefig(pdfname)
-+
-+class gs2_param:
-+    def __init__(self, var='', val=np.array([]), in_list=''):
-+        self.name = var
-+        self.value = val
-+        self.namelist = in_list
-+
-+def add_param_to_scan(name, values, namelist, scan, scandim):
-+    newparam = gs2_param(name, values, namelist)
-+    if scandim == ONE:
-+        scan[ONE].append(newparam)
-+    elif scandim == TWO:
-+        scan[TWO].append(newparam)
-+    else:
-+        sys.exit('ERROR: this code only supports up to '+NDIM_MAX+' dimensions for a scan.')
-+
-+def increment_dim(scandim):
-+    if scandim == ONE:
-+        scandim = TWO
-+    else:
-+        scandim = END
-+    return scandim
-+
-+def read_data(fname, scandim, ival_firstdim, ky_collec, gamma_avg_collec, gamma_max_collec):
-+
-+    # Iterate over every set of values taken by parameters in this dimension of the scan.
-+    for ival in range(scan[scandim][0].value.size):
-+    
-+        # Name-base and variable container for this ival
-+        my_fname = fname
-+        #ky_collec = cp.deepcopy(ky_collec)
-+        #gamma_avg_collec = cp.deepcopy(gamma_avg_collec)
-+        #gamma_max_collec = cp.deepcopy(gamma_max_collec)
-+
-+        if scandim==ONE and ival_firstdim!=ival:
-+            ival_firstdim = ival
-+            ky_collec.append([])
-+            gamma_avg_collec.append([])
-+            gamma_max_collec.append([])
-+
-+        for iparam in range(len(scan[scandim])):
-+            var = scan[scandim][iparam].name
-+            val = scan[scandim][iparam].value[ival]
-+            # Append parameter to the filenames
-+            my_fname = my_fname + '_' + var + '_' + str(val)
-+        
-+        # If we are at the last dimension of the scan, then read from the file.
-+        if scandim == ndim:
-+            my_vars = read_from_file(my_fname)
-+            ky_collec[ival_firstdim].append(my_vars['ky'][0])
-+            gamma_avg_collec[ival_firstdim].append(my_vars['gamma_avg'][0])
-+            gamma_max_collec[ival_firstdim].append(my_vars['gamma_max'][0])
-+
-+        # Or move on to the next dimension of the scan by calling function recursively
-+        else:
-+            next_scandim = increment_dim(scandim)
-+            read_data(my_fname, next_scandim, ival_firstdim, ky_collec, gamma_avg_collec, gamma_max_collec)
-+
-+def read_from_file(fname):
-+
-+    datfile_name = 'postproc/' + fname + '.flowshear_lingrowth.dat' ### USER ###
-+
-+    with open(datfile_name, 'rb') as infile: # 'rb' stands for read bytes
-+        my_vars = pickle.load(infile)
-+
-+    return my_vars
-+
-+def write_to_file(vardict):
-+
-+    datfile_name = 'postproc/flowshear_lingrowth_scan2D.dat'
-+    with open(datfile_name, 'wb') as outfile: # 'wb' stands for write bytes
-+        pickle.dump(vardict,outfile)
-+
-+# Execute main
-+if __name__ == '__main__':
-+    main()
-diff --git a/plot_misc/plot_flowshear_lingrowth_scan2D_new.py b/plot_misc/plot_flowshear_lingrowth_scan2D_new.py
-new file mode 100644
-index 0000000..49092e7
---- /dev/null
-+++ b/plot_misc/plot_flowshear_lingrowth_scan2D_new.py
-@@ -0,0 +1,178 @@
-+import sys
-+import os
-+
-+# Add path to directory where scan-files are stored
-+taskdir = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'paramfiles')
-+sys.path.insert(0, taskdir)
-+
-+import f90nml as fnml
-+import numpy as np
-+import copy as cp
-+import fileinput as fin
-+from shutil import copyfile
-+import subprocess
-+import run_parameters as runpar
-+import importlib
-+
-+plt.rc('text', usetex=True)
-+plt.rc('font', family='serif')
-+plt.rc('font', size=20)
-+rcParams.update({'figure.autolayout': True})
-+rcParams.update({'legend.fontsize': 12, 'legend.handlelength': 4})
-+rcParams.update({'legend.frameon': False})
-+
-+ONE = 'one'
-+TWO = 'two'
-+NDIM_MAX = TWO
-+ndim = TWO
-+
-+# Dict that will contain every parameter to scan
-+scan = {ONE:[],TWO:[]}
-+
-+# From command-line arguments, get info about this analysis run (filenames, tasks to complete ...)
-+run = runpar.runobj()
-+
-+# Import all parameters from paramfiles/myfile.py
-+pf = __import__(run.paramfile)
-+
-+def main():
-+
-+    base_name = 'psin_0.85' ### USER ###
-+    firstdim_var = 'ky' ### USER ###
-+    firstdim = pf.ky ### USER ###
-+    seconddim_var = 'jtwist' ### USER ###
-+    seconddim = pf.jtwist ### USER ###
-+
-+    my_ylim = (-0.05, 0.3) ### USER ###
-+
-+    # Add all parameters to the current scan
-+    nparams = len(pf.name)
-+    for iparam in range(nparams):
-+        add_param_to_scan(scan, pf.name[iparam], pf.dim[iparam], pf.namelist[iparam], pf.scandim[iparam], pf.func[iparam])
-+
-+    # Read data from .dat files for every file in scan
-+    firstdim_collec = []
-+    gamma_avg_collec = []
-+    gamma_max_collec = []
-+    scandim=ONE
-+    ival_firstdim = -1
-+    valtree = [0*i for i in range(nparams)]
-+    read_data(base_name, valtree, scandim, ival_firstdim,ival_firstdim, firstdim_collec, gamma_avg_collec, gamma_max_collec)
-+
-+    # Save data for whole scan in file
-+    vardict = {}
-+    vardict['firstdim_collec'] = firstdim_collec
-+    vardict['gamma_avg_collec'] = gamma_avg_collec
-+    vardict['gamma_max_collec'] = gamma_max_collec
-+    write_to_file(vardict)
-+
-+    # Plotting
-+    color_collec = plt.cm.gnuplot_r(np.linspace(0,1,seconddim.size))
-+
-+    pdfname = 'postproc/flowshear_gamma_avg_scan_'+firstdim_var+'_'+seconddim_var+'.pdf'
-+    plt.figure()
-+    my_legend = []
-+    plt.grid(True)
-+    plt.xlabel('$\\rho k_y$') ### USER ###
-+    plt.ylabel('$\\langle\\gamma\\rangle_t [v_{th}/a]$')
-+    for ival in range(firstdim.size):
-+        plt.plot(firstdim_collec[ival], gamma_avg_collec[ival], linewidth=2.0, color=color_collec[ival])
-+        my_legend.append('$N_\\theta = {:d}$'.format(val_firstdim[ival])) ### USER ###
-+    plt.ylim(my_ylim)
-+    plt.legend(my_legend)
-+    plt.savefig(pdfname)
-+
-+    pdfname = 'postproc/flowshear_gamma_max_scan_'+firstdim_var+'_'+seconddim_var+'.pdf'
-+    plt.figure()
-+    my_legend = []
-+    plt.grid(True)
-+    plt.xlabel('$\\rho k_y$') ### USER ###
-+    plt.ylabel('$\\gamma_{max} [v_{th}/a]$')
-+    for ival in range(firstdim.size):
-+        plt.plot(firstdim_collec[ival], gamma_avg_collec[ival], linewidth=2.0, color=color_collec[ival])
-+        my_legend.append('$N_\\theta = {:d}$'.format(val_firstdim[ival])) ### USER ###
-+    plt.ylim(my_ylim)
-+    plt.legend(my_legend)
-+    plt.savefig(pdfname)
-+
-+class gs2_param:
-+    def __init__(self, var='', dim=np.array([]), in_list='', func=None):
-+        self.name = var
-+        self.dim = dim
-+        self.namelist = in_list
-+        self.func = func
-+
-+def add_param_to_scan(scan, name, dim, namelist, scandim, func):
-+    newparam = gs2_param(name, dim, namelist, func)
-+    if scandim == ONE:
-+        scan[ONE].append(newparam)
-+    elif scandim == TWO:
-+        scan[TWO].append(newparam)
-+    else:
-+        sys.exit('ERROR: this code only supports up to '+NDIM_MAX+' dimensions for a scan.')
-+
-+def increment_dim(scandim):
-+    if scandim == ONE:
-+        scandim = TWO
-+    else:
-+        scandim = END
-+    return scandim
-+
-+def read_data(fname, valtree, scandim, ival_firstdim, firstdim_collec, gamma_avg_collec, gamma_max_collec):
-+
-+    # Iterate over every set of values taken by parameters in this dimension of the scan.
-+    for ival in range(scan[scandim][0].dim):
-+    
-+        # Name-base and patch to be modified for this ival.
-+        my_fname = fname
-+
-+        # For every new value of firstdim, append elements
-+        if scandim==ONE and ival_firstdim!=ival:
-+            ival_firstdim = ival
-+            firstdim_collec.append([])
-+            gamma_avg_collec.append([])
-+            gamma_max_collec.append([])
-+
-+        # For every parameter in this dimension of the scan, modify the files.
-+        for iparam in range(len(scan[scandim])):
-+            # Append parameter to namelist for in-file patching
-+            var = scan[scandim][iparam].name
-+            val = scan[scandim][iparam].func(ival,valtree)
-+            # Append parameter to the filenames
-+            my_fname = my_fname + '_' + var + '_' + str(val)
-+            # Update history tree
-+            if scandim == ONE:
-+                iparam_all = iparam
-+            if scandim == TWO:
-+                iparam_all = len(scan[ONE]) + iparam
-+            valtree[iparam_all] = val
-+        
-+        # If we are at the bottom of the tree, then read from the file.
-+        if scandim == ndim:
-+            my_vars = read_from_file(my_fname)
-+            firstdim_collec[ival_firstdim].append(my_vars[firstdim_var][0])
-+            gamma_avg_collec[ival_firstdim].append(my_vars['gamma_avg'][0])
-+            gamma_max_collec[ival_firstdim].append(my_vars['gamma_max'][0])
-+        # Or move on to the next dimension of the scan by calling function recursively
-+        else:
-+            next_scandim = increment_dim(scandim)
-+            read_data(my_fname, valtree, next_scandim, ival_firstdim, firstdim_collec, gamma_avg_collec, gamma_max_collec)
-+
-+def read_from_file(fname):
-+
-+    datfile_name = 'postproc/' + fname + '.flowshear_lingrowth.dat' ### USER ###
-+
-+    with open(datfile_name, 'rb') as infile: # 'rb' stands for read bytes
-+        my_vars = pickle.load(infile)
-+
-+    return my_vars
-+
-+def write_to_file(vardict):
-+
-+    datfile_name = 'postproc/flowshear_lingrowth_scan2D.dat'
-+    with open(datfile_name, 'wb') as outfile: # 'wb' stands for write bytes
-+        pickle.dump(vardict,outfile)
-+
-+# Execute main
-+if __name__ == '__main__':
-+    main()
-diff --git a/plot_misc/plot_flowshear_lingrowth_scan_new.py b/plot_misc/plot_flowshear_lingrowth_scan_new.py
-new file mode 100644
-index 0000000..78f50f8
---- /dev/null
-+++ b/plot_misc/plot_flowshear_lingrowth_scan_new.py
-@@ -0,0 +1,276 @@
-+import sys
-+import os
-+
-+# Add path to directory where scan-files are stored
-+sys.path.insert(1, '/marconi/home/userexternal/nchriste/codes/scan_gs2/paramfiles')
-+
-+import f90nml as fnml
-+import numpy as np
-+import copy as cp
-+import pickle
-+import matplotlib.pyplot as plt
-+from matplotlib import rcParams
-+
-+plt.rc('text', usetex=True)
-+plt.rc('font', family='serif')
-+plt.rc('font', size=20)
-+rcParams.update({'figure.autolayout': True})
-+rcParams.update({'legend.fontsize': 12, 'legend.handlelength': 4})
-+rcParams.update({'legend.frameon': False})
-+
-+ONE = 'one'
-+TWO = 'two'
-+NDIM_MAX = TWO
-+ndim = ONE ### USER ###
-+
-+# Dict that will contain every parameter to scan
-+scan = {ONE:[],TWO:[]}
-+
-+# Import all parameters from paramfiles/myfile.py
-+pf = __import__('scan_ky_fixed_dkx_kxmax_ijp_950_rpsi_051_final_res') ### USER ###
-+
-+base_name = 'rpsi_0.51' ### USER ###
-+firstdim_var = 'ky' ### USER ###
-+firstdim = pf.ky ### USER ###
-+seconddim_var = 'negrid' ### USER ###
-+#seconddim = (2*np.round((pf.nx-1)/3)+1).astype(int) ### USER ###
-+seconddim = pf.ky ### USER ###
-+plot_converged = False ### USER ###
-+firstdim_converged = np.array([0.2, 0.5, 1.0]) ### USER ###
-+gamma_max_converged = np.array([0.05, 0.109, 0.008]) # 950, rpsi=0.51, kx_max_scan
-+gamma_avg_converged = np.array([-0.002, -0.003, -0.001]) # 950, rpsi=0.51, kx_max_scan
-+
-+# Original code was written for ky=seconddim (invert_dims=True)
-+invert_dims = False ### USER ###
-+
-+use_my_ylim = False ### USER ###
-+my_ylim_max = (0.0, 0.25) ### USER ###
-+my_ylim_avg = (-0.015, 0.025) ### USER ###
-+
-+use_my_xlim = True ### USER ###
-+my_xlim = (0.0, 1.1) ### USER ###
-+
-+scan_with_single_ky = False ### USER ###
-+
-+
-+def main():
-+
-+    # Add all parameters to the current scan
-+    nparams = len(pf.name)
-+    for iparam in range(nparams):
-+        add_param_to_scan(scan, pf.name[iparam], pf.dim[iparam], pf.namelist[iparam], pf.scandim[iparam], pf.func[iparam])
-+
-+    # Read data from .dat files for every file in scan
-+    firstdim_collec = []
-+    gamma_avg_collec = []
-+    gamma_max_collec = []
-+    scandim=ONE
-+    ival_firstdim = -1
-+    valtree = [0*i for i in range(nparams)]
-+    read_data(base_name, valtree, scandim, ival_firstdim, firstdim_collec, gamma_avg_collec, gamma_max_collec)
-+
-+    # Re-organise data if ky=firstdim
-+    if not invert_dims and ndim == TWO:
-+
-+        firstdim_collec_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-+        gamma_avg_collec_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-+        gamma_max_collec_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-+        for ival_first in range(firstdim.size):
-+            for ival_scnd in range(seconddim.size):
-+                firstdim_collec_new[ival_scnd][ival_first] = firstdim_collec[ival_first][ival_scnd]
-+                gamma_avg_collec_new[ival_scnd][ival_first] = gamma_avg_collec[ival_first][ival_scnd]
-+                gamma_max_collec_new[ival_scnd][ival_first] = gamma_max_collec[ival_first][ival_scnd]
-+        firstdim_collec = firstdim_collec_new
-+        gamma_avg_collec = gamma_avg_collec_new
-+        gamma_max_collec = gamma_max_collec_new
-+
-+    # Save data for whole scan in file
-+    vardict = {}
-+    vardict['firstdim_collec'] = firstdim_collec
-+    vardict['gamma_avg_collec'] = gamma_avg_collec
-+    vardict['gamma_max_collec'] = gamma_max_collec
-+    write_to_file(vardict)
-+
-+    # Plotting
-+    if ndim == ONE:
-+
-+        pdfname = 'postproc/flowshear_gamma_avg_scan_'+firstdim_var+'.pdf'
-+        plt.figure()
-+        my_legend = []
-+        plt.grid(True)
-+        plt.xlabel('$\\rho k_y$') ### USER ###
-+        plt.ylabel('$\\langle\\gamma\\rangle_t [v_{th}/a]$')
-+        plt.plot(firstdim_collec, gamma_avg_collec, linewidth=2.0, color='k')
-+        if use_my_ylim:
-+            plt.ylim(my_ylim_avg)
-+        plt.savefig(pdfname)
-+
-+        pdfname = 'postproc/flowshear_gamma_max_scan_'+firstdim_var+'.pdf'
-+        plt.figure()
-+        my_legend = []
-+        plt.grid(True)
-+        plt.xlabel('$\\rho k_y$') ### USER ###
-+        plt.ylabel('$\\gamma_{max} [v_{th}/a]$')
-+        plt.plot(firstdim_collec, gamma_max_collec, linewidth=2.0, color='k')
-+        if use_my_ylim:
-+            plt.ylim(my_ylim_max)
-+        plt.savefig(pdfname)
-+
-+    elif ndim == TWO:
-+
-+        color_collec = plt.cm.gnuplot_r(np.linspace(0.05,0.9,seconddim.size))
-+        if scan_with_single_ky:
-+            color_collec = ['blue']
-+
-+        pdfname = 'postproc/flowshear_gamma_avg_scan_'+firstdim_var+'_'+seconddim_var+'.pdf'
-+        plt.figure()
-+        my_legend = []
-+        plt.grid(True)
-+        plt.xlabel('$\\rho k_y$') ### USER ###
-+        #plt.xlabel('jtwist') ### USER ###
-+        plt.ylabel('$\\langle\\gamma\\rangle_t\ [v_{th}/a]$')
-+        valdim = seconddim.size
-+        if scan_with_single_ky:
-+            valdim = firstdim.size
-+        for ival in range(valdim):
-+            if scan_with_single_ky:
-+                plt.plot(seconddim, gamma_avg_collec, linewidth=2.0, color=color_collec[ival])
-+            else:
-+                plt.plot(firstdim_collec[ival], gamma_avg_collec[ival], linewidth=2.0, color=color_collec[ival])
-+            #my_legend.append('$N_x = {0:d}$'.format(seconddim[ival])) ### USER ###
-+            #my_legend.append('$\\Delta k_x = {0:1.3f}$'.format(seconddim[ival])) ### USER ###
-+            #my_legend.append('$\\rho k_y = {0:1.3f}$'.format(seconddim[ival])) ### USER ###
-+            #my_legend.append('$N_\\theta = {0:d}$'.format(seconddim[ival])) ### USER ###
-+            my_legend.append('$N_\\varepsilon = {0:d}$'.format(seconddim[ival])) ### USER ###
-+            #my_legend.append('$v_{max} ='+str(seconddim[ival])+'$') ### USER ###
-+            #my_legend.append('$N_{\\lambda,trap} = '+str(seconddim[ival])+'$') ### USER, with ntheta=32 ###
-+        if use_my_ylim:
-+            plt.ylim(my_ylim_avg)
-+        if use_my_xlim:
-+            plt.xlim(my_xlim)
-+        if plot_converged:
-+            plt.plot(firstdim_converged, gamma_avg_converged, linestyle = 'None', color='k', marker = 's', fillstyle = 'full')
-+            my_legend.append('$N_x = 535$') ### USER ###
-+        legend = plt.legend(my_legend, frameon = True, fancybox = False)
-+        frame = legend.get_frame()
-+        frame.set_facecolor('white')
-+        frame.set_edgecolor('black')
-+        frame.set_linewidth(0.5)
-+        frame.set_alpha(1)
-+        plt.savefig(pdfname)
-+
-+        pdfname = 'postproc/flowshear_gamma_max_scan_'+firstdim_var+'_'+seconddim_var+'.pdf'
-+        plt.figure()
-+        my_legend = []
-+        plt.grid(True)
-+        plt.xlabel('$\\rho k_y$') ### USER ###
-+        #plt.xlabel('jtwist') ### USER ###
-+        plt.ylabel('$\\gamma_{max}\ [v_{th}/a]$')
-+        for ival in range(valdim):
-+            if scan_with_single_ky:
-+                plt.plot(seconddim, gamma_max_collec, linewidth=2.0, color=color_collec[ival])
-+            else:
-+                plt.plot(firstdim_collec[ival], gamma_max_collec[ival], linewidth=2.0, color=color_collec[ival])
-+            #my_legend.append('$N_x = {0:d}$'.format(seconddim[ival])) ### USER ###
-+            #my_legend.append('$\\Delta k_x = {0:1.3f}$'.format(seconddim[ival])) ### USER ###
-+            #my_legend.append('$\\rho k_y = {0:1.3f}$'.format(seconddim[ival])) ### USER ###
-+            #my_legend.append('$N_\\theta = {0:d}$'.format(seconddim[ival])) ### USER ###
-+            my_legend.append('$N_\\varepsilon = {0:d}$'.format(seconddim[ival])) ### USER ###
-+            #my_legend.append('$v_{max} ='+str(seconddim[ival])+'$') ### USER ###
-+            #my_legend.append('$N_{\\lambda,trap} = '+str(seconddim[ival])+'$') ### USER, with ntheta=32 ###
-+        if use_my_ylim:
-+            plt.ylim(my_ylim_max)
-+        if use_my_xlim:
-+            plt.xlim(my_xlim)
-+        if plot_converged:
-+            plt.plot(firstdim_converged, gamma_max_converged, linestyle = 'None', color='k', marker = 's', fillstyle = 'full')
-+            my_legend.append('$N_x = 535$') ### USER ###
-+        legend = plt.legend(my_legend, frameon = True, fancybox = False)
-+        frame = legend.get_frame()
-+        frame.set_facecolor('white')
-+        frame.set_edgecolor('black')
-+        frame.set_linewidth(0.5)
-+        frame.set_alpha(1)
-+        plt.savefig(pdfname)
-+
-+class gs2_param:
-+    def __init__(self, var='', dim=np.array([]), in_list='', func=None):
-+        self.name = var
-+        self.dim = dim
-+        self.namelist = in_list
-+        self.func = func
-+
-+def add_param_to_scan(scan, name, dim, namelist, scandim, func):
-+    newparam = gs2_param(name, dim, namelist, func)
-+    if scandim == ONE:
-+        scan[ONE].append(newparam)
-+    elif scandim == TWO:
-+        scan[TWO].append(newparam)
-+    else:
-+        sys.exit('ERROR: this code only supports up to '+NDIM_MAX+' dimensions for a scan.')
-+
-+def increment_dim(scandim):
-+    if scandim == ONE:
-+        scandim = TWO
-+    else:
-+        scandim = END
-+    return scandim
-+
-+def read_data(fname, valtree, scandim, ival_firstdim, firstdim_collec, gamma_avg_collec, gamma_max_collec):
-+
-+    # Iterate over every set of values taken by parameters in this dimension of the scan.
-+    for ival in range(scan[scandim][0].dim):
-+    
-+        # Name-base and patch to be modified for this ival.
-+        my_fname = fname
-+
-+        # For every new value of firstdim, append elements
-+        if scandim==ONE and ival_firstdim!=ival:
-+            ival_firstdim = ival
-+            firstdim_collec.append([])
-+            gamma_avg_collec.append([])
-+            gamma_max_collec.append([])
-+
-+        # For every parameter in this dimension of the scan, modify the files.
-+        for iparam in range(len(scan[scandim])):
-+            # Append parameter to namelist for in-file patching
-+            var = scan[scandim][iparam].name
-+            val = scan[scandim][iparam].func(ival,valtree)
-+            # Append parameter to the filenames
-+            my_fname = my_fname + '_' + var + '_' + str(val)
-+            # Update history tree
-+            if scandim == ONE:
-+                iparam_all = iparam
-+            if scandim == TWO:
-+                iparam_all = len(scan[ONE]) + iparam
-+            valtree[iparam_all] = val
-+        
-+        # If we are at the bottom of the tree, then read from the file.
-+        if scandim == ndim:
-+            my_vars = read_from_file(my_fname)
-+            firstdim_collec[ival_firstdim].append(my_vars[firstdim_var][0])
-+            gamma_avg_collec[ival_firstdim].append(my_vars['gamma_avg'][0])
-+            gamma_max_collec[ival_firstdim].append(my_vars['gamma_max'][0])
-+        # Or move on to the next dimension of the scan by calling function recursively
-+        else:
-+            next_scandim = increment_dim(scandim)
-+            read_data(my_fname, valtree, next_scandim, ival_firstdim, firstdim_collec, gamma_avg_collec, gamma_max_collec)
-+
-+def read_from_file(fname):
-+
-+    datfile_name = 'postproc/' + fname + '.flowshear_lingrowth.dat' ### USER ###
-+
-+    with open(datfile_name, 'rb') as infile: # 'rb' stands for read bytes
-+        my_vars = pickle.load(infile)
-+
-+    return my_vars
-+
-+def write_to_file(vardict):
-+
-+    datfile_name = 'postproc/flowshear_lingrowth_scan2D.dat'
-+    with open(datfile_name, 'wb') as outfile: # 'wb' stands for write bytes
-+        pickle.dump(vardict,outfile)
-+
-+# Execute main
-+if __name__ == '__main__':
-+    main()
-diff --git a/plot_misc/plot_scan_lingrowth_nogexb.py b/plot_misc/plot_scan_lingrowth_nogexb.py
-new file mode 100644
-index 0000000..07da160
---- /dev/null
-+++ b/plot_misc/plot_scan_lingrowth_nogexb.py
-@@ -0,0 +1,141 @@
-+import sys
-+import os
-+
-+# Add path to directory where scan-files are stored
-+sys.path.insert(1, '/marconi/home/userexternal/nchriste/codes/scan_gs2/paramfiles')
-+
-+import f90nml as fnml
-+import numpy as np
-+import copy as cp
-+import pickle
-+import matplotlib.pyplot as plt
-+
-+#plt.rcParams.update({'font.size': 22})
-+
-+ONE = 'one'
-+TWO = 'two'
-+NDIM_MAX = TWO
-+ndim = ONE
-+
-+# Dict that will contain every parameter to scan
-+scan = {ONE:[],TWO:[]}
-+
-+# Import all parameters from paramfiles/myfile.py
-+pf = __import__('ntheta_scan_nogexb_085_new') ### USER ###
-+
-+def main():
-+
-+    base_name = 'psin_0.85' ### USER ###
-+
-+    # Add all parameters to the current scan
-+    nparams = len(pf.name)
-+    for iparam in range(nparams):
-+        add_param_to_scan(pf.name[iparam], pf.val[iparam], pf.namelist[iparam], scan, pf.scandim[iparam])
-+
-+    # Read data from .dat files for every file in scan
-+    var_firstdim = scan[ONE][0].name
-+    val_firstdim = scan[ONE][0].value
-+    ky_collec = []
-+    gamma_collec = []
-+    scandim=ONE
-+    ival_firstdim = -1
-+    read_data(base_name, scandim, ival_firstdim, ky_collec, gamma_collec)
-+
-+    # Plotting
-+    color_collec = plt.cm.gnuplot(np.linspace(0,1,val_firstdim.size)) # for newalgo
-+
-+    pdfname = 'postproc/noflowshear_gamma.pdf'
-+    plt.figure()
-+    my_legend = []
-+    plt.grid(True)
-+    plt.xlabel('$\\rho k_y$')
-+    plt.ylabel('$\\gamma [v_{th}/a]$')
-+    for ival in range(val_firstdim.size):
-+        ky_collec[ival] = np.squeeze(ky_collec[ival][0])
-+        gamma_collec[ival] = np.squeeze(gamma_collec[ival][0])
-+        plt.plot(ky_collec[ival], gamma_collec[ival], linewidth=3.0, color=color_collec[ival])
-+        my_legend.append('$N_\\theta = {:d}$'.format(val_firstdim[ival]))
-+    plt.legend(my_legend)
-+    plt.savefig(pdfname)
-+
-+    # Save data for whole scan in file
-+    vardict = {}
-+    vardict['var_firstdim'] = var_firstdim
-+    vardict['val_firstdim'] = val_firstdim
-+    vardict['ky_collec'] = ky_collec
-+    vardict['gamma_collec'] = gamma_collec
-+    write_to_file(vardict)
-+
-+class gs2_param:
-+    def __init__(self, var='', val=np.array([]), in_list=''):
-+        self.name = var
-+        self.value = val
-+        self.namelist = in_list
-+
-+def add_param_to_scan(name, values, namelist, scan, scandim):
-+    newparam = gs2_param(name, values, namelist)
-+    if scandim == ONE:
-+        scan[ONE].append(newparam)
-+    elif scandim == TWO:
-+        scan[TWO].append(newparam)
-+    else:
-+        sys.exit('ERROR: this code only supports up to '+NDIM_MAX+' dimensions for a scan.')
-+
-+def increment_dim(scandim):
-+    if scandim == ONE:
-+        scandim = TWO
-+    else:
-+        scandim = END
-+    return scandim
-+
-+def read_data(fname, scandim, ival_firstdim, ky_collec, gamma_collec):
-+
-+    # Iterate over every set of values taken by parameters in this dimension of the scan.
-+    for ival in range(scan[scandim][0].value.size):
-+    
-+        # Name-base and variable container for this ival
-+        my_fname = fname
-+        #ky_collec = cp.deepcopy(ky_collec)
-+        #gamma_avg_collec = cp.deepcopy(gamma_avg_collec)
-+        #gamma_max_collec = cp.deepcopy(gamma_max_collec)
-+
-+        if scandim==ONE and ival_firstdim!=ival:
-+            ival_firstdim = ival
-+            ky_collec.append([])
-+            gamma_collec.append([])
-+
-+        for iparam in range(len(scan[scandim])):
-+            var = scan[scandim][iparam].name
-+            val = scan[scandim][iparam].value[ival]
-+            # Append parameter to the filenames
-+            my_fname = my_fname + '_' + var + '_' + str(val)
-+        
-+        # If we are at the last dimension of the scan, then read from the file.
-+        if scandim == ndim:
-+            ky, gamma = read_from_file(my_fname)
-+            ky_collec[ival_firstdim].append(ky)
-+            gamma_collec[ival_firstdim].append(gamma)
-+
-+        # Or move on to the next dimension of the scan by calling function recursively
-+        else:
-+            next_scandim = increment_dim(scandim)
-+            read_data(my_fname, next_scandim, ival_firstdim, ky_collec, gamma_collec)
-+
-+def read_from_file(fname):
-+
-+    datfile_name = 'postproc/' + fname + '.lingrowth.dat' ### USER ###
-+
-+    with open(datfile_name, 'rb') as infile: # 'rb' stands for read bytes
-+        dummy1, dummy2, ky, gamma, dummy3  = pickle.load(infile)
-+
-+    return ky, gamma
-+
-+def write_to_file(vardict):
-+
-+    datfile_name = 'postproc/noflowshear_lingrowth_scan.dat'
-+    with open(datfile_name, 'wb') as outfile: # 'wb' stands for write bytes
-+        pickle.dump(vardict,outfile)
-+
-+# Execute main
-+if __name__ == '__main__':
-+    main()
-diff --git a/tasks/floquet.py b/tasks/floquet.py
-index 65f293d..c159781 100644
---- a/tasks/floquet.py
-+++ b/tasks/floquet.py
-@@ -122,6 +122,7 @@ def process_and_save_to_dat(ifile, run, myin, myout, my_dmid, iky_list):
-         N = np.nan
- 
-     phi2_gs2 = myout['phi2_by_mode'][:,:,:]
-+    omega_gs2 = myout['omega_average'][:,:,:,0] # real frequency
- 
-     phi_t_present = myout['phi_t_present']
-     if phi_t_present:
-@@ -129,8 +130,8 @@ def process_and_save_to_dat(ifile, run, myin, myout, my_dmid, iky_list):
-    
-     # sorting kx_gs2 to get monotonic kx_bar
-     kx_bar = np.concatenate((kx_gs2[ikx_min:],kx_gs2[:ikx_min]))
--    #print(kx_bar) # NDCTEST
-     phi2 = np.concatenate((phi2_gs2[:,:,ikx_min:], phi2_gs2[:,:,:ikx_min]), axis=2)
-+    omega = np.concatenate((omega_gs2[:,:,ikx_min:], omega_gs2[:,:,:ikx_min]), axis=2)
-     if phi_t_present:
-         phi2_bytheta = np.concatenate((phi2_bytheta_gs2[:,:,ikx_min:,:], phi2_bytheta_gs2[:,:,:ikx_min,:]), axis=2)
- 
-@@ -170,6 +171,8 @@ def process_and_save_to_dat(ifile, run, myin, myout, my_dmid, iky_list):
-     phi2bloon_jump = []
-     sum_phi2bloon = []
-     max_phi2bloon = []
-+    omegabloon = []
-+    kxbarbloon = []
-     gamma = []
-     kx_star_for_gamma = []
- 
-@@ -185,6 +188,8 @@ def process_and_save_to_dat(ifile, run, myin, myout, my_dmid, iky_list):
-         sum_phi2bloon_chain = []
-         max_phi2bloon_chain = []
-         gamma_chain = []
-+        omegabloon_chain = []
-+        kxbarbloon_chain = []
-         kx_star_for_gamma_chain = []
- 
-         iTf = 0
-@@ -192,24 +197,6 @@ def process_and_save_to_dat(ifile, run, myin, myout, my_dmid, iky_list):
-         kx_star_for_gamma_floq = []
- 
-         for it in range(nt):
--            #NDCTEST
--            # To test if initial condition satisfies parallel BC. Apparently does not when shat<0.
--            #if iky==1 and it<10:
--            #    print('---------------------')
--            #    print('FOR TEST')
--            #    print('phi2(-pi) = ')
--            #    print(phi2_bytheta[it,iky,:,0])
--            #    print('phi2(+pi) = ')
--            #    print(phi2_bytheta[it,iky,:,-1])
--            #    if shat>0.:
--            #        print('phi_l = '+str(phi2_bytheta[it,iky,-1,-1])) # phi_l
--            #        print('phi_r = '+str(phi2_bytheta[it,iky,-2,0])) # phi_r
--            #    else:
--            #        # correct
--            #        print('phi_l = '+str(phi2_bytheta[it,iky,-1,0])) # phi_l
--            #        print('phi_r = '+str(phi2_bytheta[it,iky,-2,-1])) # phi_r
--            #    print('---------------------')
--            #endNDCTEST
- 
-             ikx_members_now = []
-             ikx_prevmembers_now = []
-@@ -219,6 +206,8 @@ def process_and_save_to_dat(ifile, run, myin, myout, my_dmid, iky_list):
-             phi2bloon_discont_now = []
-             phi2bloon_jump_now = []
-             sum_phi2bloon_now = 0
-+            omegabloon_now = []
-+            kxbarbloon_now = []
- 
-             # BLACK MAGIC LINE :
-             # if the position of delt and it are swapped in the following multiplication,
-@@ -232,7 +221,7 @@ def process_and_save_to_dat(ifile, run, myin, myout, my_dmid, iky_list):
-             else:
-                 ikx_shift = int(round(g_exb*ky[iky]*delt*(nwrite*it-0.5)/dkx))
-                 ikx_shift_old = int(round(g_exb*ky[iky]*delt*(nwrite*(it-1)-0.5)/dkx))
--    
-+
-             # Build collection of ikx's that are included
-             # in the chain at time step it (ikx_members_now)
-             # and at time step it-1 (ikx_prevmembers_now).
-@@ -292,6 +281,11 @@ def process_and_save_to_dat(ifile, run, myin, myout, my_dmid, iky_list):
-                             b_ang = theta[itheta] - kx[it,iky,ikx_members_now[imember]]/(shat*ky[iky])
-                         bloonang_now.append(b_ang)
-                         phi2bloon_now.append(phi2_bytheta[it,iky,ikx_members_now[imember],itheta])
-+                
-+                # construct chain of real frequency
-+                for imember in member_range:
-+                    omegabloon_now.append(omega[it,iky,ikx_members_now[imember]])
-+                    kxbarbloon_now.append(kx_bar[ikx_members_now[imember]])
- 
-                 # Saving discontinuities and bloonang at link position to plot later
-                 member_range = range(len(ikx_members_now)-1)
-@@ -305,35 +299,6 @@ def process_and_save_to_dat(ifile, run, myin, myout, my_dmid, iky_list):
-                     b_ang_bndry = pi-kx_star[it,iky,ikx_members_now[imember]]/(shat*ky[iky])
-                     bloonang_bndry_now.append(b_ang_bndry)
- 
--                # Computing 'growthrate' for every kxstar present in the chain
--                if it>0 and g_exb != 0.0:
--                    # index of the Floquet oscillation we are in
--                    iTf_new = int(round(delt*(it*nwrite-0.5)/Tf))
--                    # If we enter the next Floquet oscillation,
--                    # append gamma to gamma_chain
--                    # and start working with new oscillation.
--                    if iTf_new > iTf:
--                        # Oh dare ! -- J. Bercow, 2019
--                        idx_sort = [i[0] for i in sorted(enumerate(kx_star_for_gamma_floq), key=lambda x:x[1])]
--                        kx_star_for_gamma_floq = [kx_star_for_gamma_floq[i] for i in idx_sort]
--                        gamma_floq = [gamma_floq[i] for i in idx_sort]
--                        # and append
--                        gamma_chain.append(gamma_floq)
--                        kx_star_for_gamma_chain.append(kx_star_for_gamma_floq)
--                        gamma_floq = []
--                        kx_star_for_gamma_floq = []
--                        iTf = iTf_new
--                    for imember in range(len(ikx_members_now)):
--                        ikx = ikx_members_now[imember]
--                        ikxprev = ikx_prevmembers_now[imember]
--                        kx_star_for_gamma_floq.append(kx_star[it,iky,ikx])
--                        if not np.isnan(ikxprev):
--                            gam = 1./(2.*nwrite*delt) * np.log( \
--                                    np.amax(phi2_bytheta[it,iky,ikx,:]) / np.amax(phi2_bytheta[it-1,iky,ikxprev,:]) )
--                            gamma_floq.append(gam)
--                        else:
--                            gamma_floq.append(np.nan)
--
-             ikx_members_chain.append(ikx_members_now)
-             ikx_prevmembers_chain.append(ikx_prevmembers_now)
-             bloonang_chain.append(bloonang_now)
-@@ -342,6 +307,8 @@ def process_and_save_to_dat(ifile, run, myin, myout, my_dmid, iky_list):
-             phi2bloon_discont_chain.append(phi2bloon_discont_now)
-             phi2bloon_jump_chain.append(phi2bloon_jump_now)
-             sum_phi2bloon_chain.append(sum_phi2bloon_now)
-+            omegabloon_chain.append(omegabloon_now)
-+            kxbarbloon_chain.append(kxbarbloon_now)
-             max_phi2bloon_chain.append(max(phi2bloon_now))
-     
-         # Adding the chain to the full collection
-@@ -354,20 +321,8 @@ def process_and_save_to_dat(ifile, run, myin, myout, my_dmid, iky_list):
-         phi2bloon_jump.append(phi2bloon_jump_chain)
-         sum_phi2bloon.append(sum_phi2bloon_chain)
-         max_phi2bloon.append(max_phi2bloon_chain)
--        if g_exb != 0.0:
--            kx_star_for_gamma.append(kx_star_for_gamma_chain)
--            gamma.append(gamma_chain)
--
--    if g_exb==0.0:
--        it_start = round(0.5*nt)
--        gamma = np.zeros((nakx,len(iky_list)))
--        tofit_sq = np.amax(phi2_bytheta,axis=3) # take the max in theta for each 2pi segment
--        for ikx in range(nakx):
--            for iiky in range(len(iky_list)):
--                iky = iky_list[iiky]
--                gam = get_growthrate(t,tofit_sq[:,iky,ikx],it_start)
--                gam = gam/2. # because we fitted the square
--                gamma[ikx,iiky] = gam
-+        omegabloon.append(omegabloon_chain)
-+        kxbarbloon.append(kxbarbloon_chain)
- 
-     # Saving variables to mat-file
-     my_vars = {}
-@@ -396,8 +351,8 @@ def process_and_save_to_dat(ifile, run, myin, myout, my_dmid, iky_list):
-     my_vars['phi2bloon_jump'] = phi2bloon_jump
-     my_vars['sum_phi2bloon'] = sum_phi2bloon
-     my_vars['max_phi2bloon'] = max_phi2bloon
--    my_vars['gamma'] = gamma
--    my_vars['kx_star_for_gamma'] = kx_star_for_gamma
-+    my_vars['omegabloon'] = omegabloon
-+    my_vars['kxbarbloon'] = kxbarbloon
- 
-     #TESTpickle
-     #mat_file_name = run.out_dir + run.fnames[ifile] + '.floquet.mat'
-@@ -462,14 +417,164 @@ def plot_task_single(ifile, run, my_vars, my_it, my_dmid, make_movies):
-     phi2bloon_jump = my_vars['phi2bloon_jump']
-     sum_phi2bloon = my_vars['sum_phi2bloon']
-     max_phi2bloon = my_vars['max_phi2bloon']
--    kx_star_for_gamma = my_vars['kx_star_for_gamma']
--    gamma = my_vars['gamma']
-+    omegabloon = my_vars['omegabloon']
-+    kxbarbloon = my_vars['kxbarbloon']
-     
-     Tf = Nf*delt
-     nt = t.size
- 
-     myfig = plt.figure(figsize=(12,8))
- 
-+    # Plot sum and max of phi2 vs time for every ky
-+    # Fit each curve and plot gamma_avg vs ky
-+
-+    # Start comparing simulations at time-step it_start = N_start*Tfloquet/dt
-+    # ie after N_start Floquet oscillations
-+    # Normalise sum_phi2 by sum_phi2[it_start] for each run
-+    skip_init = False # Start plotting at it=it_start, instead of it=0
-+    if g_exb != 0.0:
-+        N_start = 2 #30 # adapt this
-+        it_start = int(round((N_start*Tf/delt)/nwrite))
-+    else:
-+        fac = 0.5 # adapt this
-+        it_start = round(fac*nt) # adapt this
-+
-+    t_collec = []
-+    sum_phi2_collec = []
-+    max_phi2_collec = []
-+    
-+    # Compute <gamma>_t
-+    slope_sum = np.zeros(len(iky_list))
-+    slope_max = np.zeros(len(iky_list))
-+    offset_max = np.zeros(len(iky_list))
-+    for iiky in range(len(iky_list)):
-+        sum_phi2_tmp = np.zeros(len(sum_phi2bloon[iiky])-it_start)
-+        max_phi2_tmp = np.zeros(len(sum_phi2bloon[iiky])-it_start)
-+        for it in range(sum_phi2_tmp.size):
-+            sum_phi2_tmp[it] = sum_phi2bloon[iiky][it_start+it]
-+            max_phi2_tmp[it] = max_phi2bloon[iiky][it_start+it]
-+        if it_start > 0:
-+            sum_phi2_tmp = sum_phi2_tmp/sum_phi2_tmp[0]
-+            max_phi2_tmp = max_phi2_tmp/max_phi2_tmp[0]
-+        sum_phi2_collec.append(sum_phi2_tmp)
-+        max_phi2_collec.append(max_phi2_tmp)
-+        
-+        t_tmp = np.zeros(len(t)-it_start)
-+        for it in range(t_tmp.size):
-+            t_tmp[it] = t[it_start+it]
-+        t_collec.append(t_tmp)
-+
-+        [gam,dummy] = leastsq_lin(t_tmp,np.log(sum_phi2_tmp))
-+        slope_sum[iiky] = gam/2. # divide by 2 because fitted square
-+        [gam,offset] = leastsq_lin(t_tmp,np.log(max_phi2_tmp))
-+        slope_max[iiky] = gam/2. # divide by 2 because fitted square
-+        offset_max[iiky] = offset
-+    # At this point:
-+    # fit_avg(t) ~ phi2(tstart) * exp[2*gam*t + offset]
-+
-+    # Compute gamma_max from ln(phi2_max)
-+    if g_exb != 0.0:
-+        it_gamma_max = np.zeros(len(iky_list))
-+        gamma_max = np.zeros(len(iky_list))
-+        for iiky in range(len(iky_list)):
-+            # Start looking for derivatives one Floquet period before last time-step
-+            it_start_last_floq = max(int(len(max_phi2bloon[iiky]) - Tf//(delt*nwrite) - 1),0)
-+            it_end_last_floq = int(len(max_phi2bloon[iiky]) - 1)
-+            for it in range(it_start_last_floq, it_end_last_floq):
-+                # Factor of 0.5 because we fit phi^2
-+                gamma_max_tmp = 0.5 * 1./(2*delt*nwrite) * \
-+                        ( np.log(max_phi2bloon[iiky][it+1]) - np.log(max_phi2bloon[iiky][it-1]) )
-+                if (gamma_max_tmp > gamma_max[iiky]):
-+                    it_gamma_max[iiky] = it
-+                    gamma_max[iiky] = gamma_max_tmp
-+        it_gamma_max = it_gamma_max.astype(int)
-+        # At this point:
-+        # fit_max(t) ~ phi2(tstart) * exp[2*gamma_max*(t-t_gamma_max)]
-+
-+        # Save growthrates to dat-file
-+        my_vars = {}
-+        my_vars['ky'] = ky[1:]
-+        my_vars['gamma_avg'] = slope_max
-+        my_vars['gamma_max'] = gamma_max
-+        datfile_name = run.out_dir + run.fnames[ifile] + '.flowshear_lingrowth.dat'
-+        with open(datfile_name, 'wb') as outfile: # 'wb' stands for write bytes
-+            pickle.dump(my_vars,outfile)
-+    
-+    plt.figure(figsize=(12,8))
-+    plt.xlabel('$t$')
-+    plt.ylabel('$\\log\\sum_{K_x}\\vert \\langle\\phi\\rangle_\\theta \\vert ^2$')
-+    plt.grid(True)
-+    my_legend = []
-+    my_colorlist = plt.cm.YlOrBr(np.linspace(0.2,1,len(iky_list))) # for newalgo
-+    #my_colorlist = plt.cm.YlGnBu(np.linspace(0.2,1,len(iky_list))) # for oldalgo
-+    if skip_init:
-+        for iiky in range(len(iky_list)):
-+            my_legend.append('$k_y = {:.3f}$'.format(ky[iky_list[iiky]]))
-+            #plt.semilogy(t_collec[iiky], sum_phi2_collec[iiky], color=my_colorlist[iiky], linewidth=3.0)
-+            plt.plot(t_collec[iiky], np.log(sum_phi2_collec[iiky]), color=my_colorlist[iiky], linewidth=3.0)
-+    else:
-+        for iiky in range(len(iky_list)):
-+            my_legend.append('$k_y = {:.3f}$'.format(ky[iky_list[iiky]]))
-+            #plt.semilogy(t_collec[iiky], sum_phi2_collec[iiky], color=my_colorlist[iiky], linewidth=3.0)
-+            plt.plot(t, np.log(sum_phi2bloon[iiky]), color=my_colorlist[iiky], linewidth=3.0)
-+    plt.legend(my_legend)
-+    pdfname = 'floquet_sum_vs_t_all_ky' + '_dmid_' + str(my_dmid) 
-+    pdfname = run.out_dir + pdfname + '_' + run.fnames[ifile] + '.pdf'
-+    plt.savefig(pdfname)
-+    plt.clf()
-+    plt.cla()
-+
-+    plt.figure(figsize=(12,8))
-+    plt.xlabel('$t$')
-+    plt.ylabel('$\\max_{K_x}\\vert \\langle\\phi\\rangle_\\theta \\vert ^2$')
-+    plt.grid(True)
-+    my_legend = []
-+    my_colorlist = []
-+    # only use blue
-+    for iiky in range(len(iky_list)):
-+        my_colorlist.append(gplots.myblue)
-+    #my_colorlist = plt.cm.YlOrBr(np.linspace(0.2,1,len(iky_list))) # for newalgo
-+    #my_colorlist = plt.cm.YlGnBu(np.linspace(0.2,1,len(iky_list))) # for oldalgo
-+    if skip_init:
-+        for iiky in range(len(iky_list)):
-+            plt.semilogy(t_collec[iiky], max_phi2_collec[iiky], color=my_colorlist[iiky], linewidth=3.0)
-+            my_legend.append('$k_y = {:.3f}$'.format(ky[iky_list[iiky]]))
-+            # Add fits for average and maximum growthrates
-+            plt.semilogy(t_collec[iiky], np.exp(2.0*slope_max[iiky]*t_collec[iiky]+offset_max[iiky]),\
-+                    color=my_colorlist[iiky], linewidth=3.0, linestyle='--')
-+            if g_exb != 0.0:
-+                my_legend.append('$\\langle\\gamma\\rangle_t = {:.3f}$'.format(slope_max[iiky]))
-+                bot, top = plt.ylim()
-+                plt.semilogy(t_collec[iiky], max_phi2bloon[iiky][it_gamma_max[iiky]]/max_phi2bloon[iiky][it_start] * \
-+                        np.exp(2.0*gamma_max[iiky]*(t_collec[iiky]-t[it_gamma_max[iiky]])),\
-+                        color=my_colorlist[iiky], linewidth=3.0, linestyle=':')
-+                my_legend.append('$\\gamma_{max} '+'= {:.3f}$'.format(gamma_max[iiky]))
-+                plt.ylim(bot,top)
-+            else:
-+                my_legend.append('$\\gamma = {:.3f}$'.format(slope_max[iiky]))
-+    else:
-+        for iiky in range(len(iky_list)):
-+            plt.semilogy(t, max_phi2bloon[iiky], color=my_colorlist[iiky], linewidth=3.0)
-+            my_legend.append('$k_y = {:.3f}$'.format(ky[iky_list[iiky]]))
-+            # Add fits for average and maximum growthrates
-+            plt.semilogy(t, max_phi2bloon[iiky][it_start]*np.exp(2.0*slope_max[iiky]*t+offset_max[iiky]),\
-+                    color=my_colorlist[iiky], linewidth=3.0, linestyle='--')
-+            if g_exb != 0.0:
-+                my_legend.append('$\\langle\\gamma\\rangle_t = {:.3f}$'.format(slope_max[iiky]))
-+                bot, top = plt.ylim()
-+                plt.semilogy(t, max_phi2bloon[iiky][it_gamma_max[iiky]]*np.exp(2.0*gamma_max[iiky]*(t-t[it_gamma_max[iiky]])),\
-+                        color=my_colorlist[iiky], linewidth=3.0, linestyle=':')
-+                my_legend.append('$\\gamma_{max} '+'= {:.3f}$'.format(gamma_max[iiky]))
-+                plt.ylim(bot,top)
-+            else:
-+                my_legend.append('$\\gamma = {:.3f}$'.format(slope_max[iiky]))
-+    plt.legend(my_legend)
-+    pdfname = 'floquet_max_vs_t_all_ky' + '_dmid_' + str(my_dmid) 
-+    pdfname = run.out_dir + pdfname + '_' + run.fnames[ifile] + '.pdf'
-+    plt.savefig(pdfname)
-+    plt.clf()
-+    plt.cla()
-+
-     for iiky in range(len(iky_list)):
-     
-         iky = iky_list[iiky]
-@@ -497,58 +602,75 @@ def plot_task_single(ifile, run, my_vars, my_it, my_dmid, make_movies):
-         plt.clf()
-         plt.cla()
- 
-+        ## set up time stepping for snapshots and movies
-+        max_it_for_snap = nt
-+        it_step_for_snap = 10 # Adapt this
-+        max_it_for_mov = nt
-+        it_step_for_mov = 10
-+
-+        ## Plot real frequency of connected chain, vs kxbar
-+        # Save snapshots
-+        tmp_pdf_id = 1
-+        pdflist = []
-+        for it in range(0,max_it_for_snap,it_step_for_snap):
-+            l1, = plt.plot(kxbarbloon[iiky][it],omegabloon[iiky][it], marker='o', color=gplots.myblue, \
-+                    markersize=12, markerfacecolor=gplots.myblue, markeredgecolor=gplots.myblue, linewidth=3.0)
-+            plt.xlabel('$\\rho\\bar{k}_x$')
-+            plt.ylabel('$\\omega$'+' '+'$[v_{thr}/r_r]$')
-+            plt.grid(True)
-+            ax = plt.gca()
-+            ax.set_title('$k_y={:.2f}$'.format(ky[iky]) + ', $t={:.2f}$'.format(t[it]))
-+            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-+            gplots.save_plot(tmp_pdfname, run, ifile)
-+            pdflist.append(tmp_pdfname)
-+            tmp_pdf_id = tmp_pdf_id+1
-+
-+        merged_pdfname = 'omega_snaps'
-+        gplots.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-+        plt.clf()
-+        plt.cla()
-+
-         if (phi_t_present):
--           
--            # plot phi2 of chosen chain vs ballooning angle at chosen time
--            for it in my_it:
--                plt.xlabel('$\\theta -\\theta_0^*$') # NDCPARAM: check plot_against_theta0_star
--                plt.ylabel('$\\vert \\phi \\vert ^2$')
--                plt.title('$t=$ '+str(t[it])+', $k_y={:.2f}$'.format(ky[iky]))
-+
-+            # find global min and max of ballooning angle
-+            bloonang_min = 0.
-+            bloonang_max = 0.
-+            for it in range(max_it_for_snap):
-+                if np.min(bloonang[iiky][it]) < bloonang_min:
-+                    bloonang_min = np.min(bloonang[iiky][it])
-+                if np.max(bloonang[iiky][it]) > bloonang_max:
-+                    bloonang_max = np.max(bloonang[iiky][it])
-+
-+            ## Save snapshots
-+            tmp_pdf_id = 1
-+            pdflist = []
-+            for it in range(0,max_it_for_snap,it_step_for_snap):
-+                l1, = plt.plot(bloonang[iiky][it],phi2bloon[iiky][it], marker='o', color=gplots.myblue, \
-+                        markersize=12, markerfacecolor=gplots.myblue, markeredgecolor=gplots.myblue, linewidth=3.0)
-+                l2, = plt.plot(bloonang_bndry[iiky][it],phi2bloon_discont[iiky][it], linestyle='', \
-+                        marker='o', markersize=8, markerfacecolor='r', markeredgecolor='r')
-+                plt.xlabel('$\\theta -\\theta_0^*$') # NDCPARAM: check for plot_against_theta0_star
-                 plt.grid(True)
--                plt.gca().set_xlim(np.min(bloonang[iiky][it]),np.max(bloonang[iiky][it]))
-+                plt.gca().set_xlim(bloonang_min,bloonang_max)
-                 plt.gca().yaxis.set_major_formatter(FormatStrFormatter('%.1E'))
--                plt.plot(bloonang[iiky][it], phi2bloon[iiky][it], marker='o', \
--                        markersize=12, markerfacecolor='none', markeredgecolor=gplots.myblue, linewidth=3.0)
--
--                pdfname = 'balloon_it_' + str(it) + '_iky_' + str(iky) + '_dmid_' + str(my_dmid)
--                pdfname = run.out_dir + pdfname + '_' + run.fnames[ifile] + '.pdf'
--                plt.savefig(pdfname)
--                
--                plt.clf()
--                plt.cla()
--            # NDCTEST: plotting mutliple times together
--            #plt.xlabel('$\\theta -\\theta_0$')
--            #plt.ylabel('$\\vert \\phi \\vert ^2$')
--            #plt.grid(True)
--            #plt.gca().yaxis.set_major_formatter(FormatStrFormatter('%.1E'))
--            #line2, = plt.plot(bloonang_chain[210], phi2bloon_chain[210], marker='None', linestyle='--', linewidth=4.0, color=gplots.oxbluel)
--            #line3, = plt.plot(bloonang_chain[310], phi2bloon_chain[310], marker='None', linestyle=':', linewidth=3.0, color=gplots.oxbluell)
--            #line1, = plt.plot(bloonang_chain[110], phi2bloon_chain[110], marker='None', linewidth=5.0, color=gplots.oxblue)
--            #plt.legend([line1,line2,line3], ['$t=$ '+"{:.1f}".format(t[110]),'$t=$ '+"{:.1f}".format(t[210]),'$t=$ '+"{:.1f}".format(t[310])])
--            #plt.savefig('two_times_floquet.pdf')
--            #plt.clf()
--            #plt.cla()
--            # endNDCTEST
--        
--            # plot gamma vs kxstar/(pi*shat*ky)
--            #plt.title('$k_y={:.2f}$'.format(ky[iky]))
--            #plt.xlabel('$k_x^*/(\\pi\\hat{s}k_y)$')
--            #plt.ylabel('$\\langle\\gamma\\rangle_\\theta$')
--            #plt.grid(True)
--            #plt.plot(kxstar_over_ky[iiky], gamma[iiky], color=gplots.myblue, linewidth=3.0, marker='o') 
--            #pdfname = 'gamma_vs_kxstar_over_ky' + '_iky_' + str(iky) + '_dmid_' + str(my_dmid)
--            #pdfname = run.out_dir + pdfname + '_' + run.fnames[ifile] + '.pdf'
--            #plt.savefig(pdfname)
--            #
--            #plt.clf()
--            #plt.cla()
-+                ymin = np.amin(phi2bloon[iiky][it])
-+                ymax = np.amax(phi2bloon[iiky][it])
-+                ax = plt.gca()
-+                ax.set_ylim(ymin,ymax)
-+                ax.set_title('$k_y={:.2f}, t={:.2f}$'.format(ky[iky],t[it]))
-+                ax.legend(['$\\vert \\phi \\vert ^2$', '$\\Delta\\vert \\phi \\vert ^2$'])
-+                tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-+                gplots.save_plot(tmp_pdfname, run, ifile)
-+                pdflist.append(tmp_pdfname)
-+                tmp_pdf_id = tmp_pdf_id+1
-+
-+            merged_pdfname = 'phibloon_snaps'
-+            gplots.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-+            plt.clf()
-+            plt.cla()
- 
-             if (make_movies):
- 
--                # set time stepping for movies
--                max_it_for_mov = nt
--                it_step_for_mov = 1
--
-                 # find global min and max of ballooning angle
-                 bloonang_min = 0.
-                 bloonang_max = 0.
-@@ -638,209 +760,22 @@ def plot_task_single(ifile, run, my_vars, my_it, my_dmid, make_movies):
-                 plt.clf()
-                 plt.cla()
- 
--                print("\n... movies completed.")
--
--    # Plot sum and max of phi2 vs time for every ky
--    # Fit each curve and plot gamma_avg vs ky
--
--    # Start comparing simulations at time-step it_start = N_start*Tfloquet/dt
--    # ie after N_start Floquet oscillations
--    # Normalise sum_phi2 by sum_phi2[it_start] for each run
--    if g_exb != 0.0:
--        N_start = 0 # adapt this
--        it_start = int(round((N_start*Tf/delt)/nwrite))
--    else:
--        fac = 0.0 # adapt this
--        it_start = round(fac*nt) # adapt this
--
--    t_collec = []
--    sum_phi2_collec = []
--    max_phi2_collec = []
--    slope_sum = np.zeros(len(iky_list))
--    slope_max = np.zeros(len(iky_list))
--    
--    for iiky in range(len(iky_list)):
--
--        iky = iky_list[iiky]
--
--        sum_phi2_tmp = np.zeros(len(sum_phi2bloon[iiky])-it_start)
--        max_phi2_tmp = np.zeros(len(sum_phi2bloon[iiky])-it_start)
--        for it in range(sum_phi2_tmp.size):
--            sum_phi2_tmp[it] = sum_phi2bloon[iiky][it_start+it]
--            max_phi2_tmp[it] = max_phi2bloon[iiky][it_start+it]
--        if it_start > 0:
--            sum_phi2_tmp = sum_phi2_tmp/sum_phi2_tmp[0]
--            max_phi2_tmp = max_phi2_tmp/max_phi2_tmp[0]
--        sum_phi2_collec.append(sum_phi2_tmp)
--        max_phi2_collec.append(max_phi2_tmp)
--        
--        t_tmp = np.zeros(len(t)-it_start)
--        for it in range(t_tmp.size):
--            t_tmp[it] = t[it_start+it]
--        t_collec.append(t_tmp)
-+                ## Save snapshots
-+                #for it in range(0,max_it_for_mov,it_step_for_mov):
-+                #    l1, = plt.plot(bloonang_bndry[iiky][it],phi2bloon_jump[iiky][it], marker='o', color=gplots.myblue, \
-+                #            markersize=12, markerfacecolor=gplots.myblue, markeredgecolor=gplots.myblue, linewidth=3.0)
-+                #    plt.xlabel('$\\theta -\\theta_0^*$') # NDCPARAM: check for plot_against_theta0_star
-+                #    plt.ylabel('$\\Delta\\vert \\phi \\vert ^2/\\vert \\phi \\vert ^2$')
-+                #    plt.grid(True)
-+                #    plt.gca().set_xlim(bloonang_min,bloonang_max)
-+                #    ax = plt.gca()
-+                #    ax.set_ylim(0,1)
-+                #    ax.set_title('$k_y={:.2f}, t={:.2f}$'.format(ky[iky],t[it]))
-+                #    plt.savefig('phidiscont_snap_{:,d}.pdf'.format(it))
-+                #    plt.clf()
-+                #    plt.cla()
- 
--        [gam,dummy] = leastsq_lin(t_tmp,np.log(sum_phi2_tmp))
--        slope_sum[iiky] = gam/2. # divide by 2 because fitted square
--        [gam,dummy] = leastsq_lin(t_tmp,np.log(max_phi2_tmp))
--        slope_max[iiky] = gam/2. # divide by 2 because fitted square
--        #gam = get_growthrate(t,sum_phi2bloon[iiky],it_start)
--        #slope_sum[iiky] = gam/2. # divide by 2 because fitted square
--        #gam = get_growthrate(t,max_phi2bloon[iiky],it_start)
--        #slope_max[iiky] = gam/2. # divide by 2 because fitted square
--    
--    plt.figure(figsize=(12,8))
--    plt.xlabel('$t$')
--    plt.ylabel('$\\log\\sum_{K_x}\\vert \\langle\\phi\\rangle_\\theta \\vert ^2$')
--    #plt.title('Sum along a single ballooning mode')
--    plt.grid(True)
--    my_legend = []
--    my_colorlist = plt.cm.YlOrBr(np.linspace(0.2,1,len(iky_list))) # for newalgo
--    #my_colorlist = plt.cm.YlGnBu(np.linspace(0.2,1,len(iky_list))) # for oldalgo
--    for iiky in range(len(iky_list)):
--        my_legend.append('$k_y = {:.3f}$'.format(ky[iky_list[iiky]]))
--        #plt.semilogy(t_collec[iiky], sum_phi2_collec[iiky], color=my_colorlist[iiky], linewidth=3.0)
--        plt.plot(t_collec[iiky], np.log(sum_phi2_collec[iiky]), color=my_colorlist[iiky], linewidth=3.0)
--    plt.legend(my_legend)
--    pdfname = 'floquet_sum_vs_t_all_ky' + '_dmid_' + str(my_dmid) 
--    pdfname = run.out_dir + pdfname + '_' + run.fnames[ifile] + '.pdf'
--    plt.savefig(pdfname)
--    plt.clf()
--    plt.cla()
--
--    plt.figure(figsize=(12,8))
--    plt.xlabel('$t$')
--    plt.ylabel('$\\max_{K_x}\\vert \\langle\\phi\\rangle_\\theta \\vert ^2$')
--    plt.grid(True)
--    my_legend = []
--    my_colorlist = plt.cm.YlOrBr(np.linspace(0.2,1,len(iky_list))) # for newalgo
--    #my_colorlist = plt.cm.YlGnBu(np.linspace(0.2,1,len(iky_list))) # for oldalgo
--    for iiky in range(len(iky_list)):
--        my_legend.append('$k_y = {:.3f}$'.format(ky[iky_list[iiky]]))
--        plt.semilogy(t_collec[iiky], max_phi2_collec[iiky], color=my_colorlist[iiky], linewidth=3.0)
--    plt.legend(my_legend)
--    pdfname = 'floquet_max_vs_t_all_ky' + '_dmid_' + str(my_dmid) 
--    pdfname = run.out_dir + pdfname + '_' + run.fnames[ifile] + '.pdf'
--    plt.savefig(pdfname)
--    plt.clf()
--    plt.cla()
--    
--    plt.figure(figsize=(12,8))
--    plt.xlabel('$k_y$')
--    plt.ylabel('$\\langle\\gamma\\rangle_t$')
--    plt.grid(True)
--    ky_to_plot = np.zeros(len(iky_list))
--    for i in range(len(iky_list)):
--        ky_to_plot[i] = ky[iky_list[i]]
--    plt.plot(ky_to_plot, slope_sum, color=gplots.myblue, linewidth=3.0, marker='o')
--    pdfname = 'gamma_from_sum_vs_ky' + '_dmid_' + str(my_dmid) 
--    pdfname = run.out_dir + pdfname + '_' + run.fnames[ifile] + '.pdf'
--    plt.savefig(pdfname)
--    plt.clf()
--    plt.cla()
--    
--    plt.figure(figsize=(12,8))
--    plt.xlabel('$k_y$')
--    plt.ylabel('$\\langle\\gamma\\rangle_t$')
--    plt.grid(True)
--    ky_to_plot = np.zeros(len(iky_list))
--    for i in range(len(iky_list)):
--        ky_to_plot[i] = ky[iky_list[i]]
--    plt.plot(ky_to_plot, slope_max, color=gplots.myblue, linewidth=3.0, marker='o')
--    pdfname = 'gamma_from_max_vs_ky' + '_dmid_' + str(my_dmid) 
--    pdfname = run.out_dir + pdfname + '_' + run.fnames[ifile] + '.pdf'
--    plt.savefig(pdfname)
--    plt.clf()
--    plt.cla()
--
--    # plot gamma vs (kxstar,ky), for every Floquet oscillation in the simulation
--    if phi_t_present:
--
--        cbarmax = np.amax(slope_max)
--        cbarmin = -1.0*cbarmax
--
--        if g_exb != 0.0:
--
--            tmp_pdf_id = 1
--            pdflist = []
--            # Finer and regular kx, ky mesh for contour plot of gamma
--            nakx_fine = (kx_bar.size-1)*1e4+1
--            kx_grid_fine = np.linspace(np.amin(kx_bar)-dkx/2.,np.amax(kx_bar)+dkx/2.,nakx_fine)
--            ky_grid_fine = np.zeros(len(iky_list))
--            for iiky in range(len(iky_list)):
--                iky = iky_list[iiky]
--                ky_grid_fine[iiky] = ky[iky]
--
--            iTfmax = len(gamma[0])-1
--
--            for iTf in range(iTfmax,-1,-1):
--                # First arrange kx,ky,gamma similarly to fine meshes above
--                npoints = 0
--                for iiky in range(len(iky_list)):
--                    npoints = npoints + len(kx_star_for_gamma[iiky][iTf])
--                kx_grid_1d = np.zeros(npoints)
--                ky_grid_1d = np.zeros(npoints)
--                gamma_1d = np.zeros(npoints)
--                istart = 0
--                for iiky in range(len(iky_list)):
--                    iky = iky_list[iiky]
--                    for ikxstar in range(len(kx_star_for_gamma[iiky][iTf])):
--                        ipoint = istart + ikxstar
--                        kx_grid_1d[ipoint] = kx_star_for_gamma[iiky][iTf][ikxstar]
--                        ky_grid_1d[ipoint] = ky[iky]
--                        gamma_1d[ipoint] = gamma[iiky][iTf][ikxstar]
--                    istart = istart + len(kx_star_for_gamma[iiky][iTf])
--                # If GS2 indeed wrote out data during this Floquet oscillation, then
--                if gamma_1d.size > 0 :
--                    # interpolate to nearest neighbour on fine, regular mesh ...
--                    gamma_fine = scinterp.griddata((kx_grid_1d,ky_grid_1d),gamma_1d, \
--                            (kx_grid_fine[None,:],ky_grid_fine[:,None]),method='nearest')
--                    # ... and plot.
--                    if len(iky_list)>1: # many ky: plot contour
--                        my_title = '$d\\log(\\varphi)/dt, N_F={:d}/{:d}$'.format(iTf+1,len(gamma[iiky]))
--                        my_xlabel = '$k_x^*$'
--                        my_ylabel = '$k_y$'
--                        gplots.plot_2d(gamma_fine,kx_grid_fine,ky_grid_fine,cbarmin,cbarmax,
--                                xlab=my_xlabel,ylab=my_ylabel,title=my_title,cmp='RdBu_r')
--                    else: # single ky: 1d plot vs kxstar
--                        plt.plot(kx_grid_1d,gamma_1d,linewidth=3.0,color=gplots.myblue)
--                        plt.xlabel('$k_x^*$')
--                        plt.ylabel('$d\\log(\\varphi)/dt$')
--                        plt.title('$k_y={:.2f}, N_F={:d}/{:d}$'.format(ky[iky_list[0]],iTf+1,len(gamma[iiky])))
--                        ax = plt.gca()
--                        ax.set_ylim(cbarmin,cbarmax)
--                    tmp_pdfname = 'tmp'+str(tmp_pdf_id)
--                    gplots.save_plot(tmp_pdfname, run, ifile)
--                    pdflist.append(tmp_pdfname)
--                    tmp_pdf_id = tmp_pdf_id+1
--            pdflist = pdflist[::-1] # re-order since we iterated from last oscillation
--            merged_pdfname = 'gamma_vs_kxky' + '_dmid_' + str(my_dmid)
--            gplots.merge_pdfs(pdflist, merged_pdfname, run, ifile)
--
--        else: # g_exb = 0.0
--
--            if len(iky_list)>1: # many ky: plot contour
--                ky_to_plot = np.zeros(len(iky_list))
--                for iiky in range(len(iky_list)):
--                    ky_to_plot[iiky] = ky[iky_list[iiky]]
--                my_title = '$d\\log(\\varphi)/dt$'
--                my_xlabel = '$k_x^*$'
--                my_ylabel = '$k_y$'
--                gplots.plot_2d(np.transpose(gamma),kx_bar,ky_to_plot,cbarmin,cbarmax,
--                        xlab=my_xlabel,ylab=my_ylabel,title=my_title,cmp='RdBu_r')
--            else: # single ky: 1d plot vs kxstar
--                plt.plot(kx_bar,gamma[:,-1],linewidth=3.0,color=gplots.myblue)
--                plt.xlabel('$k_x^*$')
--                plt.ylabel('$d\\log(\\varphi)/dt$')
--                plt.title('$k_y={:.2f}$'.format(ky[iky_list[0]]))
--                ax = plt.gca()
--                ax.set_ylim(cbarmin,cbarmax)
--
--            pdfname = 'gamma_vs_kxky' + '_dmid_' + str(my_dmid)
--            pdfname = run.out_dir + pdfname + '_' + run.fnames[ifile] + '.pdf'
--            plt.savefig(pdfname)
--            
--            plt.clf()
--            plt.cla()
-+                print("\n... movies completed.")
- 
-     plt.close()
- 
-diff --git a/tasks/linbox.py b/tasks/linbox.py
-new file mode 100644
-index 0000000..45c2e83
---- /dev/null
-+++ b/tasks/linbox.py
-@@ -0,0 +1,711 @@
-+from matplotlib import pyplot as plt
-+from matplotlib.ticker import FormatStrFormatter
-+import matplotlib.animation as anim
-+import numpy as np
-+from math import pi
-+from math import ceil
-+import imageio
-+import os
-+import sys
-+import pickle
-+from PyPDF2 import PdfFileMerger, PdfFileReader
-+import scipy.interpolate as scinterp
-+import scipy.optimize as opt
-+
-+import gs2_plotting as gplot
-+
-+# A twist and shift chain is identified by dmid = 0,
-+# which is the number of dkx between kx=0 and the
-+# smallest kx>0 that is a member of the chain, at t=0.
-+
-+ndec_tt0 = 2
-+
-+def my_task_single(ifile, run, myin, myout, mytime, task_space):  
-+
-+
-+
-+
-+
-+    # vvv User parameters vvv
-+    
-+    # select chains
-+    dmid_list = []
-+
-+    # Select t/tfinal for plot of phi vs ballooning angle
-+    tRatio_toPlot = [1.0]
-+
-+    # make snapshots/movies along ballooning angle ?
-+    make_plots = True
-+
-+    make_snaps = False
-+    itSnap_min = 0
-+    itSnap_max = -1
-+    itSnap_step = 10
-+
-+    make_movies = False
-+    itMov_min = 0
-+    itMov_max = -1
-+    itMov_step = 1
-+
-+    make_movie_discont = False
-+
-+    # ^^^ User parameters ^^^
-+
-+
-+
-+
-+
-+    t = myout['t']
-+    delt = myin['knobs']['delt']
-+    nt = t.size
-+    nwrite = myin['gs2_diagnostics_knobs']['nwrite']
-+
-+    theta = myout['theta']
-+    ntheta = theta.size
-+    
-+    g_exb = myin['dist_fn_knobs']['g_exb']
-+    shat = myin['theta_grid_parameters']['shat']
-+    jtwist = int(myin['kt_grids_box_parameters']['jtwist'])
-+
-+    kx_gs2 = myout['kx']
-+    # We only consider the first non-zero ky
-+    ky = myout['ky'][1]
-+    dky = 1./myin['kt_grids_box_parameters']['y0']
-+    dkx = 2.*pi*abs(shat)*dky/jtwist
-+    nakx = kx_gs2.size
-+    ikx_max = int(round((nakx-1)/2))
-+    ikx_min = ikx_max+1
-+    # Index of kx=0
-+    ikx0 = (nakx-1)//2
-+    
-+    # Number of t-steps before ExB re-map
-+    if g_exb != 0.0:
-+        N_per_remap = max(1, abs(int(round(dkx/(g_exb*delt*dky)))))
-+    else:
-+        N_per_remap = np.nan
-+    # Floquet period
-+    if g_exb != 0.0:
-+        Tf = abs(2*pi*shat/g_exb)
-+    else:
-+        Tf = np.nan
-+    # Number of t-steps in Floquet period
-+    if g_exb != 0.0:
-+        Nf = int(round(Tf/delt))
-+    else:
-+        Nf = np.nan
-+
-+    # Read data from output
-+    phi2_gs2 = np.squeeze(myout['phi2_by_mode'][:,1,:])
-+    omega_gs2 = np.squeeze(myout['omega_average'][:,1,:,0]) # real frequency
-+    phi_t_present = myout['phi_t_present']
-+    if phi_t_present:
-+        phi2_bytheta_gs2 = np.sum(np.power(myout['phi_t'],2), axis=4)
-+        phi2_bytheta_gs2 = np.squeeze(phi2_bytheta_gs2[:,1,:,:])
-+    try:
-+        Qe = myout['es_heat_flux'][:,1]
-+        Qi = myout['es_heat_flux'][:,0]
-+        Qratio = Qe/Qi
-+        Qratio_avg = mytime.timeavg(Qratio)
-+    except:
-+        Qratio_avg = 'NaN'
-+   
-+    # Sorting kx indices to become monotonic
-+    kx_bar = np.concatenate((kx_gs2[ikx_min:],kx_gs2[:ikx_min]))
-+    phi2 = np.concatenate((phi2_gs2[:,ikx_min:], phi2_gs2[:,:ikx_min]), axis=1)
-+    omega = np.concatenate((omega_gs2[:,ikx_min:], omega_gs2[:,:ikx_min]), axis=1)
-+    if phi_t_present:
-+        phi2_bytheta = np.concatenate((phi2_bytheta_gs2[:,ikx_min:,:], phi2_bytheta_gs2[:,:ikx_min,:]), axis=1)
-+
-+    # Check if we want to process all -pi < theta0 < pi (ie if dmid_list=[])
-+    if not dmid_list:
-+        dmid_list = [0]
-+        ikx = 1
-+        while abs(ikx*dkx/(shat*ky)) <= pi:
-+            dmid_list.insert(0,-ikx)
-+            dmid_list.append(ikx)
-+            ikx += 1
-+
-+    # Check if the chain has at least one connection.
-+    # If not, we will follow the right-most (g_exb>0)
-+    # or left-most (g_exb<0) chain until it falls off the grid.
-+    if jtwist > nakx:
-+        if g_exb != 0:
-+            dmid_list = [int(np.sign(g_exb)*(nakx-1)/2)]
-+            nt = int((nakx-1) * np.floor(N_per_remap/nwrite))
-+            if nt == 0:
-+                print('\n============== WARNING ==============\n'+ \
-+                        'This chain has no connections, and is\n'+ \
-+                        '   dropped from the simulation at    \n'+ \
-+                        '         t < nwrite*delt             \n'+ \
-+                        '=====================================\n' )
-+
-+    # Get kx and kx_star from kx_bar
-+    kx = np.zeros((nt,nakx))
-+    kx_star = np.zeros((nt,nakx))
-+    # @ it = 0, kx = kx_bar
-+    kx[0,:] = kx_bar
-+    kx_star[0,:] = kx_bar
-+    # First step is taken with 0.5*dt
-+    # Other steps taken with full dt
-+    for it in range(1,nt):
-+        ikx_shift = int(round(g_exb*ky*delt*(nwrite*it-0.5)/dkx))
-+        for ikx in range(nakx):
-+            kx[it,ikx] = kx_bar[ikx] + ikx_shift*dkx
-+            kx_star[it,ikx] = kx[it,ikx] - g_exb*ky*delt*(nwrite*it-0.5)
-+
-+    # Construct theta0 grids
-+    itheta0_list = [dmid + ikx0 for dmid in dmid_list]
-+    theta0 = kx_bar/(shat*ky)
-+    theta0_star = np.zeros((nt,nakx))
-+    for it in range(1,nt):
-+        for ikx in range(nakx):
-+            theta0_star[it,ikx] = (kx_bar[ikx]-g_exb*ky*delt*(nwrite*it-0.5))/(shat*ky)
-+    
-+    # Lists containing all ballooning chains at every time step
-+    ikx_members = []
-+    ikx_prevmembers = []
-+    bloonang = []
-+    bloonang_bndry = []
-+    phi2bloon = []
-+    phi2bloon_discont = []
-+    phi2bloon_jump = []
-+    max_phi2bloon = []
-+    omegabloon = []
-+    gamma = []
-+    kx_star_for_gamma = []
-+
-+    for dmid in dmid_list:
-+
-+        # Lists containing all time steps for the current chain
-+        ikx_members_chain = []
-+        ikx_prevmembers_chain = []
-+        bloonang_chain = []
-+        bloonang_bndry_chain = []
-+        phi2bloon_chain = []
-+        phi2bloon_discont_chain = []
-+        phi2bloon_jump_chain = []
-+        max_phi2bloon_chain = []
-+        gamma_chain = []
-+        omegabloon_chain = []
-+
-+        for it in range(nt):
-+
-+            # Lists containing the current time step of the current chain
-+            phi2bloon_now = []
-+            phi2bloon_discont_now = []
-+            phi2bloon_jump_now = []
-+            omegabloon_now = []
-+
-+            # Determine (or, if gexb/=0, update) the 
-+            # collection of ikx's that are included
-+            # in the chain at time step it (ikx_members_now)
-+            # and at time step it-1 (ikx_prevmembers_now).
-+
-+            if it==0 or g_exb != 0.0:
-+
-+                # Lists containing the current time step of the current chain
-+                ikx_members_now = []
-+                ikx_prevmembers_now = []
-+                bloonang_now = []
-+                bloonang_bndry_now = []
-+
-+                if it==0:
-+                    ikx_shift = 0
-+                    ikx_shift_old = 0
-+                elif it==1:
-+                    ikx_shift = int(round(g_exb*ky*delt*(nwrite*it-0.5)/dkx))
-+                    ikx_shift_old = 0
-+                else:
-+                    ikx_shift = int(round(g_exb*ky*delt*(nwrite*it-0.5)/dkx))
-+                    ikx_shift_old = int(round(g_exb*ky*delt*(nwrite*(it-1)-0.5)/dkx))
-+
-+                # ikx such that our chain includes kxstar(t=0) = dmid*dkx
-+                ikx = ikx0 - ikx_shift + dmid
-+                ikxprev = ikx0 - ikx_shift_old + dmid
-+
-+                while (ikx >= nakx): # moving from the right to first connected kx within the set in GS2
-+                    ikx = ikx-jtwist
-+                    ikxprev = ikxprev-jtwist
-+                while (ikx >= 0):
-+                    ikx_members_now.append(ikx)
-+                    if ikxprev >= nakx:
-+                        ikx_prevmembers_now.append(np.nan)
-+                    elif ikxprev < 0:
-+                        ikx_prevmembers_now.append(np.nan)
-+                    else:
-+                        ikx_prevmembers_now.append(ikxprev)
-+                    ikx = ikx-jtwist
-+                    ikxprev = ikxprev-jtwist
-+
-+                ikx = ikx0 - ikx_shift + dmid + jtwist
-+                ikxprev = ikx0 - ikx_shift_old + dmid + jtwist
-+                while (ikx < 0): # moving from the left to first connected kx within the set in GS2
-+                    ikx = ikx+jtwist
-+                    ikxprev = ikxprev+jtwist
-+                while (ikx < nakx):
-+                    ikx_members_now.append(ikx)
-+                    if ikxprev >= nakx:
-+                        ikx_prevmembers_now.append(np.nan)
-+                    elif ikxprev < 0:
-+                        ikx_prevmembers_now.append(np.nan)
-+                    else:
-+                        ikx_prevmembers_now.append(ikxprev)
-+                    ikx = ikx+jtwist
-+                    ikxprev = ikxprev+jtwist
-+
-+                # sort ikx of chain members at time it in left-to-right order (shat>0: descending, shat<0: ascending)
-+                # sort time it-1 accordingly
-+                idx_sort = sorted(range(len(ikx_members_now)), key=lambda k: ikx_members_now[k],reverse=(shat>0.))
-+                ikx_members_now = [ikx_members_now[idx] for idx in idx_sort]
-+                ikx_prevmembers_now = [ikx_prevmembers_now[idx] for idx in idx_sort]
-+
-+                member_range = range(len(ikx_members_now))
-+                
-+                # compute ballooning angle
-+                for imember in member_range:
-+                    if imember < len(ikx_members_now)-1:
-+                        b_ang_bndry = pi-kx_star[it,ikx_members_now[imember]]/(shat*ky)
-+                        bloonang_bndry_now.append(b_ang_bndry)
-+                    for itheta in range(ntheta):
-+                        b_ang = theta[itheta] - kx_star[it,ikx_members_now[imember]]/(shat*ky)
-+                        bloonang_now.append(b_ang)
-+
-+            if phi_t_present:
-+                
-+                for imember in member_range:
-+                    
-+                    # construct chain of phi2
-+                    for itheta in range(ntheta):
-+                        phi2bloon_now.append(phi2_bytheta[it,ikx_members_now[imember],itheta])
-+                    
-+                    # construct chain of real frequency
-+                    omegabloon_now.append(omega[it,ikx_members_now[imember]])
-+
-+                    # Saving discontinuities
-+                    if imember < len(ikx_members_now)-1:
-+                        phi2_l = phi2_bytheta[it,ikx_members_now[imember],-1]
-+                        phi2_r = phi2_bytheta[it,ikx_members_now[imember+1],0]
-+                        discont = abs(phi2_r-phi2_l)
-+                        phi2bloon_discont_now.append(discont)
-+                        jump = abs((phi2_r-phi2_l)/max(phi2_l,phi2_r))
-+                        phi2bloon_jump_now.append(jump)
-+
-+            # Add this time step to the current chain
-+            ikx_members_chain.append(ikx_members_now)
-+            ikx_prevmembers_chain.append(ikx_prevmembers_now)
-+            bloonang_chain.append(bloonang_now)
-+            bloonang_bndry_chain.append(bloonang_bndry_now)
-+            phi2bloon_chain.append(phi2bloon_now)
-+            phi2bloon_discont_chain.append(phi2bloon_discont_now)
-+            phi2bloon_jump_chain.append(phi2bloon_jump_now)
-+            omegabloon_chain.append(omegabloon_now)
-+            max_phi2bloon_chain.append(max(phi2bloon_now))
-+
-+        # Add this chain to the full collection
-+        ikx_members.append(ikx_members_chain)
-+        ikx_prevmembers.append(ikx_prevmembers_chain)
-+        bloonang.append(bloonang_chain)
-+        bloonang_bndry.append(bloonang_bndry_chain)
-+        phi2bloon.append(phi2bloon_chain)
-+        phi2bloon_discont.append(phi2bloon_discont_chain)
-+        phi2bloon_jump.append(phi2bloon_jump_chain)
-+        max_phi2bloon.append(max_phi2bloon_chain)
-+        omegabloon.append(omegabloon_chain)
-+
-+    # Start comparing simulations at time-step it_start
-+    # With flow shear, it_start = N_start*Tfloquet/dt
-+    if g_exb != 0.0:
-+        N_start = 0
-+        it_start = int(round((N_start*Tf/delt)/nwrite))
-+    else:
-+        fac = 0.5
-+        it_start = round(fac*nt)
-+
-+    t_collec = []
-+    max_phi2_collec = []
-+    
-+    # Compute <gamma>_t
-+    gamma_avg = np.zeros(len(dmid_list))
-+    offset_avg = np.zeros(len(dmid_list))
-+    for idmid in range(len(dmid_list)):
-+        max_phi2_tmp = np.zeros(len(max_phi2bloon[idmid])-it_start)
-+        for it in range(max_phi2_tmp.size):
-+            max_phi2_tmp[it] = max_phi2bloon[idmid][it_start+it]
-+        if it_start > 0:
-+            max_phi2_tmp = max_phi2_tmp/max_phi2_tmp[0]
-+        max_phi2_collec.append(max_phi2_tmp)
-+        
-+        t_tmp = np.zeros(nt-it_start)
-+        for it in range(t_tmp.size):
-+            t_tmp[it] = t[it_start+it]
-+        t_collec.append(t_tmp)
-+
-+        [gam,offset] = leastsq_lin(t_tmp,np.log(max_phi2_tmp))
-+        gamma_avg[idmid] = gam/2. # divide by 2 because fitted square
-+        offset_avg[idmid] = offset
-+    # At this point:
-+    # fit_avg(t) ~ phi2(tstart) * exp[2*gam*t + offset]
-+
-+    # Compute gamma_max from ln(phi2_max)
-+    if g_exb != 0.0:
-+        it_gamma_max = np.zeros(len(dmid_list))
-+        gamma_max = np.zeros(len(dmid_list))
-+        for idmid in range(len(dmid_list)):
-+            # Start looking for derivatives one Floquet period before last time-step
-+            it_start_last_floq = max(int(len(max_phi2bloon[idmid]) - Tf//(delt*nwrite) - 1),0)
-+            it_end_last_floq = int(len(max_phi2bloon[idmid]) - 1)
-+            for it in range(it_start_last_floq, it_end_last_floq):
-+                # Factor of 0.5 because we fit phi^2
-+                gamma_max_tmp = 0.5 * 1./(2*delt*nwrite) * \
-+                        ( np.log(max_phi2bloon[idmid][it+1]) - np.log(max_phi2bloon[idmid][it-1]) )
-+                if (gamma_max_tmp > gamma_max[idmid]):
-+                    it_gamma_max[idmid] = it
-+                    gamma_max[idmid] = gamma_max_tmp
-+        it_gamma_max = it_gamma_max.astype(int)
-+        # At this point:
-+        # fit_max(t) ~ phi2(tstart) * exp[2*gamma_max*(t-t_gamma_max)]
-+    else:
-+        # If gexb = 0, max and avg growthrates are identical.
-+        gamma_max = gamma_avg
-+
-+    
-+    # Save quantities to file for scan plots
-+
-+    fname = run.out_dir + run.fnames[ifile] + '.linbox.dat'
-+
-+    with open(fname, 'wb') as outfile:
-+
-+        vardict = {}
-+
-+        vardict['ky'] = ky
-+        vardict['g_exb'] = g_exb
-+        vardict['Qratio_avg'] = Qratio_avg
-+        vardict['gamma_max'] = gamma_max
-+        vardict['gamma_avg'] = gamma_avg
-+        vardict['dmid_list'] = dmid_list
-+        vardict['itheta0_list'] = itheta0_list
-+        vardict['theta0'] = theta0
-+
-+        pickle.dump(vardict, outfile)
-+
-+
-+    
-+    # Plotting
-+
-+
-+    if make_plots:
-+
-+        # Plot max(phi2) in chain vs time, one dmid per plot
-+
-+        plt.figure(figsize=(12,8))
-+
-+        tmp_pdf_id = 1
-+        pdflist = []
-+        for idmid in range(len(dmid_list)):
-+            my_legend = []
-+            plt.semilogy(t[0:nt], max_phi2bloon[idmid], color=gplot.myblue, linewidth=3.0)
-+            plt.title('$k_y=$'+gplot.str_ky(ky) + ', $\\theta_0=$'+gplot.str_tt0(theta0[itheta0_list[idmid]]))
-+            my_legend.append('$\\max_{K_x}\\vert \\langle\\varphi\\rangle_\\theta \\vert ^2$')
-+            # Add fits for average and maximum growthrates
-+            plt.semilogy(t[0:nt], max_phi2bloon[idmid][it_start]*np.exp(2.0*gamma_avg[idmid]*t[0:nt]+offset_avg[idmid]),\
-+                    color=gplot.myblue, linewidth=3.0, linestyle='--')
-+            if g_exb != 0.0:
-+                my_legend.append('$\\langle\\gamma\\rangle_t = {:.3f}$'.format(gamma_avg[idmid]))
-+                bot, top = plt.ylim()
-+                plt.semilogy(t[0:nt], max_phi2bloon[idmid][it_gamma_max[idmid]]*np.exp(2.0*gamma_max[idmid]*(t[0:nt]-t[it_gamma_max[idmid]])),\
-+                        color=gplot.myblue, linewidth=3.0, linestyle=':')
-+                my_legend.append('$\\gamma_{max} '+'= {:.3f}$'.format(gamma_max[idmid]))
-+                plt.ylim(bot,top)
-+            else:
-+                my_legend.append('$\\gamma = {:.3f}$'.format(gamma_avg[idmid]))
-+            plt.xlabel('$t$')
-+            plt.grid(True)
-+            gplot.legend_matlab(my_legend)
-+            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-+            gplot.save_plot(tmp_pdfname, run, ifile)
-+            pdflist.append(tmp_pdfname)
-+            tmp_pdf_id = tmp_pdf_id+1
-+
-+        merged_pdfname = 'maxphi_vs_t'
-+        gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-+        plt.clf()
-+        plt.cla()
-+
-+
-+
-+        # plot phi2 vs t for each kx
-+
-+        plt.figure(figsize=(12,8))
-+        plt.title('$k_y={:.2f}$'.format(ky))
-+        plt.xlabel('$t\\ [r_r/v_{thr}]$')
-+        my_ylabel = '$\\ln \\left(\\vert \\langle \\varphi \\rangle_\\theta \\vert ^2\\right)$'
-+        plt.ylabel(my_ylabel)
-+        plt.grid(True)
-+        my_colorlist = plt.cm.plasma(np.linspace(0,1,kx_bar.size))
-+        my_legend = []
-+        kxs_to_plot=kx_bar
-+        for ikx in range(kx_bar.size):
-+            if kx_bar[ikx] in kxs_to_plot:
-+                plt.plot(t[0:nt], np.log(phi2[0:nt,ikx]), color=my_colorlist[ikx])
-+        axes=plt.gca()
-+
-+        pdfname = 'phi2_vs_t_by_kx'
-+        pdfname = run.out_dir + pdfname + '_' + run.fnames[ifile] + '.pdf'
-+        plt.savefig(pdfname)
-+        
-+        plt.clf()
-+        plt.cla()
-+
-+
-+
-+        # Plot phi2 vs (theta-theta0), one dmid per plot, one series of plots per selected time
-+
-+        plt.figure(figsize=(12,8))
-+        it_toPlot = [int(r*(nt-1)) for r in tRatio_toPlot]
-+
-+        for it in it_toPlot:
-+
-+            tmp_pdf_id = 1
-+            pdflist = []
-+            for idmid in range(len(dmid_list)):
-+                if g_exb == 0.0:
-+                    plt.title('$t=$' + gplot.str_t(t[it]) + ', $k_y=$' + gplot.str_ky(ky) + ', $\\theta_0 =$' + gplot.str_tt0(theta0[itheta0_list[idmid]]))
-+                else:
-+                    plt.title('$t=$' + gplot.str_t(t[it]) + ', $k_y=$' + gplot.str_ky(ky) + ', $\\theta_0^* =$' + gplot.str_tt0(theta0_star[it,itheta0_list[idmid]]))
-+                lphi, = plt.plot(bloonang[idmid][it],phi2bloon[idmid][it], marker='o', color=gplot.myblue, \
-+                        markersize=5, markerfacecolor=gplot.myblue, markeredgecolor=gplot.myblue, linewidth=3.0)
-+                lphi.set_label('$\\vert \\varphi \\vert ^2$')
-+                lbdry, = plt.plot(bloonang_bndry[idmid][it],phi2bloon_discont[idmid][it], linestyle='', \
-+                        marker='d', markersize=15, markerfacecolor='r', markeredgecolor='r')
-+                lbdry.set_label('_skip')
-+                if g_exb == 0.0:
-+                    plt.xlabel('$\\theta-\\theta_0$')
-+                else:
-+                    plt.xlabel('$\\theta-\\theta_0^*$')
-+                plt.grid(True)
-+                gplot.legend_matlab()
-+                ax = plt.gca()
-+                ax.yaxis.set_major_formatter(FormatStrFormatter('%.2E'))
-+                tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-+                gplot.save_plot(tmp_pdfname, run, ifile)
-+                pdflist.append(tmp_pdfname)
-+                tmp_pdf_id = tmp_pdf_id+1
-+
-+            merged_pdfname = 'phi_vs_theta_it_' + str(it)
-+            gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-+            plt.clf()
-+            plt.cla()
-+
-+
-+
-+
-+   # Snapshots and movies
-+
-+    for idmid in range(len(dmid_list)):
-+    
-+        dmid = dmid_list[idmid]
-+
-+        if (phi_t_present):
-+
-+            # Snapshots of phi
-+
-+            if (make_snaps):
-+
-+                if itSnap_max == -1:
-+                    itSnap_max = nt
-+
-+                # find global min and max of ballooning angle
-+                bloonang_min = 0.
-+                bloonang_max = 0.
-+                for it in range(max_it_for_snap):
-+                    if np.min(bloonang[idmid][it]) < bloonang_min:
-+                        bloonang_min = np.min(bloonang[idmid][it])
-+                    if np.max(bloonang[idmid][it]) > bloonang_max:
-+                        bloonang_max = np.max(bloonang[idmid][it])
-+
-+
-+                # Snapshots of phi
-+
-+                plt.figure(figsize=(12,8))
-+
-+                tmp_pdf_id = 1
-+                pdflist = []
-+                for it in range(0,max_it_for_snap,it_step_for_snap):
-+                    l1, = plt.plot(bloonang[idmid][it],phi2bloon[idmid][it], marker='o', color=gplot.myblue, \
-+                            markersize=5, markerfacecolor=gplot.myblue, markeredgecolor=gplot.myblue, linewidth=3.0)
-+                    l1.set_label('$\\vert \\varphi \\vert ^2$')
-+                    l2, = plt.plot(bloonang_bndry[idmid][it],phi2bloon_discont[idmid][it], linestyle='', \
-+                            marker='d', markersize=15, markerfacecolor='r', markeredgecolor='r')
-+                    l2.set_label('_skip')
-+                    plt.xlabel('$\\theta$')
-+                    plt.grid(True)
-+                    plt.gca().set_xlim(bloonang_min,bloonang_max)
-+                    plt.gca().yaxis.set_major_formatter(FormatStrFormatter('%.1E'))
-+                    ymin = np.amin(phi2bloon[idmid][it])
-+                    ymax = np.amax(phi2bloon[idmid][it])
-+                    ax = plt.gca()
-+                    ax.set_ylim(ymin,ymax)
-+                    ax.set_title('$\\theta_0={:.2f},\ $'.format(theta0[itheta0_list[idmid]]) + '$k_y={:.2f},\ t={:.2f}$'.format(ky,t[it]))
-+                    ax.legend()
-+                    tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-+                    gplot.save_plot(tmp_pdfname, run, ifile)
-+                    pdflist.append(tmp_pdfname)
-+                    tmp_pdf_id = tmp_pdf_id+1
-+
-+                merged_pdfname = 'snaps_phibloon_dmid_' + str(dmid)
-+                gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-+                plt.clf()
-+                plt.cla()
-+
-+
-+            # Movie of phi
-+
-+            if (make_movies):
-+
-+                if itMov_max == -1:
-+                    itMov_max = nt
-+    
-+                myfig = plt.figure(figsize=(12,8))
-+
-+                # find global min and max of ballooning angle
-+                bloonang_min = 0.
-+                bloonang_max = 0.
-+                for it in range(itMov_min, itMov_max):
-+                    if np.min(bloonang[idmid][it]) < bloonang_min:
-+                        bAng_min = np.min(bloonang[idmid][it])
-+                    if np.max(bloonang[idmid][it]) > bloonang_max:
-+                        bAng_max = np.max(bloonang[idmid][it])
-+                
-+                # find phimax for each time step
-+                phi2_max = np.zeros(nt)
-+                for it in range(nt):
-+                    phi2_max[it] = np.max(phi2bloon[idmid][it])
-+                
-+                # movie name
-+                moviename = 'mov_phi_vs_theta' + '_dmid_' + str(dmid)
-+                moviename = run.out_dir + moviename + '_' + run.fnames[ifile] + '.mp4'
-+               
-+                print("\ncreating movie of phi vs ballooning angle ...")
-+
-+                # intialise artists
-+                xdata1, ydata1 = [], []
-+                lphi, = plt.plot([],[], marker='o', color=gplot.myblue, \
-+                        markersize=5, markerfacecolor=gplot.myblue, markeredgecolor=gplot.myblue, linewidth=3.0)
-+                lphi.set_label('$\\vert \\varphi \\vert ^2/\\max_{K_x}\\vert\\varphi\\vert^2$')
-+                xdata2, ydata2 = [], []
-+                lbdry, = plt.plot([],[], linestyle='', \
-+                        marker='d', markersize=15, markerfacecolor='r', markeredgecolor='r')
-+                lbdry.set_label('_skip')
-+
-+                # Labels, limits, legend
-+                if g_exb == 0.0:
-+                    plt.xlabel('$\\theta-\\theta_0$')
-+                else:
-+                    plt.xlabel('$\\theta-\\theta_0^*$')
-+                plt.grid(True)
-+                plt.gca().set_xlim(bAng_min,bAng_max)
-+                ax = plt.gca()
-+                plt.gca().set_ylim(0.0,1.0)
-+                gplot.legend_matlab()
-+
-+                # Update lines
-+                def update_plot(data):
-+
-+                    # Unpack data from yield_data
-+                    t, bAng, phi2bAng, bAng_bndry, phi2bAng_discont = data
-+                    # Update phi2 chain
-+                    lphi.set_data(bAng,phi2bAng)
-+                    # Update discontinuities at 2pi interfaces
-+                    lbdry.set_data(bAng_bndry,phi2bAng_discont)
-+                    # Update title
-+                    if g_exb == 0.0:
-+                        plt.gca().set_title('$t=$' + gplot.str_t(t) + ', $k_y=$' + gplot.str_ky(ky) + ', $\\theta_0 =$' + gplot.str_tt0(theta0[itheta0_list[idmid]]))
-+                    else:
-+                        plt.gca().set_title('$t=$' + gplot.str_t(t) + ', $k_y=$' + gplot.str_ky(ky) + ', $\\theta_0^* =$' + gplot.str_tt0(theta0_star[it,itheta0_list[idmid]]))
-+
-+                    return lphi, lbdry
-+
-+                # "yield" = "return, and next time function is called, start from there"
-+                def yield_data():
-+
-+                    for it in range(itMov_min, itMov_max, itMov_step):
-+
-+                        sys.stdout.write("\r{0}".format("\tFrame : "+str(it)+"/"+str(nt-1))) # comment out on HPC
-+                        yield t[it], bloonang[idmid][it], phi2bloon[idmid][it]/phi2_max[it], bloonang_bndry[idmid][it], phi2bloon_discont[idmid][it]
-+
-+                mov = anim.FuncAnimation(myfig, update_plot, frames=yield_data, blit=False, save_count=len(range(itMov_min, itMov_max, itMov_step)))
-+                writer = anim.writers['ffmpeg'](fps=15,bitrate=1800)
-+                mov.save(moviename,writer=writer,dpi=100)
-+                plt.clf()
-+                plt.cla()
-+
-+                print("\n... movie completed.")
-+                print('\n')
-+
-+
-+            # Movie of discontinuities in phi
-+
-+            if make_movie_discont:
-+
-+                if itMov_max == -1:
-+                    itMov_max = nt
-+
-+                ## movie of phi2 jump at interfaces between 2pi domains
-+                moviename = 'phijump' + '_dmid_' + str(dmid)
-+                moviename = run.out_dir + moviename + '_' + run.fnames[ifile] + '.mp4'
-+
-+                print("\ncreating movie of phijump vs ballooning angle ...")
-+                xdata1, ydata1 = [], []
-+                l1, = plt.plot([],[], marker='o', color=gplot.myred, \
-+                        markersize=12, markerfacecolor=gplot.myred, markeredgecolor=gplot.myred, linewidth=3.0)
-+                plt.xlabel('$\\theta$') # NDCPARAM: check for plot_against_theta0_star
-+                plt.ylabel('$\\Delta\\vert \\varphi \\vert ^2/\\vert \\varphi \\vert ^2$')
-+                plt.grid(True)
-+                plt.gca().set_xlim(bloonang_min,bloonang_max)
-+                plt.gca().set_ylim(0,1)
-+                # Initialize lines
-+                def init_mov_jump():
-+                    l1.set_data([], [])
-+                    return l1
-+                # Update lines
-+                def update_mov_jump(it):
-+                    #sys.stdout.write("\r{0}".format("\tFrame : "+str(it)+"/"+str(nt-1))) # comment out for HPC
-+                    # Update discontinuities at 2pi interfaces
-+                    xdata1 = bloonang_bndry[idmid][it]
-+                    ydata1 = phi2bloon_jump[idmid][it]
-+                    plt.gca().set_title('$\\theta_0 = {:.2f},$'.format(theta0[itheta0_list[idmid]])+'$k_y={:.2f}, t={:.2f}$'.format(ky,t[it]))
-+                    l1.set_data(xdata1,ydata1)
-+                    return l1
-+
-+                mov = anim.FuncAnimation(myfig,update_mov_jump,init_func=init_mov_jump, \
-+                        frames=range(0,max_it_for_mov,it_step_for_mov),blit=False)
-+                writer = anim.writers['ffmpeg'](fps=10,bitrate=-1,codec='libx264')
-+                mov.save(moviename,writer=writer,dpi=100)
-+                plt.clf()
-+                plt.cla()
-+
-+                print("\n... movie completed.")
-+
-+    plt.close()
-+
-+
-+def leastsq_lin(x, y):
-+    
-+    # y_fit = a*x + b
-+    # minimising sum((y - f_fit)^2)
-+    N_x = x.size
-+
-+    a = 1./(N_x*np.sum(np.power(x,2)) - np.sum(x)**2) * (N_x*np.sum(np.multiply(x,y)) - np.sum(x)*np.sum(y))
-+    
-+    b = 1./(N_x*np.sum(np.power(x,2)) - np.sum(x)**2) * (-1.*np.sum(x)*np.sum(np.multiply(x,y)) + np.sum(np.power(x,2))*np.sum(y))
-+
-+    return [a, b]
-+
-+def get_growthrate(t,tofit,it_start):
-+   
-+    popt, pcov = opt.curve_fit(lin_func, t[it_start:], np.log(tofit[it_start:]))
-+    return popt[0]
-+
-+def lin_func(x,a,b):
-+    return a*x+b
-+
-diff --git a/tasks/lingrowth.py b/tasks/lingrowth.py
-index ce29615..e4c9276 100644
---- a/tasks/lingrowth.py
-+++ b/tasks/lingrowth.py
-@@ -3,78 +3,146 @@ import scipy.optimize as opt
- from matplotlib import pyplot as plt
- import gs2_plotting as gplot
- import pickle
-+import math
- 
- def my_task_single(ifile, run, myin, myout):
- 
-     # User parameters
-     dump_at_start = 0.3 # fraction of initial time to dump when fitting
-     ikx_list = [-1] # choose which kx to plot, negative means plot all
-+    skip_first_ky = False
-+    kymax = 1.5 # max of gamma is taken over range [0, kymax]
-+    fix_ylim = False
-+    yl = [0.00, 0.10]
-+    g_exb = 0.0
-+    user_zlim = True
-+    zlim = [-0.02,0.08]
-+
-+    iky_first = 0
-+    if skip_first_ky:
-+        iky_first = 1
- 
-     # Compute and save growthrate
-     if not run.only_plot:
-         
--        grid_option = myin['kt_grids_knobs']['grid_option']
--
-         t = myout['t']
-         nt = t.size
-         it_start = round(nt*dump_at_start)
--        kx = myout['kx']
-+        try:
-+            radial_var = myin['kt_grids_range_parameters']['radial_lim_option']
-+            if radial_var=='default':
-+                radial_var = 'theta0_lim'
-+        except:
-+            radial_var = 'theta0_lim'
-+        if radial_var=='kx_lim':
-+            kx = myout['kx']
-+        else:
-+            kx = myout['theta0'][0]
-         nakx = kx.size
-         ky = myout['ky']
-         naky = ky.size
-         phi2 = myout['phi2_by_mode'] # modulus squared, avged over theta (indices: [t,ky,kx])
-+        shat = myin['theta_grid_parameters']['shat']
- 
--        if grid_option=='range':
--            # In range, plot the only kx
--            ikx_list = [0]
--        elif grid_option=='box':
--            if ikx_list[0]==-1:
--                ikx_list = [i in range(nakx)]
-+        # Store index of first NaN or +/- inf in it_stop
-+        it = 0
-+        it_stop = nt
-+        no_nan_inf = True
-+        while it < nt and no_nan_inf:
-+            for ikx in range(nakx):
-+                for iky in range(1,naky):
-+                    if not is_number(phi2[it,iky,ikx]):
-+                        no_nan_inf = False
-+                        it_stop = it
-+            it = it + 1
-+
-+        if ikx_list[0]==-1:
-+            ikx_list = [i for i in range(nakx)]
- 
-         # Fit phi to get growthrates
-         gamma = np.zeros([naky,len(ikx_list)])
-         gamma[0,:]=float('nan') # skip zonal mode
--        for iky in range(1,naky):
-+        for iky in range(iky_first,naky):
-             for ikx in ikx_list:
--                gamma[iky,ikx] = 0.5*get_growthrate(t,phi2,it_start,ikx,iky)
-+                if ky[iky] == 0.0 and kx[ikx] == 0.0:
-+                    gamma[iky,ikx] = 0.0
-+                else:
-+                    gamma[iky,ikx] = 0.5*get_growthrate(t,phi2,it_start,it_stop,ikx,iky)
- 
-         # Read real frequency
-         omega = np.zeros([naky,len(ikx_list)])
-         omega[0,:] = float('nan') # skip zonal mode
--        for iky in range(1,naky):
-+        for iky in range(iky_first,naky):
-             for ikx in ikx_list:
-                 omega[iky,ikx] = myout['omega_average'][-1,iky,ikx,0] # last index is for real part
-         
-         # Save to .dat file
-         datfile_name = run.out_dir + run.fnames[ifile] + '.lingrowth.dat'
-         with open(datfile_name, 'wb') as datfile:
--            pickle.dump([ikx_list,kx,ky,gamma,omega],datfile)
-+            pickle.dump([ikx_list,kx,ky,gamma,omega,radial_var],datfile)
-    
-     # or read from .dat file
-     else:
-         
-         datfile_name = run.out_dir + run.fnames[ifile] + '.lingrowth.dat'
-         with open(datfile_name, 'rb') as datfile:
--            [ikx_list,kx,ky,gamma,omega] = pickle.load(datfile)
-+            [ikx_list,kx,ky,gamma,omega,radial_var] = pickle.load(datfile)
- 
-     # Plotting
-     if not run.no_plot:
--    
-+
-         # Plot growthrate
-         plt.figure(figsize=(12,8))
-+        my_legend = []
-+        plt.grid(True)
-         plt.xlabel('$k_y\\rho_i$')
-         plt.ylabel('$\\gamma \\ [v_{thr}/r_r]$')
--        plt.title('Linear growthrate')
--        plt.grid(True)
--
--        my_legend = []
-+        # Find maximum gamma, within range [0, kymax]
-+        ikymax = 0
-+        gamma_max = -1000
-         for ikx in ikx_list:
-+            iky = 0
-+            while iky < naky and ky[iky] <= 1.5:
-+                if not math.isnan(gamma[iky,ikx]) and gamma_max < gamma[iky,ikx]:
-+                    gamma_max = gamma[iky,ikx]
-+                    ikymax = iky
-+                iky = iky + 1
-             plt.plot(ky,gamma[:,ikx])
--            my_legend.append('$\\rho_i k_x='+str(kx[ikx])+'$')
-+            if radial_var == 'kx_lim':
-+                my_legend.append('$\\rho_i k_x='+str(kx[ikx])+'$')
-+            else:
-+                my_legend.append('$\\theta_0='+str(kx[ikx])+'$')
-         plt.legend(my_legend)
-+        my_title = '$\\max(\\gamma)=' + str(round(gamma_max,3)) + '$'
-+        my_title = my_title + ' at $k_y = ' + str(round(ky[ikymax],2)) + '$'
-+        plt.title(my_title)
-+        if fix_ylim:
-+            plt.ylim(yl)
-         pdfname = 'lingrowth'
-         gplot.save_plot(pdfname, run, ifile)
--        print('Maximum linear growthrate: '+str(np.nanmax(gamma)))
-+        print('Maximum linear growthrate: '+str(gamma_max))
-+    
-+        # Plot Floquet vs growthrate
-+        if g_exb != 0.0:
-+
-+            Tf = 2*math.pi*shat/g_exb
-+
-+            plt.figure(figsize=(12,8))
-+            my_legend = []
-+            plt.grid(True)
-+            plt.xlabel('$k_y\\rho_i$')
-+            plt.ylabel('$T_f\\gamma$')
-+            for ikx in ikx_list:
-+                plt.plot(ky,Tf*gamma[:,ikx])
-+                if radial_var == 'kx_lim':
-+                    my_legend.append('$\\rho_i k_x='+str(kx[ikx])+'$')
-+                else:
-+                    my_legend.append('$\\theta_0='+str(kx[ikx])+'$')
-+            plt.legend(my_legend)
-+            my_title = '$T_F=' + str(round(Tf,3)) + '\ [r_r/v_{thr}]$'
-+            plt.title(my_title)
-+            pdfname = 'floq_vs_growth'
-+            gplot.save_plot(pdfname, run, ifile)
-     
-         # Plot real frequency
-         plt.figure(figsize=(12,8))
-@@ -86,7 +154,10 @@ def my_task_single(ifile, run, myin, myout):
-         my_legend = []
-         for ikx in ikx_list:
-             plt.plot(ky,omega[:,ikx])
--            my_legend.append('$\\rho_i k_x='+str(kx[ikx])+'$')
-+            if radial_var == 'kx_lim':
-+                my_legend.append('$\\rho_i k_x='+str(kx[ikx])+'$')
-+            else:
-+                my_legend.append('$\\theta_0='+str(kx[ikx])+'$')
-         plt.legend(my_legend)
-         pdfname = 'realfreq'
-         gplot.save_plot(pdfname, run, ifile)
-@@ -103,16 +174,52 @@ def my_task_single(ifile, run, myin, myout):
-         my_colors = [cmap(i) for i in np.linspace(0,1,naky*len(ikx_list))]
-         for iky in range(naky):
-             for ikx in ikx_list:
--                plt.semilogy(t,phi2[:,iky,ikx],color=my_colors[ikx*naky+iky])
--                my_legend.append('$(k_x,k_y)=({:.1f},{:.1f})$'.format(kx[ikx],ky[iky]))
-+                plt.semilogy(t[0:it_stop],phi2[0:it_stop,iky,ikx],color=my_colors[ikx*naky+iky])
-+                if radial_var == 'kx_lim':
-+                    my_legend.append('$(k_x,k_y)=({:.1f},{:.1f})$'.format(kx[ikx],ky[iky]))
-+                else:
-+                    my_legend.append('$(\\theta_0,k_y)=({:.1f},{:.1f})$'.format(kx[ikx],ky[iky]))
-         plt.legend(my_legend, ncol=1, prop={'size': 10},loc='upper left')
-+        plt.ylim([np.amin(phi2[0:it_stop,:,:]), np.amax(phi2[0:it_stop,:,:])])
-         pdfname = 'linpotential'
-         gplot.save_plot(pdfname, run, ifile)
- 
--def get_growthrate(t,phi2,it_start,ikx,iky):
-+        # Contour plot vs ky & kx
-+        if len(ikx_list)>1:
-+            if radial_var == 'kx_lim':
-+                xl = '$\\rho k_x$'
-+            else:
-+                xl = '$\\theta_0$'
-+            yl = '$\\rho k_y$'
-+            g = gamma
-+            if not user_zlim:
-+                gmax = np.amax(g)
-+                gmin = np.amin(g)
-+            else:
-+                gmin, gmax = zlim
-+            gplot.plot_2d(g,kx,ky,gmin,gmax,xlab=xl,ylab=yl,cmp='RdBu_r',title='$\\gamma\\ [v_{th}/r_r]$')
-+            if radial_var == 'kx_lim':
-+                pdfname = 'gamma_vs_kx_ky'
-+            else:
-+                pdfname = 'gamma_vs_theta0_ky'
-+            gplot.save_plot(pdfname, run, ifile)
-+
-+def get_growthrate(t,phi2,it_start,it_stop,ikx,iky):
-    
--    popt, pcov = opt.curve_fit(lin_func, t[it_start:], np.log(phi2[it_start:,iky,ikx]))
-+    popt, pcov = opt.curve_fit(lin_func, t[it_start:it_stop], np.log(phi2[it_start:it_stop,iky,ikx]))
-     return popt[0]
- 
- def lin_func(x,a,b):
-     return a*x+b
-+
-+def is_number(x):
-+    try:
-+        x_str = str(float(x))
-+        if x_str=='nan' or x_str=='inf' or x_str=='-inf':
-+            return False
-+    except ValueError:
-+        try:
-+            complex(x_str)
-+        except ValueError:
-+            return False
-+    return True
-diff --git a/tasks/linrange.py b/tasks/linrange.py
-new file mode 100644
-index 0000000..2448ac0
---- /dev/null
-+++ b/tasks/linrange.py
-@@ -0,0 +1,418 @@
-+import numpy as np
-+import scipy.optimize as opt
-+from matplotlib import pyplot as plt
-+from matplotlib.ticker import FormatStrFormatter
-+import gs2_plotting as gplot
-+import matplotlib.colors as mcolors
-+import pickle
-+import math
-+
-+def my_task_single(ifile, run, myin, myout, mytime):
-+
-+
-+
-+
-+
-+    # vvv User parameters vvv
-+
-+    # Fraction of time to be discarded when fitting
-+    tRatio_init_dump = 0.8
-+    tRatio_end_dump = 0.0
-+
-+    # Limit y-axis in growthrate plots ?
-+    fix_ylim = False
-+    ylim = (0.00, 0.11)
-+
-+    # Limit colorbar on gamma vs (theta0,ky) plot ?
-+    fix_cbarlim = False
-+    cbarmin = -0.05
-+    cbarmax = 0.4
-+
-+    # Specify flow shear rate to compare Tfloq vs gamma
-+    g_exb = 0.0
-+
-+    # ^^^ User parameters ^^^
-+
-+
-+
-+
-+
-+
-+    # Process data
-+
-+
-+    t = myout['t']
-+    nt = t.size
-+    it_start = int(nt*tRatio_init_dump)
-+    tt0 = myout['theta0'][0]
-+    ntt0 = tt0.size
-+    ky = myout['ky']
-+    naky = ky.size
-+    theta = myout['theta']
-+    # modulus squared, avged over theta (indices: [t,ky,tt0])
-+    phi2 = myout['phi2_by_mode']
-+    # with theta dependence: phi2_bytheta[t,ky,tt0,theta]
-+    phi_t_present = myout['phi_t_present']
-+    if phi_t_present:
-+        phi2_bytheta = np.sum(np.power(myout['phi_t'],2), axis=4)
-+    else:
-+        print('\nCannot plot phi vs theta: write_phi_over_time was probably set to false.\n')
-+    shat = myin['theta_grid_parameters']['shat']
-+    # modulus squared of non-adiabatic part of the density at last time step [spec,ky,kx,theta]
-+    if myout['density_present']:
-+        dens2 =  np.sum(np.power(myout['density'],2), axis=4)
-+    else:
-+        print("\nCannot plot dens vs theta, 'density' was not found in output.\n")
-+
-+    # Store index of first NaN or +/- inf in it_stop
-+    it = 0
-+    it_stop = int(nt*(1-tRatio_end_dump))
-+    no_nan_inf = True
-+    while it < nt and no_nan_inf:
-+        for itt0 in range(ntt0):
-+            for iky in range(1,naky):
-+                if not is_number(phi2[it,iky,itt0]):
-+                    no_nan_inf = False
-+                    it_stop = it
-+        it = it + 1
-+
-+    # Fit phi^2 to get growthrates
-+    gamma = np.zeros([naky,ntt0])
-+    for iky in range(naky):
-+        for itt0 in range(ntt0):
-+            if ky[iky] == 0.0:
-+                # Skip zonal modes
-+                gamma[iky,itt0] = float('nan')
-+            else:
-+                # Factor of 0.5 because we fit phi^2
-+                gamma[iky,itt0] = 0.5*get_growthrate(t,phi2,it_start,it_stop,itt0,iky)
-+
-+    # Read real frequency
-+    omega = np.zeros([naky,ntt0])
-+    for iky in range(naky):
-+        for itt0 in range(ntt0):
-+            # First idx = last time step, last idx = real part
-+            omega[iky,itt0] = myout['omega_average'][-1,iky,itt0,0]
-+
-+    # Compute <Qe/Qi>_t
-+    try:
-+        Qe = myout['es_heat_flux'][:,1]
-+        Qi = myout['es_heat_flux'][:,0]
-+        Qratio = Qe/Qi
-+        Qratio_avg = mytime.timeavg(Qratio)
-+    except:
-+        Qratio_avg = float('nan')
-+    
-+    # Save to .dat file
-+    datfile_name = run.out_dir + run.fnames[ifile] + '.linrange.dat'
-+    with open(datfile_name, 'wb') as datfile:
-+        pickle.dump([tt0,ky,gamma,omega,Qratio_avg],datfile)
-+
-+
-+
-+
-+
-+
-+
-+    # Plotting
-+
-+
-+    # Plot growthrate vs ky, one plot per theta0
-+
-+    if naky > 1:
-+
-+        plt.figure(figsize=(12,8))
-+
-+        tmp_pdf_id = 1
-+        pdflist = []
-+        for itt0 in range(ntt0):
-+            l, = plt.plot(ky,gamma[:,itt0], color=gplot.myblue, linewidth=3.0)
-+            l.set_label('$\\theta_0=$'+gplot.str_tt0(tt0[itt0]))
-+            gplot.legend_matlab()
-+            if fix_ylim:
-+                plt.ylim(ylim)
-+            plt.grid(True)
-+            plt.xlabel('$k_y\\rho_i$')
-+            plt.ylabel('$\\gamma \\ [v_{th}/a]$')
-+            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-+            gplot.save_plot(tmp_pdfname, run, ifile)
-+            pdflist.append(tmp_pdfname)
-+            tmp_pdf_id = tmp_pdf_id+1
-+
-+        merged_pdfname = 'gamma_vs_ky'
-+        gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-+        plt.clf()
-+        plt.cla()
-+
-+
-+    # Plot growthrate vs theta0, one plot per ky
-+
-+    if ntt0 > 1:
-+
-+        plt.figure(figsize=(12,8))
-+
-+        tmp_pdf_id = 1
-+        pdflist = []
-+        for iky in range(naky):
-+            l, = plt.plot(tt0,gamma[iky,:], color=gplot.myblue, linewidth=3.0)
-+            l.set_label('$k_y=$'+gplot.str_ky(ky[iky]))
-+            gplot.legend_matlab()
-+            if fix_ylim:
-+                plt.ylim(ylim)
-+            plt.grid(True)
-+            plt.xlabel('$\\theta_0$')
-+            plt.ylabel('$\\gamma \\ [v_{th}/a]$')
-+            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-+            gplot.save_plot(tmp_pdfname, run, ifile)
-+            pdflist.append(tmp_pdfname)
-+            tmp_pdf_id = tmp_pdf_id+1
-+
-+        merged_pdfname = 'gamma_vs_theta0'
-+        gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-+        plt.clf()
-+        plt.cla()
-+
-+
-+    # Contour gamma vs (theta0, ky)
-+
-+    if naky > 1 and ntt0 > 1:
-+
-+        xl = '$\\theta_0$'
-+        yl = '$\\rho k_y$'
-+        g = gamma
-+        if not fix_cbarlim:
-+            gmax = np.amax(g)
-+            gmin = np.amin(g)
-+        else:
-+            gmin, gmax = [cbarmin, cbarmax]
-+        gplot.plot_2d(g,tt0,ky,gmin,gmax,xlab=xl,ylab=yl,cmp='RdBu_c',title='$\\gamma\\ [v_{th}/a]$')
-+        pdfname = 'gamma_vs_theta0_ky'
-+        gplot.save_plot(pdfname, run, ifile)
-+    
-+
-+    # Plot real frequency vs ky, one plot per theta0
-+
-+    if naky > 1:
-+
-+        plt.figure(figsize=(12,8))
-+
-+        tmp_pdf_id = 1
-+        pdflist = []
-+        for itt0 in range(ntt0):
-+            l, = plt.plot(ky,omega[:,itt0], color=gplot.myblue, linewidth=3.0)
-+            l.set_label('$\\theta_0=$'+gplot.str_tt0(tt0[itt0]))
-+            gplot.legend_matlab()
-+            plt.grid(True)
-+            plt.xlabel('$k_y\\rho_i$')
-+            plt.ylabel('$\\omega \\ [v_{th}/a]$')
-+            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-+            gplot.save_plot(tmp_pdfname, run, ifile)
-+            pdflist.append(tmp_pdfname)
-+            tmp_pdf_id = tmp_pdf_id+1
-+
-+        merged_pdfname = 'omega_vs_ky'
-+        gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-+        plt.clf()
-+        plt.cla()
-+
-+
-+    # Plot real frequency vs theta0, one plot per ky
-+
-+    if ntt0 > 1:
-+
-+        plt.figure(figsize=(12,8))
-+
-+        tmp_pdf_id = 1
-+        pdflist = []
-+        for iky in range(naky):
-+            l, = plt.plot(tt0,omega[iky,:], color=gplot.myblue, linewidth=3.0)
-+            l.set_label('$k_y=$'+gplot.str_ky(ky[iky]))
-+            gplot.legend_matlab()
-+            plt.grid(True)
-+            plt.xlabel('$\\theta_0$')
-+            plt.ylabel('$\\omega \\ [v_{th}/a]$')
-+            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-+            gplot.save_plot(tmp_pdfname, run, ifile)
-+            pdflist.append(tmp_pdfname)
-+            tmp_pdf_id = tmp_pdf_id+1
-+
-+        merged_pdfname = 'omega_vs_theta0'
-+        gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-+        plt.clf()
-+        plt.cla()
-+
-+
-+    # Contour real frequency vs (theta0, ky)
-+
-+    if naky > 1 and ntt0 > 1:
-+
-+        xl = '$\\theta_0$'
-+        yl = '$\\rho k_y$'
-+        z = omega
-+        zmax = np.amax(z)
-+        zmin = np.amin(z)
-+        gplot.plot_2d(z,tt0,ky,zmin,zmax,xlab=xl,ylab=yl,cmp='RdBu_c',title='$\\omega\\ [v_{th}/a]$')
-+        pdfname = 'omega_vs_theta0_ky'
-+        gplot.save_plot(pdfname, run, ifile)
-+
-+
-+    # Plot potential vs t for each ky, one plot per theta0
-+
-+    plt.figure(figsize=(12,8))
-+
-+    tmp_pdf_id = 1
-+    pdflist = []
-+    if naky > 1:
-+        cmap = plt.get_cmap('nipy_spectral')
-+        my_colors = [cmap(i) for i in np.linspace(0,1,naky)]
-+    else:
-+        my_colors = [gplot.myblue]
-+    for itt0 in range(ntt0):
-+        lgd = []
-+        for iky in range(naky):
-+            plt.semilogy(t[0:it_stop],phi2[0:it_stop,iky,itt0],color=my_colors[iky])
-+            lgd.append('$k_y=$'+gplot.str_ky(ky[iky]))
-+        gplot.legend_matlab(lgd)
-+        plt.grid(True)
-+        plt.xlabel('$t\\ [a/v_{th}]$')
-+        plt.ylabel('$\\vert\\varphi\\vert^2$')
-+        plt.title('$\\theta_0=$'+gplot.str_tt0(tt0[itt0]))
-+        tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-+        gplot.save_plot(tmp_pdfname, run, ifile)
-+        pdflist.append(tmp_pdfname)
-+        tmp_pdf_id = tmp_pdf_id+1
-+
-+    merged_pdfname = 'phi_vs_t'
-+    gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-+    plt.clf()
-+    plt.cla()
-+
-+
-+    # Plot potential at t[it_stop] vs theta for every ky, one plot per theta0
-+
-+    plt.figure(figsize=(12,8))
-+
-+    tmp_pdf_id = 1
-+    pdflist = []
-+    if naky > 1:
-+        cmap = plt.get_cmap('nipy_spectral')
-+        my_colors = [cmap(i) for i in np.linspace(0,1,naky)]
-+    else:
-+        my_colors = [gplot.myblue]
-+    for itt0 in range(ntt0):
-+        lgd = []
-+        for iky in range(naky):
-+            plt.plot(theta,phi2_bytheta[it_stop-1,iky,itt0,:],color=my_colors[iky])
-+            lgd.append('$k_y=$'+gplot.str_ky(ky[iky]))
-+        gplot.legend_matlab(lgd)
-+        plt.grid(True)
-+        plt.xlabel('$\\theta$')
-+        plt.ylabel('$\\vert\\varphi\\vert^2$')
-+        plt.title('$\\theta_0=$'+gplot.str_tt0(tt0[itt0]))
-+        plt.gca().yaxis.set_major_formatter(FormatStrFormatter('%.2E'))
-+        tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-+        gplot.save_plot(tmp_pdfname, run, ifile)
-+        pdflist.append(tmp_pdfname)
-+        tmp_pdf_id = tmp_pdf_id+1
-+
-+    merged_pdfname = 'phi_vs_theta'
-+    gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-+    plt.clf()
-+    plt.cla()
-+
-+
-+    # Plot dens^2 at tfinal vs theta for every ky, one plot per theta0
-+
-+    plt.figure(figsize=(12,8))
-+
-+    tmp_pdf_id = 1
-+    pdflist = []
-+    if naky > 1:
-+        cmap = plt.get_cmap('nipy_spectral')
-+        my_colors_ion = [cmap(i) for i in np.linspace(0,1,naky)]
-+        my_colors_elec = [cmap(i) for i in np.linspace(0,1,naky)]
-+        elec_line = '--'
-+    else:
-+        my_colors_ion = [gplot.myblue]
-+        my_colors_elec = [gplot.myred]
-+        elec_line = '-'
-+    for itt0 in range(ntt0):
-+        lgd = []
-+        for iky in range(naky):
-+            # ion
-+            plt.plot(theta,dens2[0,iky,itt0,:],color=my_colors_ion[iky])
-+            lgd.append('ion $k_y=$'+gplot.str_ky(ky[iky]))
-+            # electron
-+            plt.plot(theta,dens2[1,iky,itt0,:],color=my_colors_elec[iky], linestyle=elec_line)
-+            lgd.append('electron $k_y=$'+gplot.str_ky(ky[iky]))
-+        gplot.legend_matlab(lgd)
-+        plt.grid(True)
-+        plt.xlabel('$\\theta$')
-+        plt.ylabel('$\\vert\\delta n_{h}\\vert^2$')
-+        plt.title('$\\theta_0=$'+gplot.str_tt0(tt0[itt0]))
-+        plt.gca().yaxis.set_major_formatter(FormatStrFormatter('%.2E'))
-+        tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-+        gplot.save_plot(tmp_pdfname, run, ifile)
-+        pdflist.append(tmp_pdfname)
-+        tmp_pdf_id = tmp_pdf_id+1
-+
-+    merged_pdfname = 'dens_vs_theta'
-+    gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-+    plt.clf()
-+    plt.cla()
-+
-+
-+    # Plot TFloq*gamma vs ky, one plot per theta0
-+
-+    if g_exb != 0.0 and naky > 1:
-+
-+        # Floquet period
-+        Tf = 2*math.pi*shat/g_exb
-+
-+        plt.figure(figsize=(12,8))
-+
-+        tmp_pdf_id = 1
-+        pdflist = []
-+        for itt0 in range(ntt0):
-+            l, = plt.plot(ky,Tf*gamma[:,itt0], color=gplot.myblue, linewidth=3.0)
-+            l.set_label('$\\theta_0=$'+gplot.str_tt0(tt0[itt0]))
-+            gplot.legend_matlab()
-+            plt.grid(True)
-+            plt.xlabel('$k_y\\rho_i$')
-+            plt.ylabel('$\\gamma T_F$')
-+            my_title = '$T_F=' + str(round(Tf,3)) + '\ [r_r/v_{thr}]$'
-+            plt.title(my_title)
-+            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-+            gplot.save_plot(tmp_pdfname, run, ifile)
-+            pdflist.append(tmp_pdfname)
-+            tmp_pdf_id = tmp_pdf_id+1
-+
-+        merged_pdfname = 'floq_vs_growth'
-+        gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-+        plt.clf()
-+        plt.cla()
-+
-+
-+
-+
-+
-+
-+def get_growthrate(t,phi2,it_start,it_stop,itt0,iky):
-+   
-+    popt, pcov = opt.curve_fit(lin_func, t[it_start:it_stop], np.log(phi2[it_start:it_stop,iky,itt0]))
-+    return popt[0]
-+
-+def lin_func(x,a,b):
-+    return a*x+b
-+
-+def is_number(x):
-+    try:
-+        x_str = str(float(x))
-+        if x_str=='nan' or x_str=='inf' or x_str=='-inf':
-+            return False
-+    except ValueError:
-+        try:
-+            complex(x_str)
-+        except ValueError:
-+            return False
-+    return True
diff --git a/gs2_analysis.py b/gs2_analysis.py
index 3d7dd2f..a6a7110 100644
--- a/gs2_analysis.py
+++ b/gs2_analysis.py
@@ -10,7 +10,7 @@ import copy
 
 # TODO: add 'your_task' to the array.
 tasks_choices = ['fluxes', 'zonal', 'tcorr', 'flowtest', 'floquet', \
-        'linrange','fluxes_stitch','potential']
+        'lingrowth','fluxes_stitch','potential']
 
 # Fom command-line arguments, get info about this analysis run (filenames, tasks to complete ...)
 run = grunpar.runobj(tasks_choices)
@@ -45,7 +45,7 @@ for ifile in range(len(run.fnames)):
         myout = gdata.get_output(ifile, run)
 
         # Extract grids from output
-        mygrids = ggrids.gridobj(myout)
+        mygrids = ggrids.gridobj(myout, myin)
         # Extract time from output
         mytime = gtime.timeobj(myout, run.twin)
         # Extract fields from output
diff --git a/gs2_data.py b/gs2_data.py
index cf35da6..caa0918 100644
--- a/gs2_data.py
+++ b/gs2_data.py
@@ -50,10 +50,6 @@ out_varnames = [
         'tpar_igomega_by_mode',
         # complex perpendicular temperature fluctuation for a given theta, usually outboard mid-plane [t,spec,ky,kx,imag]
         'tperp_igomega_by_mode',
-        # total density at last time step [spec,ky,kx,theta,imag]
-        'ntot',
-        # non-adiabatic part of the density at last time step [spec,ky,kx,theta,imag]
-        'density',
         'gds2',
         'gds21',
         'gds22',
diff --git a/gs2_data.pyc b/gs2_data.pyc
deleted file mode 100644
index 4690e61..0000000
Binary files a/gs2_data.pyc and /dev/null differ
diff --git a/gs2_fields.py b/gs2_fields.py
index 2b0a59e..8c6df3f 100644
--- a/gs2_fields.py
+++ b/gs2_fields.py
@@ -12,7 +12,7 @@ class fieldobj:
     def __init__(self, myout, mygrids, mytime):
         
         ( self.phi2_avg, self.phi_gs2, self.dens_gs2, self.upar_gs2, self.tpar_gs2, self.tperp_gs2,
-                self.phi, self.phi2, self.gphi_gs2, self.Ex_gs2, self.Ey_gs2, 
+                self.phi, self.phi2, self.phi_bytheta_tfinal, self.gphi_gs2, self.Ex_gs2, self.Ey_gs2, 
                 self.zonal_E ) = self.get_attr(myout, mygrids, mytime)
 
     def get_attr(self, myout, mygrids, mytime):
@@ -23,6 +23,9 @@ class fieldobj:
         print('arranging fields in Fourier space ...',end='')
 
         # combine real and imaginary parts into single complex variables
+        mydim = (mygrids.ny, mygrids.nx, mygrids.ntheta)
+        phi_bytheta_tfinal = form_complex('phi', myout, mydim)
+
         mydim = (mytime.ntime, mygrids.ny, mygrids.nx)
         phi_gs2 = form_complex('phi_igomega_by_mode', myout, mydim)
         
@@ -33,6 +36,7 @@ class fieldobj:
         tperp_gs2 = form_complex('tperp_igomega_by_mode', myout, mydim)
 
         # reorder kx grid to be monotonic
+        phi_bytheta_tfinal = np.concatenate((phi_bytheta_tfinal[:,mygrids.nxmid:,:],phi_bytheta_tfinal[:,:mygrids.nxmid,:]),axis=1)
         phi = np.concatenate((phi_gs2[:,:,mygrids.nxmid:],phi_gs2[:,:,:mygrids.nxmid]),axis=2)
         phi2 = np.abs(phi)**2
         # get gyro-averaged phi (at vperp = vth)
@@ -57,7 +61,7 @@ class fieldobj:
         print('complete')
 
         return ( phi2_avg, phi_gs2, dens_gs2, upar_gs2, tpar_gs2, tperp_gs2,
-                phi, phi2, gphi_gs2, Ex_gs2, Ey_gs2, zonal_E )
+                phi, phi2, phi_bytheta_tfinal, gphi_gs2, Ex_gs2, Ey_gs2, zonal_E )
 
 class field_ffted_obj:
 
diff --git a/gs2_grids.py b/gs2_grids.py
index 8f10a1e..8f841dc 100644
--- a/gs2_grids.py
+++ b/gs2_grids.py
@@ -4,12 +4,15 @@ from math import pi
 
 class gridobj:
 
-    def __init__(self, myout):
+    def __init__(self, myout, myin):
 
         print()
         print('constructing grids ... ', end='')
 
+        self.jtwist = myin['kt_grids_box_parameters']['jtwist']
+
         self.kx_gs2 = np.copy(myout['kx'])
+        self.theta0_gs2 = np.copy(myout['theta0'])
         self.ky = np.copy(myout['ky'])
 
         # number of kx and ky grid points
@@ -22,6 +25,7 @@ class gridobj:
 
         # get the monotonically increasing kx grid
         self.kx = np.concatenate((self.kx_gs2[self.nxmid:],self.kx_gs2[:self.nxmid]))
+        self.theta0 = np.concatenate((self.theta0_gs2[:,self.nxmid:],self.theta0_gs2[:,:self.nxmid]),axis=1)
 
         self.kperp = np.arange(self.ny*self.nx,dtype=float).reshape(self.ny,self.nx)
         for i in range(self.nx):
diff --git a/gs2_plotting.py b/gs2_plotting.py
index 70d41b9..990d231 100644
--- a/gs2_plotting.py
+++ b/gs2_plotting.py
@@ -6,48 +6,12 @@ import matplotlib.colors as mcolors
 import numpy as np
 from PyPDF2 import PdfFileMerger, PdfFileReader
 import os
-import scipy.interpolate as scinterp
-from math import pi
 
 myred = [183./255, 53./255, 53./255]
 myblue = [53./255, 118./255, 183./255]
 oxblue = [0.,33./255,71./255]
 oxbluel = [68./255,104./255,125./255]
 oxbluell = [72./255,145./255,220./255]
-midLoRed = [255./255,178./255,172./255]
-midHiRed = [179./255,26./255,0./255]
-darkRed = [102./255,26./255,0./255]
-midLoBlue = [179./255,217./255,255./255]
-midHiBlue = [0./255,115./255,153./255]
-darkBlue = [0./255,0./255,77./255]
-
-def RdBu_centered(minVal, maxVal):
-
-    if minVal<0 and maxVal>0:
-        bluePart = abs(minVal)/(maxVal-minVal)
-    elif minVal>0:
-        bluePart = 0.0
-    elif maxVal<0:
-        bluePart = 1.0
-    c = mcolors.ColorConverter().to_rgb
-    seq = [darkBlue, midHiBlue, bluePart/3.0, \
-            midHiBlue, midLoBlue, 2.0*bluePart/3.0, \
-            midLoBlue, c('white'), bluePart, \
-            c('white'), midLoRed, (1.0-bluePart)/3.0+bluePart, \
-            midLoRed, midHiRed, 2.0*(1.0-bluePart)/3.0+bluePart, \
-            midHiRed, darkRed]
-    #print(bluePart)
-    #seq = [c('blue'), c('white'), bluePart, c('white'), c('red')]
-    seq = [(None,) * 3, 0.0] + list(seq) + [1.0, (None,) * 3]
-    cdict = {'red': [], 'green': [], 'blue': []}
-    for i, item in enumerate(seq):
-        if isinstance(item, float):
-            r1, g1, b1 = seq[i - 1]
-            r2, g2, b2 = seq[i + 1]
-            cdict['red'].append([item, r1, r2])
-            cdict['green'].append([item, g1, g2])
-            cdict['blue'].append([item, b1, b2])
-    return mcolors.LinearSegmentedColormap('CustomMap', cdict)
 
 def save_plot(pdfname, run, ifile = None):
 
@@ -93,7 +57,7 @@ def merge_pdfs(in_namelist, out_name, run, ifile = None):
 def set_plot_defaults():
 
     # setup some plot defaults
-    plt.rc('text', usetex=True)
+    plt.rc('text', usetex=False)
     plt.rc('font', family='serif')
     plt.rc('font', size=30)
     rcParams.update({'figure.autolayout': True})
@@ -101,33 +65,6 @@ def set_plot_defaults():
     rcParams.update({'legend.frameon': False})
     #rcParams.update({'animation.ffmpeg_path':'/marconi/home/userexternal/nchriste/codes/ffmpeg'}) # for HPC use only
 
-
-
-def nearNeighb_interp_1d(x,y,xout):
-
-    if isinstance(x,(list)):
-        n = len(x)
-    elif isinstance(x,(np.ndarray)):
-        n = x.size
-    if isinstance(xout,(list)):
-        nout = len(xout)
-        yout = [0*i for i in range(nout)]
-    elif isinstance(xout,(np.ndarray)):
-        nout = xout.size
-        yout = np.zeros(nout)
-
-    i = 0
-    iout = 0
-    for i in range(n-1):
-        while xout[iout]-x[i] < (x[i+1]-x[i])/2.0:
-            yout[iout] = y[i]
-            iout += 1
-    yout[iout:] = y[-1]
-
-    return yout
-
-
-
 def plot_1d(x,y,xlab,title='',ylab=''):
 
     fig = plt.figure(figsize=(12,8))
@@ -144,10 +81,6 @@ def plot_2d(z,xin,yin,zmin,zmax,xlab='',ylab='',title='',cmp='RdBu',use_logcolor
     fig = plt.figure(figsize=(12,8))
     x,y = np.meshgrid(xin,yin)
 
-    # Centered blue->red color map
-    if cmp=='RdBu_c':
-        cmp = RdBu_centered(zmin, zmax)
-
     if use_logcolor:
         color_norm = mcolors.LogNorm(zmin,zmax)
     else:
@@ -164,26 +97,6 @@ def plot_2d(z,xin,yin,zmin,zmax,xlab='',ylab='',title='',cmp='RdBu',use_logcolor
     plt.title(title)
     return fig
 
-# Input:
-# x = x[iy][ix]
-# y = y[iy]
-# z = z[iy][ix]
-def plot_2d_uneven_xgrid(x, y, z, xmin, xmax, cbarmin, cbarmax, xlabel, ylabel, title, ngrid_fine = 1001):
-
-    # Here we assume that the scan uses a fixed set of ky.
-    ny = y.size
-
-    # Finer and regular x mesh
-    ntheta0_fine = 1001
-    x_fine = np.linspace(xmin, xmax, ngrid_fine)
-    z_fine = np.zeros((ny, ngrid_fine))
-
-    # For each ky, interpolate to nearest neighbour in x
-    for iy in range(ny):
-        z_fine[iy,:] = nearNeighb_interp_1d(x[iy],z[iy],x_fine)
-
-    plot_2d(z_fine, x_fine, y, cbarmin, cbarmax, xlabel, ylabel, title, 'RdBu_c')
-
 def movie_2d(z,xin,yin,zmin,zmax,nframes,outfile,xlab='',ylab='',title='',step=1,cmp='RdBu'):
 
     from matplotlib import animation
@@ -229,36 +142,3 @@ def movie_1d(x,y,xmin,xmax,ymin,ymax,nframes):
                                  frames=nframes, interval=200)
 
     return anim
-
-def str_tt0(theta0):
-
-    n = int(round(theta0/(2.0*pi)))
-
-    txt = '{: .2f}'.format(theta0 - 2*pi*n)
-
-    if n > 0:
-        txt += '$+' + str(2*n) + '\\pi$'
-    elif n < 0:
-        txt += '$-' + str(abs(2*n)) + '\\pi$'
-
-    return txt
-
-def str_t(time):
-
-    return '${:.2E}$'.format(time)
-
-def str_ky(ky):
-
-    return '{: .2f}'.format(ky)
-
-def legend_matlab(my_legend=None):
-
-    if my_legend:
-        legend = plt.legend(my_legend, frameon=True, fancybox=False)
-    else:
-        legend = plt.legend(frameon=True, fancybox=False)
-    frame = legend.get_frame()
-    frame.set_facecolor('white')
-    frame.set_edgecolor('black')
-    frame.set_linewidth(0.5)
-    frame.set_alpha(1)
diff --git a/gs2_plotting.pyc b/gs2_plotting.pyc
deleted file mode 100644
index e5cc483..0000000
Binary files a/gs2_plotting.pyc and /dev/null differ
diff --git a/gs2_quick_parameters.pyc b/gs2_quick_parameters.pyc
deleted file mode 100644
index e3a771c..0000000
Binary files a/gs2_quick_parameters.pyc and /dev/null differ
diff --git a/gs2_run_parameters.pyc b/gs2_run_parameters.pyc
deleted file mode 100644
index 75b8eb3..0000000
Binary files a/gs2_run_parameters.pyc and /dev/null differ
diff --git a/gs2_tasks.py b/gs2_tasks.py
index 784af2d..7762fbe 100644
--- a/gs2_tasks.py
+++ b/gs2_tasks.py
@@ -10,8 +10,8 @@ import fluxes
 import time_correlation as tcorr
 # TODO: save your python script in the task/ folder and import it here.
 import flowtest
-import linbox
-import linrange
+import floquet
+import lingrowth
 import potential
 import boxballoon
 
@@ -77,13 +77,13 @@ def complete_task_single(ifile, task, run, myin, myout, mygrids, mytime, myfield
 
         flowtest.store(myin, myout, task_space)
 
-    if (task == 'floquet' or task == 'linbox'):
+    if (task == 'floquet'):
 
-        linbox.my_task_single(ifile, run, myin, myout, mytime, task_space)
+        floquet.my_task_single(ifile, run, myin, myout, task_space)
 
-    if (task == 'linrange'):
+    if (task == 'lingrowth'):
 
-        linrange.my_task_single(ifile, run, myin, myout, mytime)
+        lingrowth.my_task_single(ifile, run, myin, myout)
 
     if (task == 'potential'):
 
@@ -119,9 +119,9 @@ def complete_task_scan(task, run, full_space):
 
         flowtest.plot(run, full_space)
 
-    if (task == 'floquet_scan' or task == 'linbox_scan'):
+    if (task == 'floquet_scan'):
 
-        linbox.task_scan(run, full_space)
+        floquet.task_scan(run, full_space)
 
     if (task == 'fluxes_stitch'):
        
diff --git a/gs2_time.py b/gs2_time.py
index e7fdc92..b2f2df5 100644
--- a/gs2_time.py
+++ b/gs2_time.py
@@ -16,7 +16,10 @@ class timeobj:
 
         # get starting index for steady-state
         self.twin = twin
-        self.it_min = int(ceil((1.0-twin)*self.ntime))
+        tmin = self.time[-1]*(1.0-twin)
+        self.it_min = 0
+        while self.time[self.it_min] < tmin:
+            self.it_min += 1
         self.it_max = self.ntime-1
         # get number of time points in steady-state interval
         self.it_interval = self.ntime - self.it_min
diff --git a/plot_misc/linbox_scan.py b/plot_misc/linbox_scan.py
deleted file mode 100644
index bc7386f..0000000
--- a/plot_misc/linbox_scan.py
+++ /dev/null
@@ -1,807 +0,0 @@
-import sys
-import os
-
-# Add path to directory where scan-files are stored
-sys.path.insert(1, '/marconi/home/userexternal/nchriste/codes/scan_gs2/paramfiles')
-# Add path to directory where gs2_plotting is stored
-sys.path.insert(1, '/marconi/home/userexternal/nchriste/codes/diagnostics_gs2')
-
-import f90nml as fnml
-import numpy as np
-import copy as cp
-import pickle
-import matplotlib.pyplot as plt
-from matplotlib import rcParams
-from math import pi
-import scipy.interpolate as scinterp
-import scipy.optimize as opt
-import gs2_plotting as gplot
-from PyPDF2 import PdfFileMerger, PdfFileReader
-
-plt.rc('text', usetex=True)
-plt.rc('font', family='serif')
-plt.rc('font', size=20)
-rcParams.update({'figure.autolayout': True})
-rcParams.update({'legend.fontsize': 12, 'legend.handlelength': 4})
-rcParams.update({'legend.frameon': False})
-
-ONE = 'one'
-TWO = 'two'
-NDIM_MAX = TWO
-
-# Dict that will contain every parameter to scan
-scan = {ONE:[],TWO:[]}
-
-
-
-
-
-
-# vvv USER PARAMETERS vvv
-
-# Import all parameters from paramfiles/myfile.py
-base_name = 'rpsi_0.8'  
-pf = __import__('scan_ky_kxmax_fixed_dkx_ijp_950_rpsi_08')  
-
-# Number of dimensions in the scan
-# e.g. vs (ky, R/LTi) -> ndim = TWO
-ndim = TWO
-
-# Define which dmid to use when plotting quant vs ky.
-# dmid is the number of dkx between kx=0 and the
-# smallest kx>0 that is a member of a particular
-# twist and shift chain at t=0, ie it identifies that chain.
-dmid_for_plots_vs_ky = 0
-
-# Define first dimension of the scan
-firstdim_label = '$\\rho_i k_y$' # for plotting
-firstdim_var = 'ky' # name of variable to append to figure names
-firstdim = pf.ky # variable name in paramfiles/myfile.py
-
-# Define second dimension of the scan
-if ndim == TWO:
-
-    #seconddim_label = '$N_x = {0:d}$'.format(seconddim[ival]))  
-    #seconddim_label = '$N_{2\\pi}$'
-    seconddim_label = '$k_{x,max}$'
-    #seconddim_label = '$\\Delta k_x$'
-    #seconddim_label = '$\\rho k_y$'
-    #seconddim_label = '$N_\\theta$'
-    #seconddim_label = '$N_\\varepsilon$'
-    #seconddim_label = '$v_{max}$'
-    #seconddim_label = '$N_{\\lambda,untrap}$'
-    #seconddim_label = '$a/L_{T_e}$'
-    #seconddim_label = '$\gamma_E$$'
-
-    seconddim_var = 'nx'  
-
-    #seconddim = (2*np.round((pf.nx-1)/3)+1).astype(int) # nakx
-    seconddim = np.round((pf.nx-1)/3) * pf.dkx  # kxmax
-    #seconddim = np.round((2*np.round((pf.nx-1)/3))/(2*pi*pf.shat*firstdim[-1]/pf.dkx)+1,2) # Ntwopi
-    #seconddim = pf.negrid  
-
-elif ndim == ONE:
-
-    seconddim_label = '_dummy'
-    seconddim_var = 'dummy'
-    seconddim = np.array([0])
-
-# Does the scan have only a single ky ?
-scan_with_single_ky = False  
-
-# Apply limits to axis when plotting ?
-use_my_xlim = False
-my_xlim = (0.0, 2.0)  
-
-use_my_ylim = True
-# rpsi = 0.6
-my_ylim_max = (0.0, 0.35)
-my_ylim_avg = (-0.05, 0.15)
-# rpsi = 0.7
-#my_ylim_max = (0.0, 0.40)
-#my_ylim_avg = (-0.02, 0.09)
-# rpsi = 0.8
-#my_ylim_max = (0.0, 0.50)
-#my_ylim_avg = (-0.02, 0.08)
-# rpsi = 0.9
-#my_ylim_max = (0.0, 0.30)
-#my_ylim_avg = (-0.06, 0.00)
-#my_ylim_avg = my_ylim_max
-
-# Fix colorbar limits ?
-fix_cbarlim = True
-# rpsi = 0.6
-my_cbarmin = -0.20
-my_cbarmax = 0.2
-# rpsi = 0.7
-#my_cbarmin = -0.30
-#my_cbarmax = 0.3
-# rpsi = 0.8
-#my_cbarmin = -0.30
-#my_cbarmax = 0.3
-
-# Original code was written for kyas second dim of scan (not first).
-# To restore this, set invert_dims = True
-invert_dims = False  
-
-# ^^^ USER PARAMETERS ^^^
-
-
-
-
-
-
-def main():
-
-    # Logical testing if instantaneous growthrate was computed
-    gamma_inst_pres = True
-
-    if scan_with_single_ky:
-        valdim = firstdim.size
-    else:
-        valdim = seconddim.size
-
-    # Add all parameters to the current scan
-    nparams = len(pf.name)
-    for iparam in range(nparams):
-        add_param_to_scan(scan, pf.name[iparam], pf.dim[iparam], pf.namelist[iparam], pf.scandim[iparam], pf.func[iparam])
-
-    # Read data from .dat files for every file in scan
-    g_exb_vs_v2_ky_tt0 = []
-    dmid_list_vs_v2_ky_tt0 = []
-    itheta0_list_vs_v2_ky_tt0 = []
-    theta0_vs_v2_ky_tt0 = []
-    theta0_star_for_inst_vs_v2_ky_tt0 = []
-    firstdim_vs_v2_ky_tt0 = []
-    gamma_avg_vs_v2_ky_tt0 = []
-    gamma_avg_fromSum_vs_v2_ky_tt0 = []
-    gamma_max_vs_v2_ky_tt0 = []
-    gamma_max_fromSum_vs_v2_ky_tt0 = []
-    gamma_inst_vs_v2_ky_tt0 = []
-    gamma_inst_fromSum_vs_v2_ky_tt0 = []
-    Qratio_avg_vs_v2_ky_tt0 = []
-    scandim=ONE
-    ival_firstdim = -1
-    valtree = [0*i for i in range(nparams)]
-    read_data(base_name, valtree, scandim, ival_firstdim, dmid_list_vs_v2_ky_tt0, itheta0_list_vs_v2_ky_tt0, theta0_vs_v2_ky_tt0, \
-            firstdim_vs_v2_ky_tt0, gamma_avg_vs_v2_ky_tt0, gamma_avg_fromSum_vs_v2_ky_tt0, gamma_max_vs_v2_ky_tt0, \
-             gamma_max_fromSum_vs_v2_ky_tt0, Qratio_avg_vs_v2_ky_tt0, g_exb_vs_v2_ky_tt0, \
-            gamma_inst_vs_v2_ky_tt0, gamma_inst_fromSum_vs_v2_ky_tt0, theta0_star_for_inst_vs_v2_ky_tt0)
-    if not gamma_inst_vs_v2_ky_tt0[0]:
-        gamma_inst_pres = False
-
-
-
-
-    # Re-organise data
-
-    if not invert_dims:
-
-        # Arrays for data with all theta0
-        dmid_list_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-        itheta0_list_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-        theta0_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-        firstdim_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-        gamma_avg_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-        gamma_avg_fromSum_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-        gamma_max_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-        gamma_max_fromSum_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-        Qratio_avg_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-        g_exb_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-        if gamma_inst_pres:
-            gamma_inst_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-            gamma_inst_fromSum_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-            theta0_star_for_inst_vs_v2_ky_tt0_new = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-
-        # Arrays for data with only theta0 = 0
-        firstdim_vs_v2_ky = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-        gamma_avg_vs_v2_ky = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-        gamma_avg_fromSum_vs_v2_ky = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-        gamma_max_vs_v2_ky = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-        gamma_max_fromSum_vs_v2_ky = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-        Qratio_avg_vs_v2_ky = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-        g_exb_vs_v2_ky = [[0*i*j for i in range(firstdim.size)] for j in range(seconddim.size)]
-
-        for ival_first in range(firstdim.size):
-
-            for ival_scnd in range(seconddim.size):
-
-                # Rearrange keeping all theta0
-                dmid_list_vs_v2_ky_tt0_new[ival_scnd][ival_first] = dmid_list_vs_v2_ky_tt0[ival_first][ival_scnd]
-                itheta0_list_vs_v2_ky_tt0_new[ival_scnd][ival_first] = itheta0_list_vs_v2_ky_tt0[ival_first][ival_scnd]
-                theta0_vs_v2_ky_tt0_new[ival_scnd][ival_first] = theta0_vs_v2_ky_tt0[ival_first][ival_scnd]
-                firstdim_vs_v2_ky_tt0_new[ival_scnd][ival_first] = firstdim_vs_v2_ky_tt0[ival_first][ival_scnd]
-                gamma_avg_vs_v2_ky_tt0_new[ival_scnd][ival_first] = gamma_avg_vs_v2_ky_tt0[ival_first][ival_scnd]
-                gamma_avg_fromSum_vs_v2_ky_tt0_new[ival_scnd][ival_first] = gamma_avg_fromSum_vs_v2_ky_tt0[ival_first][ival_scnd]
-                gamma_max_vs_v2_ky_tt0_new[ival_scnd][ival_first] = gamma_max_vs_v2_ky_tt0[ival_first][ival_scnd]
-                gamma_max_fromSum_vs_v2_ky_tt0_new[ival_scnd][ival_first] = gamma_max_fromSum_vs_v2_ky_tt0[ival_first][ival_scnd]
-                Qratio_avg_vs_v2_ky_tt0_new[ival_scnd][ival_first] = Qratio_avg_vs_v2_ky_tt0[ival_first][ival_scnd]
-                g_exb_vs_v2_ky_tt0_new[ival_scnd][ival_first] = g_exb_vs_v2_ky_tt0[ival_first][ival_scnd]
-                if gamma_inst_pres:
-                    gamma_inst_vs_v2_ky_tt0_new[ival_scnd][ival_first] = gamma_inst_vs_v2_ky_tt0[ival_first][ival_scnd]
-                    gamma_inst_fromSum_vs_v2_ky_tt0_new[ival_scnd][ival_first] = gamma_inst_fromSum_vs_v2_ky_tt0[ival_first][ival_scnd]
-                    theta0_star_for_inst_vs_v2_ky_tt0_new[ival_scnd][ival_first] = theta0_star_for_inst_vs_v2_ky_tt0[ival_first][ival_scnd]
-
-                # try to find the index of theta0 = 0
-                idmid = 0
-                try:
-                    while dmid_list_vs_v2_ky_tt0[ival_first][ival_scnd][idmid] != dmid_for_plots_vs_ky:
-                        idmid += 1
-                except:
-                    idmid = 0
-
-                # Rearrange keeping only theta0 = 0
-                firstdim_vs_v2_ky[ival_scnd][ival_first] = firstdim_vs_v2_ky_tt0[ival_first][ival_scnd]
-                gamma_avg_vs_v2_ky[ival_scnd][ival_first] = gamma_avg_vs_v2_ky_tt0[ival_first][ival_scnd][idmid]
-                gamma_avg_fromSum_vs_v2_ky[ival_scnd][ival_first] = gamma_avg_fromSum_vs_v2_ky_tt0[ival_first][ival_scnd][idmid]
-                gamma_max_vs_v2_ky[ival_scnd][ival_first] = gamma_max_vs_v2_ky_tt0[ival_first][ival_scnd][idmid]
-                gamma_max_fromSum_vs_v2_ky[ival_scnd][ival_first] = gamma_max_fromSum_vs_v2_ky_tt0[ival_first][ival_scnd][idmid]
-                Qratio_avg_vs_v2_ky[ival_scnd][ival_first] = Qratio_avg_vs_v2_ky_tt0[ival_first][ival_scnd]
-                g_exb_vs_v2_ky[ival_scnd][ival_first] = g_exb_vs_v2_ky_tt0[ival_first][ival_scnd]
-
-        # Overwrite old arrays
-        dmid_list_vs_v2_ky_tt0 = dmid_list_vs_v2_ky_tt0_new
-        itheta0_list_vs_v2_ky_tt0 = itheta0_list_vs_v2_ky_tt0_new
-        theta0_vs_v2_ky_tt0 = theta0_vs_v2_ky_tt0_new
-        firstdim_vs_v2_ky_tt0 = firstdim_vs_v2_ky_tt0_new
-        gamma_avg_vs_v2_ky_tt0 = gamma_avg_vs_v2_ky_tt0_new
-        gamma_avg_fromSum_vs_v2_ky_tt0 = gamma_avg_fromSum_vs_v2_ky_tt0_new
-        gamma_max_vs_v2_ky_tt0 = gamma_max_vs_v2_ky_tt0_new
-        gamma_max_fromSum_vs_v2_ky_tt0 = gamma_max_fromSum_vs_v2_ky_tt0_new
-        Qratio_avg_vs_v2_ky_tt0 = Qratio_avg_vs_v2_ky_tt0_new
-        g_exb_vs_v2_ky_tt0 = g_exb_vs_v2_ky_tt0_new
-        if gamma_inst_pres:
-            gamma_inst_vs_v2_ky_tt0 = gamma_inst_vs_v2_ky_tt0_new
-            gamma_inst_fromSum_vs_v2_ky_tt0 = gamma_inst_fromSum_vs_v2_ky_tt0_new
-            theta0_star_for_inst_vs_v2_ky_tt0 = theta0_star_for_inst_vs_v2_ky_tt0_new
-
-        # Get rid of extra dimension if ndim=1
-        if ndim == ONE:
-
-            dmid_list_vs_v2_ky_tt0 = dmid_list_vs_v2_ky_tt0[0]
-            dmid_list_vs_v2_ky = dmid_list_vs_v2_ky[0]
-            itheta0_list_vs_v2_ky_tt0 = itheta0_list_vs_v2_ky_tt0[0]
-            itheta0_list_vs_v2_ky = itheta0_list_vs_v2_ky[0]
-            theta0_vs_v2_ky_tt0 = theta0_vs_v2_ky_tt0[0]
-            theta0_vs_v2_ky = theta0_vs_v2_ky[0]
-            firstdim_vs_v2_ky_tt0 = firstdim_vs_v2_ky_tt0[0]
-            firstdim_vs_v2_ky = firstdim_vs_v2_ky[0]
-            gamma_avg_vs_v2_ky_tt0 = gamma_avg_vs_v2_ky_tt0[0]
-            gamma_avg_fromSum_vs_v2_ky_tt0 = gamma_avg_fromSum_vs_v2_ky_tt0[0]
-            gamma_avg_vs_v2_ky = gamma_avg_vs_v2_ky[0]
-            gamma_avg_fromSum_vs_v2_ky = gamma_avg_fromSum_vs_v2_ky[0]
-            gamma_max_vs_v2_ky_tt0 = gamma_max_vs_v2_ky_tt0[0]
-            gamma_max_fromSum_vs_v2_ky_tt0 = gamma_max_fromSum_vs_v2_ky_tt0[0]
-            gamma_max_vs_v2_ky = gamma_max_vs_v2_ky[0]
-            gamma_max_fromSum_vs_v2_ky = gamma_max_fromSum_vs_v2_ky[0]
-            Qratio_avg_vs_v2_ky_tt0 = Qratio_avg_vs_v2_ky_tt0[0]
-            Qratio_avg_vs_v2_ky = Qratio_avg_vs_v2_ky[0]
-            g_exb_vs_v2_ky = g_exb_vs_v2_ky[0]
-            if gamma_inst_pres:
-                gamma_inst_vs_v2_ky_tt0 = gamma_inst_vs_v2_ky_tt0[0]
-                gamma_inst_fromSum_vs_v2_ky_tt0 = gamma_inst_fromSum_vs_v2_ky_tt0[0]
-                theta0_star_for_inst_vs_v2_ky_tt0 = theta0_star_for_inst_vs_v2_ky_tt0[0]
-
-    # Save data vs var2,ky with all theta0
-    vardict = {}
-    vardict['dmid_list_vs_v2_ky_tt0'] = dmid_list_vs_v2_ky_tt0
-    vardict['itheta0_list_vs_v2_ky_tt0'] = itheta0_list_vs_v2_ky_tt0
-    vardict['theta0_vs_v2_ky_tt0'] = theta0_vs_v2_ky_tt0
-    vardict['firstdim_vs_v2_ky_tt0'] = firstdim_vs_v2_ky_tt0
-    vardict['gamma_avg_vs_v2_ky_tt0'] = gamma_avg_vs_v2_ky_tt0
-    vardict['gamma_avg_fromSum_vs_v2_ky_tt0'] = gamma_avg_fromSum_vs_v2_ky_tt0
-    vardict['gamma_max_vs_v2_ky_tt0'] = gamma_max_vs_v2_ky_tt0
-    vardict['gamma_max_fromSum_vs_v2_ky_tt0'] = gamma_max_fromSum_vs_v2_ky_tt0
-    vardict['Qratio_avg_vs_v2_ky_tt0'] = Qratio_avg_vs_v2_ky_tt0
-    vardict['g_exb_vs_v2_ky_tt0'] = g_exb_vs_v2_ky_tt0
-    if gamma_inst_pres:
-        vardict['theta0_star_for_inst_vs_v2_ky_tt0'] = theta0_star_for_inst_vs_v2_ky_tt0
-        vardict['gamma_inst_vs_v2_ky_tt0'] = gamma_inst_vs_v2_ky_tt0
-        vardict['gamma_inst_fromSum_vs_v2_ky_tt0'] = gamma_inst_fromSum_vs_v2_ky_tt0
-    write_to_file(vardict)
-
-    # Here we assume that all runs have the same g_exb
-    g_exb = g_exb_vs_v2_ky[0][0]
-
-
-
-
-
-
-    # Plotting
-
-    # Plots vs ky and vs seconddim
-
-    if ndim == ONE:
-
-        pdfname = 'postproc/linbox_gamma_avg_scan_'+firstdim_var+'.pdf'
-        plt.figure()
-        my_legend = []
-        plt.grid(True)
-        plt.xlabel(firstdim_label)
-        if g_exb == 0.0:
-            plt.ylabel('$\\gamma [v_{th}/a]$')
-        else:
-            plt.ylabel('$\\langle\\gamma\\rangle_t [v_{th}/a]$')
-        plt.plot(firstdim_vs_v2_ky, gamma_avg_vs_v2_ky, linewidth=2.0, color='k')
-        if use_my_ylim:
-            plt.ylim(my_ylim_avg)
-        plt.savefig(pdfname)
-
-        pdfname = 'postproc/linbox_gamma_max_scan_'+firstdim_var+'.pdf'
-        plt.figure()
-        my_legend = []
-        plt.grid(True)
-        plt.xlabel(firstdim_label)
-        if g_exb == 0.0:
-            plt.ylabel('$\\gamma [v_{th}/a]$')
-        else:
-            plt.ylabel('$\\langle\\gamma\\rangle_t [v_{th}/a]$')
-        plt.plot(firstdim_vs_v2_ky, gamma_max_vs_v2_ky, linewidth=2.0, color='k')
-        if use_my_ylim:
-            plt.ylim(my_ylim_max)
-        plt.savefig(pdfname)
-
-        # Same plots, obtained from sum(phi2) instead of max(phi2)
-
-        pdfname = 'postproc/linbox_gamma_avg_fromSum_scan_'+firstdim_var+'.pdf'
-        plt.figure()
-        my_legend = []
-        plt.grid(True)
-        plt.xlabel(firstdim_label)
-        if g_exb == 0.0:
-            plt.ylabel('$\\gamma [v_{th}/a]$')
-        else:
-            plt.ylabel('$\\langle\\gamma\\rangle_t [v_{th}/a]$')
-        plt.plot(firstdim_vs_v2_ky, gamma_avg_fromSum_vs_v2_ky, linewidth=2.0, color='k')
-        if use_my_ylim:
-            plt.ylim(my_ylim_avg)
-        plt.savefig(pdfname)
-
-        pdfname = 'postproc/linbox_gamma_max_fromSum_scan_'+firstdim_var+'.pdf'
-        plt.figure()
-        my_legend = []
-        plt.grid(True)
-        plt.xlabel(firstdim_label)
-        if g_exb == 0.0:
-            plt.ylabel('$\\gamma [v_{th}/a]$')
-        else:
-            plt.ylabel('$\\langle\\gamma\\rangle_t [v_{th}/a]$')
-        plt.plot(firstdim_vs_v2_ky, gamma_max_fromSum_vs_v2_ky, linewidth=2.0, color='k')
-        if use_my_ylim:
-            plt.ylim(my_ylim_max)
-        plt.savefig(pdfname)
-
-    elif ndim == TWO:
-
-        color_vs_v2_ky = plt.cm.gnuplot_r(np.linspace(0.05,0.9,seconddim.size))
-        if scan_with_single_ky:
-            color_vs_v2_ky = ['blue']
-
-        if g_exb == 0.0:
-            pdfname = 'postproc/linbox_gamma_scan_'+firstdim_var+'_'+seconddim_var+'.pdf'
-        else:
-            pdfname = 'postproc/linbox_gamma_avg_scan_'+firstdim_var+'_'+seconddim_var+'.pdf'
-        plt.figure()
-        my_legend = []
-        plt.grid(True)
-        plt.xlabel(firstdim_label)
-        if g_exb == 0.0:
-            plt.ylabel('$\\gamma [v_{th}/a]$')
-        else:
-            plt.ylabel('$\\langle\\gamma\\rangle_t [v_{th}/a]$')
-        for ival in range(valdim):
-            if scan_with_single_ky:
-                plt.plot(seconddim, gamma_avg_vs_v2_ky, linewidth=2.0, color=color_vs_v2_ky[ival])
-            else:
-                plt.plot(firstdim_vs_v2_ky[ival], gamma_avg_vs_v2_ky[ival], linewidth=2.0, color=color_vs_v2_ky[ival])
-            my_legend.append(seconddim_label + '$=' + str(seconddim[ival]) + '$')
-        if use_my_ylim:
-            plt.ylim(my_ylim_avg)
-        if use_my_xlim:
-            plt.xlim(my_xlim)
-        legend = plt.legend(my_legend, frameon = True, fancybox = False)
-        frame = legend.get_frame()
-        frame.set_facecolor('white')
-        frame.set_edgecolor('black')
-        frame.set_linewidth(0.5)
-        frame.set_alpha(1)
-        plt.savefig(pdfname)
-
-        # Same plot obtained with sum(phi2) instead of max(phi2)
-
-        if g_exb == 0.0:
-            pdfname = 'postproc/linbox_gamma_fromSum_scan_'+firstdim_var+'_'+seconddim_var+'.pdf'
-        else:
-            pdfname = 'postproc/linbox_gamma_avg_fromSum_scan_'+firstdim_var+'_'+seconddim_var+'.pdf'
-        plt.figure()
-        my_legend = []
-        plt.grid(True)
-        plt.xlabel(firstdim_label)
-        if g_exb == 0.0:
-            plt.ylabel('$\\gamma [v_{th}/a]$')
-        else:
-            plt.ylabel('$\\langle\\gamma\\rangle_t [v_{th}/a]$')
-        for ival in range(valdim):
-            if scan_with_single_ky:
-                plt.plot(seconddim, gamma_avg_fromSum_vs_v2_ky, linewidth=2.0, color=color_vs_v2_ky[ival])
-            else:
-                plt.plot(firstdim_vs_v2_ky[ival], gamma_avg_fromSum_vs_v2_ky[ival], linewidth=2.0, color=color_vs_v2_ky[ival])
-            my_legend.append(seconddim_label + '$=' + str(seconddim[ival]) + '$')
-        if use_my_ylim:
-            plt.ylim(my_ylim_avg)
-        if use_my_xlim:
-            plt.xlim(my_xlim)
-        legend = plt.legend(my_legend, frameon = True, fancybox = False)
-        frame = legend.get_frame()
-        frame.set_facecolor('white')
-        frame.set_edgecolor('black')
-        frame.set_linewidth(0.5)
-        frame.set_alpha(1)
-        plt.savefig(pdfname)
-
-        if g_exb != 0.0:
-
-            pdfname = 'postproc/linbox_gamma_max_scan_'+firstdim_var+'_'+seconddim_var+'.pdf'
-            plt.figure()
-            my_legend = []
-            plt.grid(True)
-            plt.xlabel(firstdim_label)
-            plt.ylabel('$\\gamma_{max}\ [v_{th}/a]$')
-            for ival in range(valdim):
-                if scan_with_single_ky:
-                    plt.plot(seconddim, gamma_max_vs_v2_ky, linewidth=2.0, color=color_vs_v2_ky[ival])
-                else:
-                    plt.plot(firstdim_vs_v2_ky[ival], gamma_max_vs_v2_ky[ival], linewidth=2.0, color=color_vs_v2_ky[ival])
-                my_legend.append(seconddim_label + '$=' + str(seconddim[ival]) + '$')
-            if use_my_ylim:
-                plt.ylim(my_ylim_max)
-            if use_my_xlim:
-                plt.xlim(my_xlim)
-            legend = plt.legend(my_legend, frameon = True, fancybox = False, fontsize=8)
-            frame = legend.get_frame()
-            frame.set_facecolor('white')
-            frame.set_edgecolor('black')
-            frame.set_linewidth(0.5)
-            frame.set_alpha(1)
-            plt.savefig(pdfname)
-
-            # Same plot obtained with sum(phi2) instead of max(phi2)
-
-            pdfname = 'postproc/linbox_gamma_max_fromSum_scan_'+firstdim_var+'_'+seconddim_var+'.pdf'
-            plt.figure()
-            my_legend = []
-            plt.grid(True)
-            plt.xlabel(firstdim_label)
-            plt.ylabel('$\\gamma_{max}\ [v_{th}/a]$')
-            for ival in range(valdim):
-                if scan_with_single_ky:
-                    plt.plot(seconddim, gamma_max_fromSum_vs_v2_ky, linewidth=2.0, color=color_vs_v2_ky[ival])
-                else:
-                    plt.plot(firstdim_vs_v2_ky[ival], gamma_max_fromSum_vs_v2_ky[ival], linewidth=2.0, color=color_vs_v2_ky[ival])
-                my_legend.append(seconddim_label + '$=' + str(seconddim[ival]) + '$')
-            if use_my_ylim:
-                plt.ylim(my_ylim_max)
-            if use_my_xlim:
-                plt.xlim(my_xlim)
-            legend = plt.legend(my_legend, frameon = True, fancybox = False, fontsize=8)
-            frame = legend.get_frame()
-            frame.set_facecolor('white')
-            frame.set_edgecolor('black')
-            frame.set_linewidth(0.5)
-            frame.set_alpha(1)
-            plt.savefig(pdfname)
-
-        try:
-            pdfname = 'postproc/linbox_qe_vs_qi_scan_'+seconddim_var+'.pdf'
-            plt.figure()
-            my_legend = []
-            plt.grid(True)
-            plt.xlabel(seconddim_label)
-            plt.ylabel('$\\langle Q_e/Q_i\\rangle_t$')
-            plt.plot(seconddim, Qratio_avg_vs_v2_ky, linewidth=2.0, color='k')
-            plt.savefig(pdfname)
-        except:
-            print('Fluxes cannot be found in the output.')
-
-    # Plot gamma vs (theta0, ky),
-    # for every value of the second dimension in the scan.
-    
-    if firstdim_var == 'ky' and not (g_exb != 0.0 and not gamma_inst_pres):
-
-        # Preparing to stitch multiple pdfs together
-        tmp_pdf_id = 1
-        pdflist = []
-        tmp_pdf_id_fromSum = 1
-        pdflist_fromSum = []
-
-        # Here we assume that the scan uses a fixed set of ky.
-        ky = np.array(firstdim_vs_v2_ky_tt0[0])
-        naky = ky.size
-
-        for ival in range(valdim):
-
-            gamma_min = 1e20
-            gamma_max = -1e20
-            gamma_min_fromSum = 1e20
-            gamma_max_fromSum = -1e20
-
-            theta0 = []
-            gamma = []
-            theta0_fromSum = []
-            gamma_fromSum = []
-
-            for iky in range(naky):
-
-                if g_exb == 0.0:
-
-                    theta0.append([])
-                    gamma.append([])
-                    theta0_fromSum.append([])
-                    gamma_fromSum.append([])
-
-                    ntheta0 = len(itheta0_list_vs_v2_ky_tt0[ival][iky])
-
-                    for iitheta0 in range(ntheta0):
-
-                        this_theta0 = theta0_vs_v2_ky_tt0[ival][iky][itheta0_list_vs_v2_ky_tt0[ival][iky][iitheta0]]
-                        this_gamma = gamma_avg_vs_v2_ky_tt0[ival][iky][iitheta0]
-
-                        theta0[iky].append(this_theta0)
-                        gamma[iky].append(this_gamma)
-
-                        # Update min and max gamma
-                        if this_gamma < gamma_min:
-                            gamma_min = this_gamma
-                        if this_gamma > gamma_max:
-                            gamma_max = this_gamma
-
-
-                        # Do the same, based on sum(phi2) instead of max(phi2)
-
-                        this_gamma = gamma_avg_fromSum_vs_v2_ky_tt0[ival][iky][iitheta0]
-
-                        theta0[iky].append(this_theta0)
-                        gamma_fromSum[iky].append(this_gamma)
-
-                        # Update min and max gamma
-                        if this_gamma < gamma_min_fromSum:
-                            gamma_min_fromSum = this_gamma
-                        if this_gamma > gamma_max_fromSum:
-                            gamma_max_fromSum = this_gamma
-
-                else:
-
-                    theta0.append(theta0_star_for_inst_vs_v2_ky_tt0[ival][iky][dmid_for_plots_vs_ky])
-                    gamma.append(gamma_inst_vs_v2_ky_tt0[ival][iky][dmid_for_plots_vs_ky])
-
-                    # Update min and max gamma
-                    for idx in range(len(gamma[-1])):
-
-                        this_gamma = gamma[-1][idx]
-                        if this_gamma < gamma_min:
-                            gamma_min = this_gamma
-                        if this_gamma > gamma_max:
-                            gamma_max = this_gamma
-                    
-
-                    # Do the same, based on sum(phi2) instead of max(phi2)
-
-                    gamma_fromSum.append(gamma_inst_fromSum_vs_v2_ky_tt0[ival][iky][dmid_for_plots_vs_ky])
-
-                    # Update min and max gamma
-                    for idx in range(len(gamma_fromSum[-1])):
-
-                        this_gamma = gamma_fromSum[-1][idx]
-                        if this_gamma < gamma_min_fromSum:
-                            gamma_min_fromSum = this_gamma
-                        if this_gamma > gamma_max_fromSum:
-                            gamma_max_fromSum = this_gamma
-
-            if g_exb == 0.0:
-                xlabel = '$\\theta_0$'
-            else:
-                xlabel = '$\\theta_0^*$'
-            ylabel = '$k_y$'
-            title = '$\\gamma\ [v_{th}/a]$' + ', ' + seconddim_label + '$= {:.2f}$'.format(seconddim[ival])
-            if fix_cbarlim:
-                cbarmin = my_cbarmin
-                cbarmax = my_cbarmax
-            else:
-                cbarmin = gamma_min
-                cbarmax = gamma_max
-            # NUmber of points in refined x-grid
-            ngrid_fine = 1001
-            gplot.plot_2d_uneven_xgrid(theta0, ky, gamma, -pi, pi, \
-                    cbarmin, cbarmax, xlabel, ylabel, title, ngrid_fine)
-
-            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-            plt.savefig('postproc/'+tmp_pdfname+'.pdf')
-            pdflist.append(tmp_pdfname)
-            tmp_pdf_id = tmp_pdf_id+1
-        
-
-            # Same plot obtained with sum(phi2) instead of max(phi2)
-
-            gplot.plot_2d_uneven_xgrid(theta0, ky, gamma_fromSum, -pi, pi, \
-                    cbarmin, cbarmax, xlabel, ylabel, title, ngrid_fine)
-
-            tmp_pdfname = 'tmp'+str(tmp_pdf_id_fromSum)+'_fromSum'
-            plt.savefig('postproc/'+tmp_pdfname+'.pdf')
-            pdflist_fromSum.append(tmp_pdfname)
-            tmp_pdf_id_fromSum = tmp_pdf_id_fromSum+1
-
-        # Stitch the pdfs together
-
-        merged_pdfname = 'linbox_gam_vs_theta0_ky'
-        merge_pdfs(pdflist, merged_pdfname, 'postproc/')
-
-        merged_pdfname = 'linbox_gam_fromSum_vs_theta0_ky'
-        merge_pdfs(pdflist_fromSum, merged_pdfname, 'postproc/')
-
-
-
-
-
-
-class gs2_param:
-    def __init__(self, var='', dim=np.array([]), in_list='', func=None):
-        self.name = var
-        self.dim = dim
-        self.namelist = in_list
-        self.func = func
-
-
-
-
-
-def add_param_to_scan(scan, name, dim, namelist, scandim, func):
-    newparam = gs2_param(name, dim, namelist, func)
-    if scandim == ONE:
-        scan[ONE].append(newparam)
-    elif scandim == TWO:
-        scan[TWO].append(newparam)
-    else:
-        sys.exit('ERROR: this code only supports up to '+NDIM_MAX+' dimensions for a scan.')
-
-
-
-
-
-def increment_dim(scandim):
-    if scandim == ONE:
-        scandim = TWO
-    else:
-        scandim = END
-    return scandim
-
-
-
-
-
-def read_data(fname, valtree, scandim, ival_firstdim, dmid_list_vs_v2_ky, itheta0_list_vs_v2_ky, theta0_vs_v2_ky, \
-        firstdim_vs_v2_ky, gamma_avg_vs_v2_ky, gamma_avg_fromSum_vs_v2_ky, gamma_max_vs_v2_ky, gamma_max_fromSum_vs_v2_ky, \
-        Qratio_avg_vs_v2_ky, g_exb_vs_v2_ky, \
-        gamma_inst_vs_v2_ky, gamma_inst_fromSum_vs_v2_ky, theta0_star_for_inst_vs_v2_ky):
-
-    # Iterate over every set of values taken by parameters in this dimension of the scan.
-    for ival in range(scan[scandim][0].dim):
-    
-        # Name-base and patch to be modified for this ival.
-        my_fname = fname
-
-        # For every new value of firstdim, append elements
-        if scandim==ONE and ival_firstdim!=ival:
-            ival_firstdim = ival
-            g_exb_vs_v2_ky.append([])
-            dmid_list_vs_v2_ky.append([])
-            itheta0_list_vs_v2_ky.append([])
-            theta0_vs_v2_ky.append([])
-            theta0_star_for_inst_vs_v2_ky.append([])
-            firstdim_vs_v2_ky.append([])
-            gamma_avg_vs_v2_ky.append([])
-            gamma_avg_fromSum_vs_v2_ky.append([])
-            gamma_max_vs_v2_ky.append([])
-            gamma_max_fromSum_vs_v2_ky.append([])
-            gamma_inst_vs_v2_ky.append([])
-            gamma_inst_fromSum_vs_v2_ky.append([])
-            Qratio_avg_vs_v2_ky.append([])
-
-        # For every parameter in this dimension of the scan, modify the files.
-        for iparam in range(len(scan[scandim])):
-            # Append parameter to namelist for in-file patching
-            var = scan[scandim][iparam].name
-            val = scan[scandim][iparam].func(ival,valtree)
-            # Append parameter to the filenames
-            my_fname = my_fname + '_' + var + '_' + str(val)
-            # Update history tree
-            if scandim == ONE:
-                iparam_all = iparam
-            if scandim == TWO:
-                iparam_all = len(scan[ONE]) + iparam
-            valtree[iparam_all] = val
-        
-        # If we are at the bottom of the tree, then read from the file.
-        if scandim == ndim:
-            my_vars = read_from_file(my_fname)
-            g_exb_vs_v2_ky[ival_firstdim].append(my_vars['g_exb'])
-            dmid_list_vs_v2_ky[ival_firstdim].append(my_vars['dmid_list'])
-            itheta0_list_vs_v2_ky[ival_firstdim].append(my_vars['itheta0_list'])
-            theta0_vs_v2_ky[ival_firstdim].append(my_vars['theta0'])
-            firstdim_vs_v2_ky[ival_firstdim].append(my_vars[firstdim_var])
-            gamma_avg_vs_v2_ky[ival_firstdim].append(my_vars['gamma_avg'])
-            gamma_avg_fromSum_vs_v2_ky[ival_firstdim].append(my_vars['gamma_avg_fromSum'])
-            gamma_max_vs_v2_ky[ival_firstdim].append(my_vars['gamma_max'])
-            gamma_max_fromSum_vs_v2_ky[ival_firstdim].append(my_vars['gamma_max_fromSum'])
-            Qratio_avg_vs_v2_ky[ival_firstdim].append(my_vars['Qratio_avg'])
-            try:
-                gamma_inst_vs_v2_ky[ival_firstdim].append(my_vars['gamma_inst'])
-                gamma_inst_fromSum_vs_v2_ky[ival_firstdim].append(my_vars['gamma_inst_fromSum'])
-                theta0_star_for_inst_vs_v2_ky[ival_firstdim].append(my_vars['theta0_star_for_inst'])
-            except:
-                pass
-        # Or move on to the next dimension of the scan by calling function recursively
-        else:
-            next_scandim = increment_dim(scandim)
-            read_data(my_fname, valtree, next_scandim, ival_firstdim, dmid_list_vs_v2_ky, itheta0_list_vs_v2_ky, theta0_vs_v2_ky, \
-                    firstdim_vs_v2_ky, gamma_avg_vs_v2_ky, gamma_avg_fromSum_vs_v2_ky, gamma_max_vs_v2_ky, gamma_max_fromSum_vs_v2_ky, \
-                    Qratio_avg_vs_v2_ky, g_exb_vs_v2_ky, \
-                    gamma_inst_vs_v2_ky, gamma_inst_fromSum_vs_v2_ky, theta0_star_for_inst_vs_v2_ky)
-
-
-
-
-def read_from_file(fname):
-
-    datfile_name = 'postproc/' + fname + '.linbox.dat' ### USER ###
-
-    my_vars = {}
-
-    if os.path.getsize(datfile_name) > 0:
-        with open(datfile_name, 'rb') as infile: # 'rb' stands for read bytes
-            unpickler = pickle.Unpickler(infile)
-            my_vars = unpickler.load()
-            #my_vars = pickle.load(infile)
-    else:
-        print("Cannot open file: " + "'" + datfile_name + "'\n")
-
-    return my_vars
-
-
-
-
-def write_to_file(vardict):
-
-    datfile_name = 'postproc/linbox_scan.dat'
-    with open(datfile_name, 'wb') as outfile: # 'wb' stands for write bytes
-        pickle.dump(vardict,outfile)
-
-
-
-def merge_pdfs(in_namelist, out_name, out_dir):
-
-    # read all tmp pdfs to be merged
-    merger = PdfFileMerger()
-    for pdfname in in_namelist:
-        file_name = out_dir + pdfname + '.pdf'
-        with open(file_name, 'rb') as pdffile:
-            merger.append(PdfFileReader(pdffile))
-
-    # write and save output pdf
-    out_name = out_dir + out_name + '.pdf'
-    merger.write(out_name)
-
-    # remove tmp pdfs
-    for pdfname in in_namelist:
-        file_name = out_dir + pdfname
-        os.system('rm -f '+file_name)
-
-    plt.cla()
-    plt.clf()
-
-
-
-
-# Execute main
-if __name__ == '__main__':
-    main()
diff --git a/plot_misc/linrange_scan.py b/plot_misc/linrange_scan.py
deleted file mode 100644
index 235a771..0000000
--- a/plot_misc/linrange_scan.py
+++ /dev/null
@@ -1,275 +0,0 @@
-import sys
-import os
-
-# Add path to directory where scan-files are stored
-sys.path.insert(1, '/marconi/home/userexternal/nchriste/codes/scan_gs2/paramfiles')
-
-import f90nml as fnml
-import numpy as np
-import copy as cp
-import pickle
-import matplotlib.pyplot as plt
-from matplotlib import rcParams
-from math import pi
-
-plt.rc('text', usetex=True)
-plt.rc('font', family='serif')
-plt.rc('font', size=20)
-rcParams.update({'figure.autolayout': True})
-rcParams.update({'legend.fontsize': 12, 'legend.handlelength': 4})
-rcParams.update({'legend.frameon': False})
-
-ONE = 'one'
-TWO = 'two'
-NDIM_MAX = TWO
-
-# Dict that will contain every parameter to scan
-scan = {ONE:[],TWO:[]}
-
-
-
-
-
-
-# vvv User parameters vvv
-
-# Import all parameters from paramfiles/myfile.py
-base_name = 'rpsi_0.6'  
-pf = __import__('scan_linrange_coll_elec_ijp_950_rpsi_06')  
-
-# Number of dimensions in the scan
-# e.g. vs R/LTi -> ndim = ONE
-ndim = ONE
-
-# Define first dimension of the scan
-firstdim_label = '$\\nu_{ee}\ [v_{th}/a]$' # for plotting
-firstdim_var = 'vnewk' # name of variable to append to figure names
-firstdim = pf.vnewk # variable name in paramfiles/myfile.py
-
-# Apply limits to axis when plotting ?
-use_my_xlim = False
-my_xlim = (0.0, 2.0)  
-
-use_my_ylim = False
-my_ylim_max = (0.0, 0.50)
-my_ylim_avg = (-0.1, 0.15)
-
-# ^^^ User parameters ^^^
-
-
-
-
-
-
-
-def main():
-
-
-    # Add all parameters to the current scan
-
-    nparams = len(pf.name)
-    for iparam in range(nparams):
-        add_param_to_scan(scan, pf.name[iparam], pf.dim[iparam], pf.namelist[iparam], pf.scandim[iparam], pf.func[iparam])
-
-
-    # Read data from .dat files for every file in scan
-
-    tt0_collec = []
-    ky_collec = []
-    gamma_collec = []
-    omega_collec = []
-    qe_vs_qi_collec = []
-    scandim=ONE
-    valtree = [0*i for i in range(nparams)]
-    read_data(base_name, valtree, scandim, tt0_collec, ky_collec, gamma_collec, omega_collec, qe_vs_qi_collec)
-
-
-    # Save data for whole scan in file
-
-    vardict = {}
-    vardict['tt0_collec'] = tt0_collec
-    vardict['ky_collec'] = ky_collec
-    vardict['gamma_collec'] = gamma_collec
-    vardict['omega_collec'] = omega_collec
-    vardict['qe_vs_qi_collec'] = qe_vs_qi_collec
-    write_to_file(vardict)
-
-
-
-
-
-    # Plotting
-
-    naky = gamma_collec[0].shape[0]
-    ntt0 = gamma_collec[0].shape[1]
-    valdim = firstdim.size
-
-    # Check whether to plot vs ky, theta0, or both.
-    # Squeeze out unsuseful dimensions.
-    if ntt0 > 1 and naky > 1:
-        plot1d = False
-        plot2d = True
-    else:
-        if ntt0 > 1:
-            xlabel = '$\\theta_0$'
-            xvar = 'theta0'
-            xvar_collec = tt0_collec
-        else:
-            xlabel = '$k_y\\rho_i$'
-            xvar = 'ky'
-            xvar_collec = ky_collec
-        for ival in range(valdim):
-            gamma_collec[ival] = np.squeeze(gamma_collec[ival])
-            omega_collec[ival] = np.squeeze(omega_collec[ival])
-        plot1d = True
-        plot2d = False
-
-
-    # Plots vs xvar
-
-    if plot1d:
-
-        color_collec = plt.cm.gnuplot_r(np.linspace(0.05,0.9,firstdim.size))
-
-
-        # Plot gamma vs xvar
-
-        pdfname = 'postproc/linrange_gamma_scan_'+firstdim_var+'_vs_'+xvar+'.pdf'
-        plt.figure()
-        my_legend = []
-        plt.grid(True)
-        plt.xlabel(xlabel)
-        plt.ylabel('$\\gamma\ [v_{th}/a]$')
-        valdim = firstdim.size
-        for ival in range(valdim):
-            plt.plot(xvar_collec[ival], gamma_collec[ival], linewidth=2.0, color=color_collec[ival])
-            my_legend.append(firstdim_label+'$ = '+str(firstdim[ival])+'$')
-        if use_my_ylim:
-            plt.ylim(my_ylim_avg)
-        if use_my_xlim:
-            plt.xlim(my_xlim)
-        legend = plt.legend(my_legend, frameon = True, fancybox = False, fontsize=10)
-        frame = legend.get_frame()
-        frame.set_facecolor('white')
-        frame.set_edgecolor('black')
-        frame.set_linewidth(0.5)
-        frame.set_alpha(1)
-        plt.savefig(pdfname)
-
-        
-        # Plot real frequency vs xvar
-
-        pdfname = 'postproc/linrange_omega_scan_'+firstdim_var+'_vs_'+xvar+'.pdf'
-        plt.figure()
-        my_legend = []
-        plt.grid(True)
-        plt.xlabel(xlabel)
-        plt.ylabel('$\\omega\ [v_{th}/a]$')
-        valdim = firstdim.size
-        for ival in range(valdim):
-            plt.plot(xvar_collec[ival], omega_collec[ival], linewidth=2.0, color=color_collec[ival])
-            my_legend.append(firstdim_label+'$ = '+str(firstdim[ival])+'$')
-        if use_my_ylim:
-            plt.ylim(my_ylim_avg)
-        if use_my_xlim:
-            plt.xlim(my_xlim)
-        legend = plt.legend(my_legend, frameon = True, fancybox = False)
-        frame = legend.get_frame()
-        frame.set_facecolor('white')
-        frame.set_edgecolor('black')
-        frame.set_linewidth(0.5)
-        frame.set_alpha(1)
-        plt.savefig(pdfname)
-
-
-        # Plot Qe/Qi vs first scan dimension
-
-        pdfname = 'postproc/linrange_qe_vs_qi_scan_'+firstdim_var+'.pdf'
-        plt.figure()
-        my_legend = []
-        plt.grid(True)
-        plt.xlabel(firstdim_label)
-        plt.ylabel('$\\langle Q_e/Q_i \\rangle_t$')
-        plt.plot(firstdim , qe_vs_qi_collec, linewidth=2.0, color='k')
-        plt.savefig(pdfname)
-
-
-
-
-
-class gs2_param:
-    def __init__(self, var='', dim=np.array([]), in_list='', func=None):
-        self.name = var
-        self.dim = dim
-        self.namelist = in_list
-        self.func = func
-
-def add_param_to_scan(scan, name, dim, namelist, scandim, func):
-    newparam = gs2_param(name, dim, namelist, func)
-    if scandim == ONE:
-        scan[ONE].append(newparam)
-    elif scandim == TWO:
-        scan[TWO].append(newparam)
-    else:
-        sys.exit('ERROR: this code only supports up to '+NDIM_MAX+' dimensions for a scan.')
-
-def increment_dim(scandim):
-    if scandim == ONE:
-        scandim = TWO
-    else:
-        scandim = END
-    return scandim
-
-def read_data(fname, valtree, scandim, tt0_collec, ky_collec, gamma_collec, omega_collec, qe_vs_qi_collec):
-
-    # Iterate over every set of values taken by parameters in this dimension of the scan.
-    for ival in range(scan[scandim][0].dim):
-    
-        # Name-base and patch to be modified for this ival.
-        my_fname = fname
-
-        # For every parameter in this dimension of the scan, modify the files.
-        for iparam in range(len(scan[scandim])):
-            # Append parameter to namelist for in-file patching
-            var = scan[scandim][iparam].name
-            val = scan[scandim][iparam].func(ival,valtree)
-            # Append parameter to the filenames
-            my_fname = my_fname + '_' + var + '_' + str(val)
-            # Update history tree
-            if scandim == ONE:
-                iparam_all = iparam
-            if scandim == TWO:
-                iparam_all = len(scan[ONE]) + iparam
-            valtree[iparam_all] = val
-        
-        # If we are at the bottom of the tree, then read from the file.
-        if scandim == ndim:
-            [tt0,ky,gamma,omega,Qratio_avg] = read_from_file(my_fname)
-            tt0_collec.append(tt0)
-            ky_collec.append(ky)
-            gamma_collec.append(gamma)
-            omega_collec.append(omega)
-            qe_vs_qi_collec.append(Qratio_avg)
-        # Or move on to the next dimension of the scan by calling function recursively
-        else:
-            next_scandim = increment_dim(scandim)
-            read_data(my_fname, valtree, next_scandim, tt0_collec, ky_collec, gamma_collec, omega_collec, qe_vs_qi_collec)
-
-def read_from_file(fname):
-
-    datfile_name = 'postproc/' + fname + '.linrange.dat' ### USER ###
-
-    with open(datfile_name, 'rb') as infile: # 'rb' stands for read bytes
-        my_vars = pickle.load(infile)
-
-    return my_vars
-
-def write_to_file(vardict):
-
-    datfile_name = 'postproc/linscan.dat'
-    with open(datfile_name, 'wb') as outfile: # 'wb' stands for write bytes
-        pickle.dump(vardict,outfile)
-
-# Execute main
-if __name__ == '__main__':
-    main()
diff --git a/tasks/__pycache__/boxballoon.cpython-36.pyc b/tasks/__pycache__/boxballoon.cpython-36.pyc
deleted file mode 100644
index 6bde7fd..0000000
Binary files a/tasks/__pycache__/boxballoon.cpython-36.pyc and /dev/null differ
diff --git a/tasks/__pycache__/flowtest.cpython-36.pyc b/tasks/__pycache__/flowtest.cpython-36.pyc
deleted file mode 100644
index 69b09b7..0000000
Binary files a/tasks/__pycache__/flowtest.cpython-36.pyc and /dev/null differ
diff --git a/tasks/__pycache__/fluxes.cpython-36.pyc b/tasks/__pycache__/fluxes.cpython-36.pyc
deleted file mode 100644
index 3117635..0000000
Binary files a/tasks/__pycache__/fluxes.cpython-36.pyc and /dev/null differ
diff --git a/tasks/__pycache__/linbox.cpython-36.pyc b/tasks/__pycache__/linbox.cpython-36.pyc
deleted file mode 100644
index 9a2df87..0000000
Binary files a/tasks/__pycache__/linbox.cpython-36.pyc and /dev/null differ
diff --git a/tasks/__pycache__/linrange.cpython-36.pyc b/tasks/__pycache__/linrange.cpython-36.pyc
deleted file mode 100644
index 434ab43..0000000
Binary files a/tasks/__pycache__/linrange.cpython-36.pyc and /dev/null differ
diff --git a/tasks/__pycache__/plot_phi2_vs_time.cpython-36.pyc b/tasks/__pycache__/plot_phi2_vs_time.cpython-36.pyc
deleted file mode 100644
index 54aa8c1..0000000
Binary files a/tasks/__pycache__/plot_phi2_vs_time.cpython-36.pyc and /dev/null differ
diff --git a/tasks/__pycache__/plot_zonal_phikx_t.cpython-36.pyc b/tasks/__pycache__/plot_zonal_phikx_t.cpython-36.pyc
deleted file mode 100644
index 1d14b21..0000000
Binary files a/tasks/__pycache__/plot_zonal_phikx_t.cpython-36.pyc and /dev/null differ
diff --git a/tasks/__pycache__/potential.cpython-36.pyc b/tasks/__pycache__/potential.cpython-36.pyc
deleted file mode 100644
index cf9248f..0000000
Binary files a/tasks/__pycache__/potential.cpython-36.pyc and /dev/null differ
diff --git a/tasks/__pycache__/time_correlation.cpython-36.pyc b/tasks/__pycache__/time_correlation.cpython-36.pyc
deleted file mode 100644
index 084a0cd..0000000
Binary files a/tasks/__pycache__/time_correlation.cpython-36.pyc and /dev/null differ
diff --git a/tasks/__pycache__/zonal.cpython-36.pyc b/tasks/__pycache__/zonal.cpython-36.pyc
deleted file mode 100644
index 6fbcfec..0000000
Binary files a/tasks/__pycache__/zonal.cpython-36.pyc and /dev/null differ
diff --git a/tasks/floquet_orig.py b/tasks/floquet_orig.py
new file mode 100644
index 0000000..0d4425d
--- /dev/null
+++ b/tasks/floquet_orig.py
@@ -0,0 +1,1059 @@
+from matplotlib import pyplot as plt
+from matplotlib.ticker import FormatStrFormatter
+import matplotlib.animation as anim
+import numpy as np
+from math import pi
+from math import ceil
+import imageio
+import os
+import sys
+#TESTpickle
+#import scipy.io
+import pickle
+from PyPDF2 import PdfFileMerger, PdfFileReader
+import scipy.interpolate as scinterp
+import scipy.optimize as opt
+
+import gs2_plotting as gplots
+
+################################################################################
+# A twist and shift chain is identified by it, iky and dmid = 0, ..., min(jtwist-1, (nakx-1)//2)
+# which is the number of dkx between kx=0 and the smallest kx>0 that is a member of the chain.
+################################################################################
+
+################################################################################
+# main
+################################################################################
+
+def my_task_single(ifile, run, myin, myout, task_space):  
+
+    #
+    # User parameters
+    #
+    
+    # select chains
+    naky = (myin['kt_grids_box_parameters']['ny']-1)//3 + 1
+    iky_list = [i for i in range(1,naky)] # [-1] means all nonzero ky
+    #iky_list = [1] # NDCTEST
+    if iky_list==[-1]:
+        iky_list = [i for i in range(1,myout['ky'].size)]
+    my_dmid = 0 # we include kxbar=my_dmid*dkx in our chain
+
+    # Select time index for plot of phi vs ballooning angle
+    #my_it = [10*i+3000 for i in range(6)]
+    my_it = [-1]
+
+    # make movies of phi and growthrate along ballooning angle ?
+    make_movies = False
+
+    #
+    #
+    #
+
+    print('\n\n----------------------------------------')
+    print('Starting single task : Floquet ...\n')
+
+    my_vars = []
+
+    if run.only_plot:
+        
+        my_vars = read_from_dat(ifile, run)
+
+    else:
+        
+        my_vars = process_and_save_to_dat(ifile, run, myin, myout, my_dmid, iky_list)
+        
+    store_for_task_scan(my_vars, task_space)
+
+    if not run.no_plot:
+
+        plot_task_single(ifile, run, my_vars, my_it, my_dmid, make_movies)
+
+
+    print('\n... single task completed.')
+
+
+def process_and_save_to_dat(ifile, run, myin, myout, my_dmid, iky_list):
+
+    plot_against_theta0_star = True # NDCPARAM
+
+    t = myout['t']
+    delt = myin['knobs']['delt']
+    print('Time step size : ' + str(delt))
+    nt = t.size
+    nwrite = myin['gs2_diagnostics_knobs']['nwrite']
+    print('nwrite : ' + str(nwrite))
+
+    theta = myout['theta']
+    ntheta = theta.size
+    theta0 = myout['theta0']
+    
+    g_exb = myin['dist_fn_knobs']['g_exb']
+    shat = myin['theta_grid_parameters']['shat']
+    jtwist = int(myin['kt_grids_box_parameters']['jtwist'])
+    
+    # Floquet period
+    if g_exb != 0.0:
+        Tf = abs(2*pi*shat/g_exb)
+        print('Floquet period : ' + str(Tf))
+    else:
+        Tf = np.nan
+    # number of t-steps in Floquet period
+    if g_exb != 0.0:
+        Nf = int(round(Tf/delt))
+        print('Number of t-steps in Floquet period : ' + str(Nf))
+    else:
+        Nf = np.nan
+
+    kx_gs2 = myout['kx']
+    ky = myout['ky']
+    dky = 1./myin['kt_grids_box_parameters']['y0']
+    dkx = 2.*pi*abs(shat)*dky/jtwist
+    nakx = kx_gs2.size
+    naky = ky.size
+    ikx_max = int(round((nakx-1)/2))
+    ikx_min = ikx_max+1
+    
+    # number of t-steps before ExB re-map
+    if g_exb != 0.0:
+        N = max(1, abs(int(round(dkx/(g_exb*delt*dky)))))
+        print('Number of t-steps before ExB re-map : ' + str(N))
+    else:
+        N = np.nan
+
+    phi2_gs2 = myout['phi2_by_mode'][:,:,:]
+    omega_gs2 = myout['omega_average'][:,:,:,0] # real frequency
+
+    phi_t_present = myout['phi_t_present']
+    if phi_t_present:
+        phi2_bytheta_gs2 = np.sum(np.power(myout['phi_t'],2), axis=4)
+   
+    # sorting kx_gs2 to get monotonic kx_bar
+    kx_bar = np.concatenate((kx_gs2[ikx_min:],kx_gs2[:ikx_min]))
+    phi2 = np.concatenate((phi2_gs2[:,:,ikx_min:], phi2_gs2[:,:,:ikx_min]), axis=2)
+    omega = np.concatenate((omega_gs2[:,:,ikx_min:], omega_gs2[:,:,:ikx_min]), axis=2)
+    if phi_t_present:
+        phi2_bytheta = np.concatenate((phi2_bytheta_gs2[:,:,ikx_min:,:], phi2_bytheta_gs2[:,:,:ikx_min,:]), axis=2)
+
+    # get kx and kx_star from kx_bar
+    kx = np.zeros((nt,naky,nakx))
+    kx_star = np.zeros((nt,naky,nakx))
+    # @ it = 0, kx = kx_bar
+    # First step is taken with 0.5*dt
+    # Other steps taken with full dt
+    for it in range(1,nt):
+        for iky in range(naky):
+            ikx_shift = int(round(g_exb*ky[iky]*delt*(nwrite*it-0.5)/dkx))
+            for ikx in range(nakx):
+                kx[it,iky,ikx] = kx_bar[ikx] + ikx_shift*dkx
+                kx_star[it,iky,ikx] = kx[it,iky,ikx] - g_exb*ky[iky]*delt*(nwrite*it-0.5)
+ 
+    # index of kx=0
+    ikx0 = (nakx-1)//2
+    
+    #
+    # In the following :
+    # -- compute sum of phi2 along that chain and store in sum_phi2_chain[it]
+    # -- compute ballooning angle and store in bloonang_chain[it][ibloon]
+    # -- construct associated phi2 and store in phi2bloon_chain[it][ibloon]
+    # -- compute associated growthrate gamma, such that :
+    #        phinew = phi * exp(-i*omega*delt)
+    #        gamma = Im(omega)
+    #    and store in gamma_chain[it][ibloon]
+    #
+    
+    ikx_members = []
+    ikx_prevmembers = []
+    bloonang = []
+    bloonang_bndry = []
+    phi2bloon = []
+    phi2bloon_discont = []
+    phi2bloon_jump = []
+    sum_phi2bloon = []
+    max_phi2bloon = []
+    omegabloon = []
+    kxbarbloon = []
+    gamma = []
+    kx_star_for_gamma = []
+
+    for iky in iky_list:
+
+        ikx_members_chain = []
+        ikx_prevmembers_chain = []
+        bloonang_chain = []
+        bloonang_bndry_chain = []
+        phi2bloon_chain = []
+        phi2bloon_discont_chain = []
+        phi2bloon_jump_chain = []
+        sum_phi2bloon_chain = []
+        max_phi2bloon_chain = []
+        gamma_chain = []
+        omegabloon_chain = []
+        kxbarbloon_chain = []
+        kx_star_for_gamma_chain = []
+
+        iTf = 0
+        gamma_floq = []
+        kx_star_for_gamma_floq = []
+
+        for it in range(nt):
+            #NDCTEST
+            # To test if initial condition satisfies parallel BC. Apparently does not when shat<0.
+            #if iky==1 and it<10:
+            #    print('---------------------')
+            #    print('FOR TEST')
+            #    print('phi2(-pi) = ')
+            #    print(phi2_bytheta[it,iky,:,0])
+            #    print('phi2(+pi) = ')
+            #    print(phi2_bytheta[it,iky,:,-1])
+            #    if shat>0.:
+            #        print('phi_l = '+str(phi2_bytheta[it,iky,-1,-1])) # phi_l
+            #        print('phi_r = '+str(phi2_bytheta[it,iky,-2,0])) # phi_r
+            #    else:
+            #        # correct
+            #        print('phi_l = '+str(phi2_bytheta[it,iky,-1,0])) # phi_l
+            #        print('phi_r = '+str(phi2_bytheta[it,iky,-2,-1])) # phi_r
+            #    print('---------------------')
+            #endNDCTEST
+
+            ikx_members_now = []
+            ikx_prevmembers_now = []
+            bloonang_now = []
+            bloonang_bndry_now = []
+            phi2bloon_now = []
+            phi2bloon_discont_now = []
+            phi2bloon_jump_now = []
+            sum_phi2bloon_now = 0
+            omegabloon_now = []
+            kxbarbloon_now = []
+
+            # BLACK MAGIC LINE :
+            # if the position of delt and it are swapped in the following multiplication,
+            # the resulting ikx_shift can be different ! (e.g. it=297 for ~/gs2/flowtest/dkx_scan/dkx_2.in)
+            if it==0:
+                ikx_shift = 0
+                ikx_shift_old = 0
+            elif it==1:
+                ikx_shift = int(round(g_exb*ky[iky]*delt*(nwrite*it-0.5)/dkx))
+                ikx_shift_old = 0
+            else:
+                ikx_shift = int(round(g_exb*ky[iky]*delt*(nwrite*it-0.5)/dkx))
+                ikx_shift_old = int(round(g_exb*ky[iky]*delt*(nwrite*(it-1)-0.5)/dkx))
+
+            print('t =',delt*(nwrite*it-0.5)) # NDCTEST
+            print('kx_shift =',-1.*g_exb*ky[iky]*delt*(nwrite*it-0.5)+dkx*ikx_shift) # NDCTEST
+            print('ikx_shift =',ikx_shift) # NDCTEST
+    
+            # Build collection of ikx's that are included
+            # in the chain at time step it (ikx_members_now)
+            # and at time step it-1 (ikx_prevmembers_now).
+
+            # ikx such that our chain includes kxstar(t=0) = dmid*dkx
+            ikx = ikx0 - ikx_shift + my_dmid
+            ikxprev = ikx0 - ikx_shift_old + my_dmid
+
+            while (ikx >= nakx): # moving from right to first connected kx within the set in GS2
+                ikx = ikx-jtwist*iky
+                ikxprev = ikxprev-jtwist*iky
+            while (ikx >= 0):
+                ikx_members_now.append(ikx)
+                if ikxprev >= nakx:
+                    ikx_prevmembers_now.append(np.nan)
+                elif ikxprev < 0:
+                    ikx_prevmembers_now.append(np.nan)
+                else:
+                    ikx_prevmembers_now.append(ikxprev)
+                sum_phi2bloon_now = sum_phi2bloon_now + phi2[it,iky,ikx]                    
+                ikx = ikx-jtwist*iky
+                ikxprev = ikxprev-jtwist*iky
+
+            ikx = ikx0 - ikx_shift + my_dmid + jtwist*iky
+            ikxprev = ikx0 - ikx_shift_old + my_dmid + jtwist*iky
+            while (ikx < 0): # moving from left to first connected kx within the set in GS2
+                ikx = ikx+jtwist*iky
+                ikxprev = ikxprev+jtwist*iky
+            while (ikx < nakx):
+                ikx_members_now.append(ikx)
+                if ikxprev >= nakx:
+                    ikx_prevmembers_now.append(np.nan)
+                elif ikxprev < 0:
+                    ikx_prevmembers_now.append(np.nan)
+                else:
+                    ikx_prevmembers_now.append(ikxprev)
+                sum_phi2bloon_now = sum_phi2bloon_now + phi2[it,iky,ikx]
+                ikx = ikx+jtwist*iky
+                ikxprev = ikxprev+jtwist*iky
+
+            # sort ikx of chain members at time it in left-to-right order (shat>0: descending, shat<0: ascending)
+            # sort time it-1 accordingly
+            idx_sort = sorted(range(len(ikx_members_now)), key=lambda k: ikx_members_now[k],reverse=(shat>0.))
+            ikx_members_now = [ikx_members_now[idx] for idx in idx_sort]
+            ikx_prevmembers_now = [ikx_prevmembers_now[idx] for idx in idx_sort]
+
+            if phi_t_present:
+
+                member_range = range(len(ikx_members_now))
+                
+                # compute ballooning angle and construct associated phi2
+                for imember in member_range:
+                    for itheta in range(ntheta):
+                        if plot_against_theta0_star:
+                            b_ang = theta[itheta] - kx_star[it,iky,ikx_members_now[imember]]/(shat*ky[iky])
+                        else:
+                            b_ang = theta[itheta] - kx[it,iky,ikx_members_now[imember]]/(shat*ky[iky])
+                        bloonang_now.append(b_ang)
+                        phi2bloon_now.append(phi2_bytheta[it,iky,ikx_members_now[imember],itheta])
+                
+                # construct chain of real frequency
+                for imember in member_range:
+                    omegabloon_now.append(omega[it,iky,ikx_members_now[imember]])
+                    kxbarbloon_now.append(kx_bar[ikx_members_now[imember]])
+
+                # Saving discontinuities and bloonang at link position to plot later
+                member_range = range(len(ikx_members_now)-1)
+                for imember in member_range:
+                    phi2_l = phi2_bytheta[it,iky,ikx_members_now[imember],-1]
+                    phi2_r = phi2_bytheta[it,iky,ikx_members_now[imember+1],0]
+                    discont = abs(phi2_r-phi2_l)
+                    phi2bloon_discont_now.append(discont)
+                    jump = abs((phi2_r-phi2_l)/max(phi2_l,phi2_r))
+                    phi2bloon_jump_now.append(jump)
+                    b_ang_bndry = pi-kx_star[it,iky,ikx_members_now[imember]]/(shat*ky[iky])
+                    bloonang_bndry_now.append(b_ang_bndry)
+
+                # Computing 'growthrate' for every kxstar present in the chain
+                if it>0 and g_exb != 0.0:
+                    # index of the Floquet oscillation we are in
+                    iTf_new = int(round(delt*(it*nwrite-0.5)/Tf))
+                    # If we enter the next Floquet oscillation,
+                    # append gamma to gamma_chain
+                    # and start working with new oscillation.
+                    if iTf_new > iTf:
+                        # Oh dare ! -- J. Bercow, 2019
+                        idx_sort = [i[0] for i in sorted(enumerate(kx_star_for_gamma_floq), key=lambda x:x[1])]
+                        kx_star_for_gamma_floq = [kx_star_for_gamma_floq[i] for i in idx_sort]
+                        gamma_floq = [gamma_floq[i] for i in idx_sort]
+                        # and append
+                        gamma_chain.append(gamma_floq)
+                        kx_star_for_gamma_chain.append(kx_star_for_gamma_floq)
+                        gamma_floq = []
+                        kx_star_for_gamma_floq = []
+                        iTf = iTf_new
+                    for imember in range(len(ikx_members_now)):
+                        ikx = ikx_members_now[imember]
+                        ikxprev = ikx_prevmembers_now[imember]
+                        kx_star_for_gamma_floq.append(kx_star[it,iky,ikx])
+                        if not np.isnan(ikxprev):
+                            gam = 1./(2.*nwrite*delt) * np.log( \
+                                    np.amax(phi2_bytheta[it,iky,ikx,:]) / np.amax(phi2_bytheta[it-1,iky,ikxprev,:]) )
+                            gamma_floq.append(gam)
+                        else:
+                            gamma_floq.append(np.nan)
+
+            ikx_members_chain.append(ikx_members_now)
+            ikx_prevmembers_chain.append(ikx_prevmembers_now)
+            bloonang_chain.append(bloonang_now)
+            bloonang_bndry_chain.append(bloonang_bndry_now)
+            phi2bloon_chain.append(phi2bloon_now)
+            phi2bloon_discont_chain.append(phi2bloon_discont_now)
+            phi2bloon_jump_chain.append(phi2bloon_jump_now)
+            sum_phi2bloon_chain.append(sum_phi2bloon_now)
+            omegabloon_chain.append(omegabloon_now)
+            kxbarbloon_chain.append(kxbarbloon_now)
+            max_phi2bloon_chain.append(max(phi2bloon_now))
+    
+        # Adding the chain to the full collection
+        ikx_members.append(ikx_members_chain)
+        ikx_prevmembers.append(ikx_prevmembers_chain)
+        bloonang.append(bloonang_chain)
+        bloonang_bndry.append(bloonang_bndry_chain)
+        phi2bloon.append(phi2bloon_chain)
+        phi2bloon_discont.append(phi2bloon_discont_chain)
+        phi2bloon_jump.append(phi2bloon_jump_chain)
+        sum_phi2bloon.append(sum_phi2bloon_chain)
+        max_phi2bloon.append(max_phi2bloon_chain)
+        omegabloon.append(omegabloon_chain)
+        kxbarbloon.append(kxbarbloon_chain)
+        if g_exb != 0.0:
+            kx_star_for_gamma.append(kx_star_for_gamma_chain)
+            gamma.append(gamma_chain)
+
+    if g_exb==0.0:
+        it_start = round(0.5*nt)
+        gamma = np.zeros((nakx,len(iky_list)))
+        tofit_sq = np.amax(phi2_bytheta,axis=3) # take the max in theta for each 2pi segment
+        for ikx in range(nakx):
+            for iiky in range(len(iky_list)):
+                iky = iky_list[iiky]
+                gam = get_growthrate(t,tofit_sq[:,iky,ikx],it_start)
+                gam = gam/2. # because we fitted the square
+                gamma[ikx,iiky] = gam
+
+    # Saving variables to mat-file
+    my_vars = {}
+    my_vars['Nf'] = Nf
+    my_vars['t'] = t
+    my_vars['delt'] = delt
+    my_vars['nwrite'] = nwrite
+    my_vars['shat'] = shat
+    my_vars['g_exb'] = g_exb
+    my_vars['kx'] = kx
+    my_vars['ky'] = ky
+    my_vars['dkx'] = dkx
+    my_vars['jtwist'] = jtwist
+    my_vars['iky_list'] = iky_list
+    my_vars['nakx'] = nakx
+    my_vars['kx_bar'] = kx_bar
+    my_vars['kx_star'] = kx_star
+    my_vars['phi2'] = phi2
+    my_vars['phi_t_present'] = phi_t_present
+    my_vars['ikx_members'] = ikx_members
+    my_vars['ikx_prevmembers'] = ikx_prevmembers
+    my_vars['bloonang'] = bloonang
+    my_vars['bloonang_bndry'] = bloonang_bndry
+    my_vars['phi2bloon'] = phi2bloon
+    my_vars['phi2bloon_discont'] = phi2bloon_discont
+    my_vars['phi2bloon_jump'] = phi2bloon_jump
+    my_vars['sum_phi2bloon'] = sum_phi2bloon
+    my_vars['max_phi2bloon'] = max_phi2bloon
+    my_vars['omegabloon'] = omegabloon
+    my_vars['kxbarbloon'] = kxbarbloon
+    my_vars['gamma'] = gamma
+    my_vars['kx_star_for_gamma'] = kx_star_for_gamma
+
+    #TESTpickle
+    #mat_file_name = run.out_dir + run.fnames[ifile] + '.floquet.mat'
+    #scipy.io.savemat(mat_file_name, my_vars)
+    datfile_name = run.out_dir + run.fnames[ifile] + '.floquet.dat'
+    with open(datfile_name, 'wb') as outfile: # 'wb' stands for write bytes
+        pickle.dump(my_vars,outfile)
+
+    return my_vars
+
+
+################################################################################
+# reading Floquet variables from mat-file
+################################################################################
+
+#TESTpickle
+#def read_from_mat(ifile, run):
+#
+#    mat_file_name = run.out_dir + run.fnames[ifile] + '.floquet.mat'
+#
+#    my_vars = scipy.io.loadmat(mat_file_name, squeeze_me=True)
+#
+#    return my_vars
+def read_from_dat(ifile, run):
+
+    datfile_name = run.out_dir + run.fnames[ifile] + '.floquet.dat'
+
+    with open(datfile_name, 'rb') as infile: # 'rb' stands for read bytes
+        my_vars = pickle.load(infile)
+
+    return my_vars
+
+
+################################################################################
+# plotting
+################################################################################
+    
+def plot_task_single(ifile, run, my_vars, my_it, my_dmid, make_movies):
+        
+    Nf = my_vars['Nf']
+    t = my_vars['t']
+    delt = my_vars['delt']
+    nwrite = my_vars['nwrite']
+    shat = my_vars['shat']
+    g_exb = my_vars['g_exb']
+    kx = my_vars['kx']
+    ky = my_vars['ky']
+    dkx = my_vars['dkx']
+    jtwist = my_vars['jtwist']
+    iky_list = my_vars['iky_list']
+    nakx = my_vars['nakx']
+    kx_bar = my_vars['kx_bar']
+    kx_star = my_vars['kx_star']
+    phi2 = my_vars['phi2']
+    phi_t_present = my_vars['phi_t_present']
+    ikx_members = my_vars['ikx_members']
+    ikx_prevmembers = my_vars['ikx_prevmembers']
+    bloonang = my_vars['bloonang']
+    bloonang_bndry = my_vars['bloonang_bndry']
+    phi2bloon = my_vars['phi2bloon']
+    phi2bloon_discont = my_vars['phi2bloon_discont']
+    phi2bloon_jump = my_vars['phi2bloon_jump']
+    sum_phi2bloon = my_vars['sum_phi2bloon']
+    max_phi2bloon = my_vars['max_phi2bloon']
+    omegabloon = my_vars['omegabloon']
+    kxbarbloon = my_vars['kxbarbloon']
+    kx_star_for_gamma = my_vars['kx_star_for_gamma']
+    gamma = my_vars['gamma']
+    
+    Tf = Nf*delt
+    nt = t.size
+
+    myfig = plt.figure(figsize=(12,8))
+
+    # Plot sum and max of phi2 vs time for every ky
+    # Fit each curve and plot gamma_avg vs ky
+
+    # Start comparing simulations at time-step it_start = N_start*Tfloquet/dt
+    # ie after N_start Floquet oscillations
+    # Normalise sum_phi2 by sum_phi2[it_start] for each run
+    skip_init = False # Start plotting at it=it_start, instead of it=0
+    if g_exb != 0.0:
+        N_start = 0 #30 # adapt this
+        it_start = int(round((N_start*Tf/delt)/nwrite))
+    else:
+        fac = 0.0 # adapt this
+        it_start = round(fac*nt) # adapt this
+
+    t_collec = []
+    sum_phi2_collec = []
+    max_phi2_collec = []
+    
+    # Compute <gamma>_t
+    slope_sum = np.zeros(len(iky_list))
+    slope_max = np.zeros(len(iky_list))
+    offset_max = np.zeros(len(iky_list))
+    for iiky in range(len(iky_list)):
+        sum_phi2_tmp = np.zeros(len(sum_phi2bloon[iiky])-it_start)
+        max_phi2_tmp = np.zeros(len(sum_phi2bloon[iiky])-it_start)
+        for it in range(sum_phi2_tmp.size):
+            sum_phi2_tmp[it] = sum_phi2bloon[iiky][it_start+it]
+            max_phi2_tmp[it] = max_phi2bloon[iiky][it_start+it]
+        if it_start > 0:
+            sum_phi2_tmp = sum_phi2_tmp/sum_phi2_tmp[0]
+            max_phi2_tmp = max_phi2_tmp/max_phi2_tmp[0]
+        sum_phi2_collec.append(sum_phi2_tmp)
+        max_phi2_collec.append(max_phi2_tmp)
+        
+        t_tmp = np.zeros(len(t)-it_start)
+        for it in range(t_tmp.size):
+            t_tmp[it] = t[it_start+it]
+        t_collec.append(t_tmp)
+
+        [gam,dummy] = leastsq_lin(t_tmp,np.log(sum_phi2_tmp))
+        slope_sum[iiky] = gam/2. # divide by 2 because fitted square
+        [gam,offset] = leastsq_lin(t_tmp,np.log(max_phi2_tmp))
+        slope_max[iiky] = gam/2. # divide by 2 because fitted square
+        offset_max[iiky] = offset
+    # At this point:
+    # fit_avg(t) ~ phi2(tstart) * exp[2*gam*t + offset]
+
+    # Compute gamma_max from ln(phi2_max)
+    it_gamma_max = np.zeros(len(iky_list))
+    gamma_max = np.zeros(len(iky_list))
+    for iiky in range(len(iky_list)):
+        # Start looking for derivatives one Floquet period before last time-step
+        it_start_last_floq = int(len(max_phi2bloon[iiky]) - Tf//(delt*nwrite) - 1)
+        it_end_last_floq = int(len(max_phi2bloon[iiky]) - 1)
+        for it in range(it_start_last_floq, it_end_last_floq):
+            # Factor of 0.5 because we fit phi^2
+            gamma_max_tmp = 0.5 * 1./(2*delt*nwrite) * \
+                    ( np.log(max_phi2bloon[iiky][it+1]) - np.log(max_phi2bloon[iiky][it-1]) )
+            if (gamma_max_tmp > gamma_max[iiky]):
+                it_gamma_max[iiky] = it
+                gamma_max[iiky] = gamma_max_tmp
+    it_gamma_max = it_gamma_max.astype(int)
+    # At this point:
+    # fit_max(t) ~ phi2(tstart) * exp[2*gamma_max*(t-t_gamma_max)]
+
+    # Save growthrates to dat-file
+    my_vars = {}
+    my_vars['ky'] = ky[1:]
+    my_vars['gamma_avg'] = slope_max
+    my_vars['gamma_max'] = gamma_max
+    datfile_name = run.out_dir + run.fnames[ifile] + '.flowshear_lingrowth.dat'
+    with open(datfile_name, 'wb') as outfile: # 'wb' stands for write bytes
+        pickle.dump(my_vars,outfile)
+    
+    plt.figure(figsize=(12,8))
+    plt.xlabel('$t$')
+    plt.ylabel('$\\log\\sum_{K_x}\\vert \\langle\\phi\\rangle_\\theta \\vert ^2$')
+    plt.grid(True)
+    my_legend = []
+    my_colorlist = plt.cm.YlOrBr(np.linspace(0.2,1,len(iky_list))) # for newalgo
+    #my_colorlist = plt.cm.YlGnBu(np.linspace(0.2,1,len(iky_list))) # for oldalgo
+    if skip_init:
+        for iiky in range(len(iky_list)):
+            my_legend.append('$k_y = {:.3f}$'.format(ky[iky_list[iiky]]))
+            #plt.semilogy(t_collec[iiky], sum_phi2_collec[iiky], color=my_colorlist[iiky], linewidth=3.0)
+            plt.plot(t_collec[iiky], np.log(sum_phi2_collec[iiky]), color=my_colorlist[iiky], linewidth=3.0)
+    else:
+        for iiky in range(len(iky_list)):
+            my_legend.append('$k_y = {:.3f}$'.format(ky[iky_list[iiky]]))
+            #plt.semilogy(t_collec[iiky], sum_phi2_collec[iiky], color=my_colorlist[iiky], linewidth=3.0)
+            plt.plot(t, np.log(sum_phi2bloon[iiky]), color=my_colorlist[iiky], linewidth=3.0)
+    plt.legend(my_legend)
+    pdfname = 'floquet_sum_vs_t_all_ky' + '_dmid_' + str(my_dmid) 
+    pdfname = run.out_dir + pdfname + '_' + run.fnames[ifile] + '.pdf'
+    plt.savefig(pdfname)
+    plt.clf()
+    plt.cla()
+
+    plt.figure(figsize=(12,8))
+    plt.xlabel('$t$')
+    plt.ylabel('$\\max_{K_x}\\vert \\langle\\phi\\rangle_\\theta \\vert ^2$')
+    plt.grid(True)
+    my_legend = []
+    my_colorlist = plt.cm.YlOrBr(np.linspace(0.2,1,len(iky_list))) # for newalgo
+    #my_colorlist = plt.cm.YlGnBu(np.linspace(0.2,1,len(iky_list))) # for oldalgo
+    if skip_init:
+        for iiky in range(len(iky_list)):
+            plt.semilogy(t_collec[iiky], max_phi2_collec[iiky], color=my_colorlist[iiky], linewidth=3.0)
+            my_legend.append('$k_y = {:.3f}$'.format(ky[iky_list[iiky]]))
+            plt.semilogy(t_collec[iiky], np.exp(2.0*slope_max[iiky]*t_collec[iiky]+offset_max[iiky]),\
+                    color=my_colorlist[iiky], linewidth=3.0, linestyle='--')
+            my_legend.append('$\\langle\\gamma\\rangle_t = {:.3f}$'.format(slope_max[iiky]))
+            bot, top = plt.ylim()
+            plt.semilogy(t_collec[iiky], max_phi2bloon[iiky][it_gamma_max[iiky]]/max_phi2bloon[iiky][it_start] * \
+                    np.exp(2.0*gamma_max[iiky]*(t_collec[iiky]-t[it_gamma_max[iiky]])),\
+                    color=my_colorlist[iiky], linewidth=3.0, linestyle=':')
+            my_legend.append('$\\gamma_{max} '+'= {:.3f}$'.format(gamma_max[iiky]))
+            plt.ylim(bot,top)
+    else:
+        for iiky in range(len(iky_list)):
+            plt.semilogy(t, max_phi2bloon[iiky], color=my_colorlist[iiky], linewidth=3.0)
+            my_legend.append('$k_y = {:.3f}$'.format(ky[iky_list[iiky]]))
+            plt.semilogy(t, max_phi2bloon[iiky][it_start]*np.exp(2.0*slope_max[iiky]*t+offset_max[iiky]),\
+                    color=my_colorlist[iiky], linewidth=3.0, linestyle='--')
+            my_legend.append('$\\langle\\gamma\\rangle_t = {:.3f}$'.format(slope_max[iiky]))
+            bot, top = plt.ylim()
+            plt.semilogy(t, max_phi2bloon[iiky][it_gamma_max[iiky]]*np.exp(2.0*gamma_max[iiky]*(t-t[it_gamma_max[iiky]])),\
+                    color=my_colorlist[iiky], linewidth=3.0, linestyle=':')
+            my_legend.append('$\\gamma_{max} '+'= {:.3f}$'.format(gamma_max[iiky]))
+            plt.ylim(bot,top)
+    plt.legend(my_legend)
+    pdfname = 'floquet_max_vs_t_all_ky' + '_dmid_' + str(my_dmid) 
+    pdfname = run.out_dir + pdfname + '_' + run.fnames[ifile] + '.pdf'
+    plt.savefig(pdfname)
+    plt.clf()
+    plt.cla()
+
+    # plot gamma vs (kxstar,ky), for every Floquet oscillation in the simulation
+    if phi_t_present:
+
+        cbarmax = np.amax(slope_max)
+        cbarmin = -1.0*cbarmax
+
+        if g_exb != 0.0:
+
+            tmp_pdf_id = 1
+            pdflist = []
+            # Finer and regular kx, ky mesh for contour plot of gamma
+            nakx_fine = (kx_bar.size-1)*1e4+1
+            kx_grid_fine = np.linspace(np.amin(kx_bar)-dkx/2.,np.amax(kx_bar)+dkx/2.,nakx_fine)
+            ky_grid_fine = np.zeros(len(iky_list))
+            for iiky in range(len(iky_list)):
+                iky = iky_list[iiky]
+                ky_grid_fine[iiky] = ky[iky]
+
+            iTfmax = len(gamma[0])-1
+
+            for iTf in range(iTfmax,-1,-1):
+                # First arrange kx,ky,gamma similarly to fine meshes above
+                npoints = 0
+                for iiky in range(len(iky_list)):
+                    npoints = npoints + len(kx_star_for_gamma[iiky][iTf])
+                kx_grid_1d = np.zeros(npoints)
+                ky_grid_1d = np.zeros(npoints)
+                gamma_1d = np.zeros(npoints)
+                istart = 0
+                for iiky in range(len(iky_list)):
+                    iky = iky_list[iiky]
+                    for ikxstar in range(len(kx_star_for_gamma[iiky][iTf])):
+                        ipoint = istart + ikxstar
+                        kx_grid_1d[ipoint] = kx_star_for_gamma[iiky][iTf][ikxstar]
+                        ky_grid_1d[ipoint] = ky[iky]
+                        gamma_1d[ipoint] = gamma[iiky][iTf][ikxstar]
+                    istart = istart + len(kx_star_for_gamma[iiky][iTf])
+                # If GS2 indeed wrote out data during this Floquet oscillation, then
+                if gamma_1d.size > 0 :
+                    # interpolate to nearest neighbour on fine, regular mesh ...
+                    gamma_fine = scinterp.griddata((kx_grid_1d,ky_grid_1d),gamma_1d, \
+                            (kx_grid_fine[None,:],ky_grid_fine[:,None]),method='nearest')
+                    # ... and plot.
+                    if len(iky_list)>1: # many ky: plot contour
+                        my_title = '$d\\log(\\varphi)/dt, N_F={:d}/{:d}$'.format(iTf+1,len(gamma[iiky]))
+                        my_xlabel = '$k_x^*$'
+                        my_ylabel = '$k_y$'
+                        gplots.plot_2d(gamma_fine,kx_grid_fine,ky_grid_fine,cbarmin,cbarmax,
+                                xlab=my_xlabel,ylab=my_ylabel,title=my_title,cmp='RdBu_r')
+                    else: # single ky: 1d plot vs kxstar
+                        plt.plot(kx_grid_1d,gamma_1d,linewidth=3.0,color=gplots.myblue)
+                        plt.xlabel('$k_x^*$')
+                        plt.ylabel('$d\\log(\\varphi)/dt$')
+                        plt.title('$k_y={:.2f}, N_F={:d}/{:d}$'.format(ky[iky_list[0]],iTf+1,len(gamma[iiky])))
+                        ax = plt.gca()
+                        ax.set_ylim(cbarmin,cbarmax)
+                    tmp_pdfname = 'tmp'+str(tmp_pdf_id)
+                    gplots.save_plot(tmp_pdfname, run, ifile)
+                    pdflist.append(tmp_pdfname)
+                    tmp_pdf_id = tmp_pdf_id+1
+            pdflist = pdflist[::-1] # re-order since we iterated from last oscillation
+            merged_pdfname = 'gamma_vs_kxky' + '_dmid_' + str(my_dmid)
+            gplots.merge_pdfs(pdflist, merged_pdfname, run, ifile)
+
+        else: # g_exb = 0.0
+
+            if len(iky_list)>1: # many ky: plot contour
+                ky_to_plot = np.zeros(len(iky_list))
+                for iiky in range(len(iky_list)):
+                    ky_to_plot[iiky] = ky[iky_list[iiky]]
+                my_title = '$d\\log(\\varphi)/dt$'
+                my_xlabel = '$k_x^*$'
+                my_ylabel = '$k_y$'
+                gplots.plot_2d(np.transpose(gamma),kx_bar,ky_to_plot,cbarmin,cbarmax,
+                        xlab=my_xlabel,ylab=my_ylabel,title=my_title,cmp='RdBu_r')
+            else: # single ky: 1d plot vs kxstar
+                plt.plot(kx_bar,gamma[:,-1],linewidth=3.0,color=gplots.myblue)
+                plt.xlabel('$k_x^*$')
+                plt.ylabel('$d\\log(\\varphi)/dt$')
+                plt.title('$k_y={:.2f}$'.format(ky[iky_list[0]]))
+                ax = plt.gca()
+                ax.set_ylim(cbarmin,cbarmax)
+
+            pdfname = 'gamma_vs_kxky' + '_dmid_' + str(my_dmid)
+            pdfname = run.out_dir + pdfname + '_' + run.fnames[ifile] + '.pdf'
+            plt.savefig(pdfname)
+            
+            plt.clf()
+            plt.cla()
+
+
+    for iiky in range(len(iky_list)):
+    
+        iky = iky_list[iiky]
+
+        # plot phi2 vs t for each kx
+        plt.title('$k_y={:.2f}$'.format(ky[iky]))
+        plt.xlabel('$t\\ [r_r/v_{thr}]$')
+        my_ylabel = '$\\ln \\left(\\vert \\langle \\phi \\rangle_\\theta \\vert ^2\\right)$'
+        plt.ylabel(my_ylabel)
+        plt.grid(True)
+        my_colorlist = plt.cm.plasma(np.linspace(0,1,kx_bar.size))
+        my_legend = []
+        kxs_to_plot=kx_bar
+        for ikx in range(kx_bar.size):
+            if kx_bar[ikx] in kxs_to_plot:
+                plt.plot(t, np.log(phi2[:,iky,ikx]), color=my_colorlist[ikx])
+                #my_legend.append('$\\rho_i\\bar{k}_x = '+str(kx_bar[ikx])+'$')
+        #plt.legend(my_legend)
+        axes=plt.gca()
+
+        pdfname = 'phi2_by_kx_iky_{:d}'.format(iky)
+        pdfname = run.out_dir + pdfname + '_' + run.fnames[ifile] + '.pdf'
+        plt.savefig(pdfname)
+        
+        plt.clf()
+        plt.cla()
+
+        ## set up time stepping for snapshots and movies
+        max_it_for_snap = nt
+        it_step_for_snap = 1 # Adapt this
+        max_it_for_mov = nt
+        it_step_for_mov = 10
+
+        ## Plot real frequency of connected chain, vs kxbar
+        # Save snapshots
+        tmp_pdf_id = 1
+        pdflist = []
+        for it in range(0,max_it_for_snap,it_step_for_snap):
+            l1, = plt.plot(kxbarbloon[iiky][it],omegabloon[iiky][it], marker='o', color=gplots.myblue, \
+                    markersize=12, markerfacecolor=gplots.myblue, markeredgecolor=gplots.myblue, linewidth=3.0)
+            plt.xlabel('$\\rho\\bar{k}_x$')
+            plt.ylabel('$\\omega$'+' '+'$[v_{thr}/r_r]$')
+            plt.grid(True)
+            ax = plt.gca()
+            ax.set_title('$k_y={:.2f}, t={:.2f}$'.format(ky[iky],t[it]))
+            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
+            gplots.save_plot(tmp_pdfname, run, ifile)
+            pdflist.append(tmp_pdfname)
+            tmp_pdf_id = tmp_pdf_id+1
+
+        merged_pdfname = 'omega_snaps'
+        gplots.merge_pdfs(pdflist, merged_pdfname, run, ifile)
+        plt.clf()
+        plt.cla()
+
+        if (phi_t_present):
+
+            # find global min and max of ballooning angle
+            bloonang_min = 0.
+            bloonang_max = 0.
+            for it in range(max_it_for_snap):
+                if np.min(bloonang[iiky][it]) < bloonang_min:
+                    bloonang_min = np.min(bloonang[iiky][it])
+                if np.max(bloonang[iiky][it]) > bloonang_max:
+                    bloonang_max = np.max(bloonang[iiky][it])
+
+            ## Save snapshots
+            tmp_pdf_id = 1
+            pdflist = []
+            for it in range(0,max_it_for_snap,it_step_for_snap):
+                l1, = plt.plot(bloonang[iiky][it],phi2bloon[iiky][it], marker='o', color=gplots.myblue, \
+                        markersize=12, markerfacecolor=gplots.myblue, markeredgecolor=gplots.myblue, linewidth=3.0)
+                l2, = plt.plot(bloonang_bndry[iiky][it],phi2bloon_discont[iiky][it], linestyle='', \
+                        marker='o', markersize=8, markerfacecolor='r', markeredgecolor='r')
+                plt.xlabel('$\\theta -\\theta_0^*$') # NDCPARAM: check for plot_against_theta0_star
+                plt.grid(True)
+                plt.gca().set_xlim(bloonang_min,bloonang_max)
+                plt.gca().yaxis.set_major_formatter(FormatStrFormatter('%.1E'))
+                ymin = np.amin(phi2bloon[iiky][it])
+                ymax = np.amax(phi2bloon[iiky][it])
+                ax = plt.gca()
+                ax.set_ylim(ymin,ymax)
+                ax.set_title('$k_y={:.2f}, t={:.2f}$'.format(ky[iky],t[it]))
+                ax.legend(['$\\vert \\phi \\vert ^2$', '$\\Delta\\vert \\phi \\vert ^2$'])
+                tmp_pdfname = 'tmp'+str(tmp_pdf_id)
+                gplots.save_plot(tmp_pdfname, run, ifile)
+                pdflist.append(tmp_pdfname)
+                tmp_pdf_id = tmp_pdf_id+1
+
+            merged_pdfname = 'phibloon_snaps'
+            gplots.merge_pdfs(pdflist, merged_pdfname, run, ifile)
+            plt.clf()
+            plt.cla()
+
+            if (make_movies):
+
+                # find global min and max of ballooning angle
+                bloonang_min = 0.
+                bloonang_max = 0.
+                for it in range(max_it_for_mov):
+                    if np.min(bloonang[iiky][it]) < bloonang_min:
+                        bloonang_min = np.min(bloonang[iiky][it])
+                    if np.max(bloonang[iiky][it]) > bloonang_max:
+                        bloonang_max = np.max(bloonang[iiky][it])
+                
+                ## movie of phi2 vs ballooning angle over time
+                moviename = 'phi_bloon' + '_iky_' + str(iky) + '_dmid_' + str(my_dmid)
+                moviename = run.out_dir + moviename + '_' + run.fnames[ifile] + '.mp4'
+               
+                print("\ncreating movie of phi vs ballooning angle ...")
+                xdata1, ydata1 = [], []
+                l1, = plt.plot([],[], marker='o', color=gplots.myblue, \
+                        markersize=12, markerfacecolor=gplots.myblue, markeredgecolor=gplots.myblue, linewidth=3.0)
+                xdata2, ydata2 = [], []
+                l2, = plt.plot([],[], linestyle='', \
+                        marker='o', markersize=8, markerfacecolor='r', markeredgecolor='r')
+                plt.xlabel('$\\theta -\\theta_0^*$') # NDCPARAM: check for plot_against_theta0_star
+                plt.ylabel('$\\vert \\phi \\vert ^2$')
+                plt.grid(True)
+                plt.gca().set_xlim(bloonang_min,bloonang_max)
+                plt.gca().yaxis.set_major_formatter(FormatStrFormatter('%.1E'))
+                # Initialize lines
+                def init_mov():
+                    l1.set_data([], [])
+                    l2.set_data([], [])
+                    return l1,l2
+                # Update lines
+                def update_mov(it):
+                    # Update chain
+                    #sys.stdout.write("\r{0}".format("\tFrame : "+str(it)+"/"+str(nt-1))) # comment out on HPC
+                    xdata1 = bloonang[iiky][it]
+                    ydata1 = phi2bloon[iiky][it]
+                    l1.set_data(xdata1,ydata1)
+                    ymin = np.amin(phi2bloon[iiky][it])
+                    ymax = np.amax(phi2bloon[iiky][it])
+                    ax = plt.gca()
+                    ax.set_ylim(ymin,ymax)
+                    ax.set_title('$k_y={:.2f}, t={:.2f}$'.format(ky[iky],t[it]))
+                    # Update discontinuities at 2pi interfaces
+                    xdata2 = bloonang_bndry[iiky][it]
+                    ydata2 = phi2bloon_discont[iiky][it]
+                    l2.set_data(xdata2,ydata2)
+                    return l1, l2
+
+                mov = anim.FuncAnimation(myfig,update_mov,init_func=init_mov, \
+                        frames=range(0,max_it_for_mov,it_step_for_mov),blit=False)
+                writer = anim.writers['ffmpeg'](fps=10,bitrate=-1,codec='libx264')
+                mov.save(moviename,writer=writer,dpi=100)
+                plt.clf()
+                plt.cla()
+
+                ## movie of phi2 jump at interfaces between 2pi domains
+                moviename = 'phijump' + '_iky_' + str(iky) + '_dmid_' + str(my_dmid)
+                moviename = run.out_dir + moviename + '_' + run.fnames[ifile] + '.mp4'
+
+                print("\ncreating movie of phijump vs ballooning angle ...")
+                xdata1, ydata1 = [], []
+                l1, = plt.plot([],[], marker='o', color=gplots.myred, \
+                        markersize=12, markerfacecolor=gplots.myred, markeredgecolor=gplots.myred, linewidth=3.0)
+                plt.xlabel('$\\theta -\\theta_0^*$') # NDCPARAM: check for plot_against_theta0_star
+                plt.ylabel('$\\Delta\\vert \\phi \\vert ^2/\\vert \\phi \\vert ^2$')
+                plt.grid(True)
+                plt.gca().set_xlim(bloonang_min,bloonang_max)
+                plt.gca().set_ylim(0,1)
+                # Initialize lines
+                def init_mov_jump():
+                    l1.set_data([], [])
+                    return l1
+                # Update lines
+                def update_mov_jump(it):
+                    #sys.stdout.write("\r{0}".format("\tFrame : "+str(it)+"/"+str(nt-1))) # comment out for HPC
+                    # Update discontinuities at 2pi interfaces
+                    xdata1 = bloonang_bndry[iiky][it]
+                    ydata1 = phi2bloon_jump[iiky][it]
+                    plt.gca().set_title('$k_y={:.2f}, t={:.2f}$'.format(ky[iky],t[it]))
+                    l1.set_data(xdata1,ydata1)
+                    return l1
+
+                mov = anim.FuncAnimation(myfig,update_mov_jump,init_func=init_mov_jump, \
+                        frames=range(0,max_it_for_mov,it_step_for_mov),blit=False)
+                writer = anim.writers['ffmpeg'](fps=10,bitrate=-1,codec='libx264')
+                mov.save(moviename,writer=writer,dpi=100)
+                plt.clf()
+                plt.cla()
+
+                ## Save snapshots
+                #for it in range(0,max_it_for_mov,it_step_for_mov):
+                #    l1, = plt.plot(bloonang_bndry[iiky][it],phi2bloon_jump[iiky][it], marker='o', color=gplots.myblue, \
+                #            markersize=12, markerfacecolor=gplots.myblue, markeredgecolor=gplots.myblue, linewidth=3.0)
+                #    plt.xlabel('$\\theta -\\theta_0^*$') # NDCPARAM: check for plot_against_theta0_star
+                #    plt.ylabel('$\\Delta\\vert \\phi \\vert ^2/\\vert \\phi \\vert ^2$')
+                #    plt.grid(True)
+                #    plt.gca().set_xlim(bloonang_min,bloonang_max)
+                #    ax = plt.gca()
+                #    ax.set_ylim(0,1)
+                #    ax.set_title('$k_y={:.2f}, t={:.2f}$'.format(ky[iky],t[it]))
+                #    plt.savefig('phidiscont_snap_{:,d}.pdf'.format(it))
+                #    plt.clf()
+                #    plt.cla()
+
+                print("\n... movies completed.")
+
+    plt.close()
+
+
+################################################################################
+# storing quantities for scan-plots
+################################################################################
+
+def store_for_task_scan(my_vars, task_space):
+
+    task_space.t = my_vars['t']
+    task_space.delt = my_vars['delt']
+    task_space.iky_list = my_vars['iky_list']
+    task_space.ky = my_vars['ky']
+    task_space.nwrite = my_vars['nwrite']
+    task_space.dkx = my_vars['dkx']
+    task_space.Tf = my_vars['Nf']*my_vars['delt']
+    task_space.sum_phi2bloon = my_vars['sum_phi2bloon']
+
+
+################################################################################
+# Part of task for scans
+################################################################################
+
+def task_scan(run, full_space):
+
+    # Start comparing simulations at time-step it_start = N_start*Tfloquet/dt
+    # ie after N_start Floquet oscillations
+    # Normalise sum_phi2 by sum_phi2[it_start] for each run
+    
+    N_start = 2
+    # Here, assume that all files have the same iky_list & ky
+    iky_list = full_space[0]['floquet'].iky_list
+    ky = full_space[0]['floquet'].ky
+    
+    sum_phi2 = []
+    t = []
+    delt = np.zeros(len(run.fnames))
+    dkx = np.zeros(len(run.fnames))
+    slope = np.zeros(len(run.fnames))
+    
+    if not run.no_plot:
+
+        ifile_dummy=0
+        for iiky in range(len(iky_list)):
+
+            iky = iky_list[iiky]
+
+            for ifile in range(len(run.fnames)):
+                
+                Tf = full_space[ifile]['floquet'].Tf
+                delt[ifile] = full_space[ifile]['floquet'].delt
+                dkx[ifile] = full_space[ifile]['floquet'].dkx
+                nwrite = full_space[ifile]['floquet'].nwrite
+
+                it_start = int(round((N_start*Tf/delt[ifile])/nwrite))
+
+                sum_phi2_tmp = np.zeros(len(full_space[ifile]['floquet'].sum_phi2bloon[iiky])-it_start)
+                for it in range(sum_phi2_tmp.size):
+                    sum_phi2_tmp[it] = full_space[ifile]['floquet'].sum_phi2bloon[iiky][it_start+it]
+                sum_phi2_tmp = sum_phi2_tmp/sum_phi2_tmp[0]
+                sum_phi2.append(sum_phi2_tmp)
+                
+                t_tmp = np.zeros(len(full_space[ifile]['floquet'].t)-it_start)
+                for it in range(t_tmp.size):
+                    t_tmp[it] = full_space[ifile]['floquet'].t[it_start+it]
+                t.append(t_tmp)
+
+                [a,dummy] = leastsq_lin(t_tmp,np.log(sum_phi2_tmp))
+                slope[ifile] = a
+    
+            print('Slopes for ky={:.3f}:'.format(ky[iky]))
+            print(slope)
+            plt.figure(figsize=(12,8))
+            
+            # Plot phi2 summed along chain
+            plt.xlabel('$t [a/v_{thi,i}]$')
+            plt.ylabel('$\\ln \\left(\\sum_{k_x}\\vert \\langle\\hat{\\varphi}\\rangle_\\theta \\vert ^2\\right)$')
+            if len(iky_list)>1:
+                plt.title('$\\rho k_y = {:.3f}$'.format(ky[iky]))
+            plt.grid(True)
+            my_legend = []
+            #my_colorlist = plt.cm.YlOrBr(np.linspace(0.2,1,len(run.fnames))) # for newalgo
+            my_colorlist = plt.cm.YlGnBu(np.linspace(0.2,1,len(run.fnames))) # for oldalgo
+            for ifile in range(len(run.fnames)):
+                #my_legend.append('$\\Delta t =$'+str(full_space[ifile]['floquet'].delt))
+                my_legend.append('$\\rho(\\Delta k_x) = {:.3f}$'.format(full_space[ifile]['floquet'].dkx))
+                plt.plot(t[ifile], np.log(sum_phi2[ifile]), color=my_colorlist[ifile], linewidth=3.0)
+            plt.legend(my_legend)
+            axes = plt.gca()
+            axes.set_ylim([-0.5, 13.75])
+
+            # Plot growthrates within phi2 plot
+            subaxes = plt.axes([0.65, 0.25, 0.3, 0.25])
+            subaxes.tick_params(labelsize=18)
+            plt.xlabel('$\\rho(\\Delta k_x)$',fontsize=20)
+            #plt.ylabel('$\\langle \\gamma \\rangle_t$',fontsize=20)
+            plt.title('Time averaged growth-rate',fontsize=20)
+            plt.grid(True)
+            plt.plot(dkx, slope, marker='o', color='black', \
+                    markersize=10, markerfacecolor='none', markeredgecolor='black', linewidth=2.0)
+            gamma_converged = 0.06418364
+            plt.axhline(y=gamma_converged, color='grey', linestyle='--', linewidth=2.0) # for oldalgo
+            subaxes.set_ylim([0.06, 0.13])
+            
+            plot_name = run.scan_name
+            if len(iky_list)>1:
+                plot_name = plot_name + '_ky_{:.3f}'.format(ky[iky])
+            gplots.save_plot(run.scan_name, run)
+            
+            plt.clf()
+            plt.cla()
+
+        plt.close()
+
+def leastsq_lin(x, y):
+    
+    # y_fit = a*x + b
+    # minimising sum((y - f_fit)^2)
+    N_x = x.size
+
+    a = 1./(N_x*np.sum(np.power(x,2)) - np.sum(x)**2) * (N_x*np.sum(np.multiply(x,y)) - np.sum(x)*np.sum(y))
+    
+    b = 1./(N_x*np.sum(np.power(x,2)) - np.sum(x)**2) * (-1.*np.sum(x)*np.sum(np.multiply(x,y)) + np.sum(np.power(x,2))*np.sum(y))
+
+    return [a, b]
+
+def get_growthrate(t,tofit,it_start):
+   
+    popt, pcov = opt.curve_fit(lin_func, t[it_start:], np.log(tofit[it_start:]))
+    return popt[0]
+
+def lin_func(x,a,b):
+    return a*x+b
diff --git a/tasks/linbox.py b/tasks/linbox.py
deleted file mode 100644
index 211b6fd..0000000
--- a/tasks/linbox.py
+++ /dev/null
@@ -1,835 +0,0 @@
-from matplotlib import pyplot as plt
-from matplotlib.ticker import FormatStrFormatter
-import matplotlib.animation as anim
-import numpy as np
-from math import pi
-from math import ceil
-import imageio
-import os
-import sys
-import pickle
-from PyPDF2 import PdfFileMerger, PdfFileReader
-import scipy.interpolate as scinterp
-import scipy.optimize as opt
-
-import gs2_plotting as gplot
-
-# A twist and shift chain is identified by dmid = 0,
-# which is the number of dkx between kx=0 and the
-# smallest kx>0 that is a member of the chain, at t=0.
-
-ndec_tt0 = 2
-
-def my_task_single(ifile, run, myin, myout, mytime, task_space):  
-
-
-
-
-
-    # vvv User parameters vvv
-    
-    # select chains
-    dmid_list = []
-
-    # Select t/tfinal for plot of phi vs ballooning angle
-    tRatio_toPlot = [1.0]
-
-    # make snapshots/movies along ballooning angle ?
-    make_plots = True
-
-    make_snaps = False
-    itSnap_min = 0
-    itSnap_max = -1
-    itSnap_step = 10
-
-    make_movies = False
-    itMov_min = 0
-    itMov_max = -1
-    itMov_step = 1
-
-    make_movie_discont = False
-
-    # ^^^ User parameters ^^^
-
-
-
-
-
-    t = myout['t']
-    delt = myin['knobs']['delt']
-    nt = t.size
-    nwrite = myin['gs2_diagnostics_knobs']['nwrite']
-
-    theta = myout['theta']
-    ntheta = theta.size
-    
-    g_exb = myin['dist_fn_knobs']['g_exb']
-    shat = myin['theta_grid_parameters']['shat']
-    jtwist = int(myin['kt_grids_box_parameters']['jtwist'])
-
-    kx_gs2 = myout['kx']
-    # We only consider the first non-zero ky
-    ky = myout['ky'][1]
-    dky = 1./myin['kt_grids_box_parameters']['y0']
-    dkx = 2.*pi*abs(shat)*dky/jtwist
-    nakx = kx_gs2.size
-    ikx_max = int(round((nakx-1)/2))
-    ikx_min = ikx_max+1
-    # Index of kx=0
-    ikx0 = (nakx-1)//2
-    
-    # Number of t-steps before ExB re-map
-    if g_exb != 0.0:
-        N_per_remap = max(1, abs(int(round(dkx/(g_exb*delt*dky)))))
-    else:
-        N_per_remap = np.nan
-    # Floquet period
-    if g_exb != 0.0:
-        Tf = abs(2*pi*shat/g_exb)
-    else:
-        Tf = np.nan
-    # Number of t-steps in Floquet period
-    if g_exb != 0.0:
-        Nf = int(round(Tf/delt))
-    else:
-        Nf = np.nan
-
-    # Read data from output
-    phi2_gs2 = np.squeeze(myout['phi2_by_mode'][:,1,:])
-    omega_gs2 = np.squeeze(myout['omega_average'][:,1,:,0]) # real frequency
-    phi_t_present = myout['phi_t_present']
-    if phi_t_present:
-        phi2_bytheta_gs2 = np.sum(np.power(myout['phi_t'],2), axis=4)
-        phi2_bytheta_gs2 = np.squeeze(phi2_bytheta_gs2[:,1,:,:])
-    try:
-        Qe = myout['es_heat_flux'][:,1]
-        Qi = myout['es_heat_flux'][:,0]
-        Qratio = Qe/Qi
-        Qratio_avg = mytime.timeavg(Qratio)
-    except:
-        Qratio_avg = 'NaN'
-   
-    # Sorting kx indices to become monotonic
-    kx_bar = np.concatenate((kx_gs2[ikx_min:],kx_gs2[:ikx_min]))
-    phi2 = np.concatenate((phi2_gs2[:,ikx_min:], phi2_gs2[:,:ikx_min]), axis=1)
-    omega = np.concatenate((omega_gs2[:,ikx_min:], omega_gs2[:,:ikx_min]), axis=1)
-    if phi_t_present:
-        phi2_bytheta = np.concatenate((phi2_bytheta_gs2[:,ikx_min:,:], phi2_bytheta_gs2[:,:ikx_min,:]), axis=1)
-
-    # Check if we want to process all -pi < theta0 < pi (ie if dmid_list=[])
-    if not dmid_list:
-        dmid_list = [0]
-        ikx = 1
-        while abs(ikx*dkx/(shat*ky)) <= pi:
-            dmid_list.insert(0,-ikx)
-            dmid_list.append(ikx)
-            ikx += 1
-
-    # Check if the chain has at least one connection.
-    # If not, we will follow the right-most (g_exb>0)
-    # or left-most (g_exb<0) chain until it falls off the grid.
-    if jtwist > nakx:
-        if g_exb != 0:
-            dmid_list = [int(np.sign(g_exb)*(nakx-1)/2)]
-            nt = int((nakx-1) * np.floor(N_per_remap/nwrite))
-            if nt == 0:
-                print('\n============== WARNING ==============\n'+ \
-                        'This chain has no connections, and is\n'+ \
-                        '   dropped from the simulation at    \n'+ \
-                        '         t < nwrite*delt             \n'+ \
-                        '=====================================\n' )
-
-    # Get kx and kx_star from kx_bar
-    kx = np.zeros((nt,nakx))
-    kx_star = np.zeros((nt,nakx))
-    # @ it = 0, kx = kx_bar
-    kx[0,:] = kx_bar
-    kx_star[0,:] = kx_bar
-    # First step is taken with 0.5*dt
-    # Other steps taken with full dt
-    for it in range(1,nt):
-        ikx_shift = int(round(g_exb*ky*delt*(nwrite*it-0.5)/dkx))
-        for ikx in range(nakx):
-            kx[it,ikx] = kx_bar[ikx] + ikx_shift*dkx
-            kx_star[it,ikx] = kx[it,ikx] - g_exb*ky*delt*(nwrite*it-0.5)
-
-    # Construct theta0 grids
-    itheta0_list = [dmid + ikx0 for dmid in dmid_list]
-    theta0 = kx_bar/(shat*ky)
-    theta0_star = np.zeros((nt,nakx))
-    theta0_star[0,:] = theta0
-    for it in range(1,nt):
-        for ikx in range(nakx):
-            theta0_star[it,ikx] = (kx_bar[ikx]-g_exb*ky*delt*(nwrite*it-0.5))/(shat*ky)
-    
-    # Lists containing all ballooning chains at every time step
-    ikx_members = []
-    ikx_prevmembers = []
-    bloonang = []
-    bloonang_bndry = []
-    phi2bloon = []
-    phi2bloon_discont = []
-    phi2bloon_jump = []
-    max_phi2bloon = []
-    sum_phi2bloon = []
-    omegabloon = []
-    gamma = []
-    kx_star_for_gamma = []
-
-    for dmid in dmid_list:
-
-        # Lists containing all time steps for the current chain
-        ikx_members_chain = []
-        ikx_prevmembers_chain = []
-        bloonang_chain = []
-        bloonang_bndry_chain = []
-        phi2bloon_chain = []
-        phi2bloon_discont_chain = []
-        phi2bloon_jump_chain = []
-        max_phi2bloon_chain = []
-        sum_phi2bloon_chain = []
-        gamma_chain = []
-        omegabloon_chain = []
-
-        for it in range(nt):
-
-            # Lists containing the current time step of the current chain
-            phi2bloon_now = []
-            phi2bloon_discont_now = []
-            phi2bloon_jump_now = []
-            omegabloon_now = []
-
-            # Determine (or, if gexb/=0, update) the 
-            # collection of ikx's that are included
-            # in the chain at time step it (ikx_members_now)
-            # and at time step it-1 (ikx_prevmembers_now).
-
-            if it==0 or g_exb != 0.0:
-
-                # Lists containing the current time step of the current chain
-                ikx_members_now = []
-                ikx_prevmembers_now = []
-                bloonang_now = []
-                bloonang_bndry_now = []
-
-                if it==0:
-                    ikx_shift = 0
-                    ikx_shift_old = 0
-                elif it==1:
-                    ikx_shift = int(round(g_exb*ky*delt*(nwrite*it-0.5)/dkx))
-                    ikx_shift_old = 0
-                else:
-                    ikx_shift = int(round(g_exb*ky*delt*(nwrite*it-0.5)/dkx))
-                    ikx_shift_old = int(round(g_exb*ky*delt*(nwrite*(it-1)-0.5)/dkx))
-
-                # ikx such that our chain includes kxstar(t=0) = dmid*dkx
-                ikx = ikx0 - ikx_shift + dmid
-                ikxprev = ikx0 - ikx_shift_old + dmid
-
-                while (ikx >= nakx): # moving from the right to first connected kx within the set in GS2
-                    ikx = ikx-jtwist
-                    ikxprev = ikxprev-jtwist
-                while (ikx >= 0):
-                    ikx_members_now.append(ikx)
-                    if ikxprev >= nakx:
-                        ikx_prevmembers_now.append(np.nan)
-                    elif ikxprev < 0:
-                        ikx_prevmembers_now.append(np.nan)
-                    else:
-                        ikx_prevmembers_now.append(ikxprev)
-                    ikx = ikx-jtwist
-                    ikxprev = ikxprev-jtwist
-
-                ikx = ikx0 - ikx_shift + dmid + jtwist
-                ikxprev = ikx0 - ikx_shift_old + dmid + jtwist
-                while (ikx < 0): # moving from the left to first connected kx within the set in GS2
-                    ikx = ikx+jtwist
-                    ikxprev = ikxprev+jtwist
-                while (ikx < nakx):
-                    ikx_members_now.append(ikx)
-                    if ikxprev >= nakx:
-                        ikx_prevmembers_now.append(np.nan)
-                    elif ikxprev < 0:
-                        ikx_prevmembers_now.append(np.nan)
-                    else:
-                        ikx_prevmembers_now.append(ikxprev)
-                    ikx = ikx+jtwist
-                    ikxprev = ikxprev+jtwist
-
-                # sort ikx of chain members at time it in left-to-right order (shat>0: descending, shat<0: ascending)
-                # sort time it-1 accordingly
-                idx_sort = sorted(range(len(ikx_members_now)), key=lambda k: ikx_members_now[k],reverse=(shat>0.))
-                ikx_members_now = [ikx_members_now[idx] for idx in idx_sort]
-                ikx_prevmembers_now = [ikx_prevmembers_now[idx] for idx in idx_sort]
-
-                member_range = range(len(ikx_members_now))
-                
-                # compute ballooning angle
-                for imember in member_range:
-                    if imember < len(ikx_members_now)-1:
-                        b_ang_bndry = pi-kx_star[it,ikx_members_now[imember]]/(shat*ky)
-                        bloonang_bndry_now.append(b_ang_bndry)
-                    for itheta in range(ntheta):
-                        b_ang = theta[itheta] - kx_star[it,ikx_members_now[imember]]/(shat*ky)
-                        bloonang_now.append(b_ang)
-
-            if phi_t_present:
-                
-                for imember in member_range:
-                    
-                    # construct chain of phi2
-                    for itheta in range(ntheta):
-                        phi2bloon_now.append(phi2_bytheta[it,ikx_members_now[imember],itheta])
-                    
-                    # construct chain of real frequency
-                    omegabloon_now.append(omega[it,ikx_members_now[imember]])
-
-                    # Saving discontinuities
-                    if imember < len(ikx_members_now)-1:
-                        phi2_l = phi2_bytheta[it,ikx_members_now[imember],-1]
-                        phi2_r = phi2_bytheta[it,ikx_members_now[imember+1],0]
-                        discont = abs(phi2_r-phi2_l)
-                        phi2bloon_discont_now.append(discont)
-                        jump = abs((phi2_r-phi2_l)/max(phi2_l,phi2_r))
-                        phi2bloon_jump_now.append(jump)
-
-            # Add this time step to the current chain
-            ikx_members_chain.append(ikx_members_now)
-            ikx_prevmembers_chain.append(ikx_prevmembers_now)
-            bloonang_chain.append(bloonang_now)
-            bloonang_bndry_chain.append(bloonang_bndry_now)
-            phi2bloon_chain.append(phi2bloon_now)
-            phi2bloon_discont_chain.append(phi2bloon_discont_now)
-            phi2bloon_jump_chain.append(phi2bloon_jump_now)
-            omegabloon_chain.append(omegabloon_now)
-            max_phi2bloon_chain.append(max(phi2bloon_now))
-            sum_phi2bloon_chain.append(sum(phi2bloon_now))
-
-        # Add this chain to the full collection
-        ikx_members.append(ikx_members_chain)
-        ikx_prevmembers.append(ikx_prevmembers_chain)
-        bloonang.append(bloonang_chain)
-        bloonang_bndry.append(bloonang_bndry_chain)
-        phi2bloon.append(phi2bloon_chain)
-        phi2bloon_discont.append(phi2bloon_discont_chain)
-        phi2bloon_jump.append(phi2bloon_jump_chain)
-        max_phi2bloon.append(max_phi2bloon_chain)
-        sum_phi2bloon.append(sum_phi2bloon_chain)
-        omegabloon.append(omegabloon_chain)
-
-    # Start comparing simulations at time-step it_start
-    # With flow shear, it_start = N_start*Tfloquet/dt
-    if g_exb != 0.0:
-        N_start = 0
-        it_start = int(round((N_start*Tf/delt)/nwrite))
-    else:
-        fac = 0.5
-        it_start = round(fac*nt)
-
-    t_collec = []
-    max_phi2_collec = []
-    sum_phi2_collec = []
-    
-    # Compute <gamma>_t
-    gamma_avg = np.zeros(len(dmid_list))
-    offset_avg = np.zeros(len(dmid_list))
-    gamma_avg_fromSum = np.zeros(len(dmid_list))
-    offset_avg_fromSum = np.zeros(len(dmid_list))
-
-    for idmid in range(len(dmid_list)):
-
-        # Selected time window
-        t_tmp = np.zeros(nt-it_start)
-        for it in range(t_tmp.size):
-            t_tmp[it] = t[it_start+it]
-        t_collec.append(t_tmp)
-
-        # Gamma from max(phi2)
-        max_phi2_tmp = np.zeros(len(max_phi2bloon[idmid])-it_start)
-        for it in range(max_phi2_tmp.size):
-            max_phi2_tmp[it] = max_phi2bloon[idmid][it_start+it]
-        if it_start > 0:
-            max_phi2_tmp = max_phi2_tmp/max_phi2_tmp[0]
-        max_phi2_collec.append(max_phi2_tmp)
-
-        [gam,offset] = leastsq_lin(t_tmp,np.log(max_phi2_tmp))
-        gamma_avg[idmid] = gam/2. # divide by 2 because fitted square
-        offset_avg[idmid] = offset
-
-        # Gamma from sum(phi2)
-        sum_phi2_tmp = np.zeros(len(sum_phi2bloon[idmid])-it_start)
-        for it in range(sum_phi2_tmp.size):
-            sum_phi2_tmp[it] = sum_phi2bloon[idmid][it_start+it]
-        if it_start > 0:
-            sum_phi2_tmp = sum_phi2_tmp/sum_phi2_tmp[0]
-        sum_phi2_collec.append(sum_phi2_tmp)
-
-        [gam,offset] = leastsq_lin(t_tmp,np.log(sum_phi2_tmp))
-        gamma_avg_fromSum[idmid] = gam/2. # divide by 2 because fitted square
-        offset_avg_fromSum[idmid] = offset
-
-    # At this point:
-    # fit_avg(t) ~ phi2(tstart) * exp[2*gam*t + offset]
-
-
-
-    # Compute instantaneous and maximum growthrates from ln(phi2_max)
-    # For each chain and at every time, gamma_inst will
-    # have a corresponding theta0* stored in theta0_star_for_inst
-
-    # If gexb = 0, growthrate is cst in time
-    # so the following variables are unused and should not be considered
-
-    if g_exb != 0.0:
-        it_gamma_max = np.zeros(len(dmid_list))
-        it_gamma_max_fromSum = np.zeros(len(dmid_list))
-        gamma_max = np.zeros(len(dmid_list))
-        gamma_max_fromSum = np.zeros(len(dmid_list))
-        gamma_inst = []
-        gamma_inst_fromSum = []
-        theta0_star_for_inst = []
-        for idmid in range(len(dmid_list)):
-            # Start looking for derivatives one Floquet period before last time-step
-            it_start_last_floq = max(int(nt-1-Tf//(delt*nwrite)),0)
-            it_end_last_floq = nt-1
-            it_lastFloq = [it for it in range(it_start_last_floq, it_end_last_floq)]
-            gamma_inst_by_dmid = []
-            gamma_inst_fromSum_by_dmid = []
-            theta0_star_for_inst_by_dmid = []
-            for it in it_lastFloq:
-                # Factor of 0.5 because we fit phi^2
-                gamma_max_tmp = 0.5 * 1./(2*delt*nwrite) * \
-                        ( np.log(max_phi2bloon[idmid][it+1]) - np.log(max_phi2bloon[idmid][it-1]) )
-                gamma_max_fromSum_tmp = 0.5 * 1./(2*delt*nwrite) * \
-                        ( np.log(sum_phi2bloon[idmid][it+1]) - np.log(sum_phi2bloon[idmid][it-1]) )
-                # Fill instantaneous growthrate and corresponding theta0_star
-                gamma_inst_by_dmid.append(gamma_max_tmp)
-                gamma_inst_fromSum_by_dmid.append(gamma_max_fromSum_tmp)
-                # Update maximum growthrate if needed
-                # First from max(phi2)
-                if (gamma_max_tmp > gamma_max[idmid]):
-                    it_gamma_max[idmid] = it
-                    gamma_max[idmid] = gamma_max_tmp
-                # Then from sum(phi2)
-                if (gamma_max_fromSum_tmp > gamma_max_fromSum[idmid]):
-                    it_gamma_max_fromSum[idmid] = it
-                    gamma_max_fromSum[idmid] = gamma_max_fromSum_tmp
-                # Determine current theta0_star associated with this chain
-                tt0_tmp = theta0_star[it,itheta0_list[idmid]]
-                # Shift it to [-pi,+pi]
-                n = int(round(tt0_tmp/(2.0*pi)))
-                tt0_tmp -= 2*pi*n
-                theta0_star_for_inst_by_dmid.append(tt0_tmp)
-            # Get theta0_star in ascending order
-            idx_sort = np.argsort(theta0_star_for_inst_by_dmid)
-            theta0_star_for_inst_by_dmid = [theta0_star_for_inst_by_dmid[idx] for idx in idx_sort]
-            # Sort gamma_inst accordingly
-            gamma_inst_by_dmid = [gamma_inst_by_dmid[idx] for idx in idx_sort]
-            gamma_inst_fromSum_by_dmid = [gamma_inst_fromSum_by_dmid[idx] for idx in idx_sort]
-            # Append theta0_star and gamma_inst to full lists
-            theta0_star_for_inst.append(theta0_star_for_inst_by_dmid)
-            gamma_inst.append(gamma_inst_by_dmid)
-            gamma_inst_fromSum.append(gamma_inst_fromSum_by_dmid)
-
-        it_gamma_max = it_gamma_max.astype(int)
-        it_gamma_max_fromSum = it_gamma_max_fromSum.astype(int)
-        # At this point:
-        # fit_max(t) ~ phi2(tstart) * exp[2*gamma_max*(t-t_gamma_max)]
-    else:
-        gamma_inst = []
-        gamma_inst_fromSum = []
-        theta0_star_for_inst = []
-        for idmid in range(len(dmid_list)):
-            gamma_inst.append([])
-            gamma_inst_fromSum.append([])
-            theta0_star_for_inst.append([])
-        gamma_max = gamma_avg
-        gamma_max_fromSum = gamma_avg_fromSum
-
-    
-    # Save quantities to file for scan plots
-
-    fname = run.out_dir + run.fnames[ifile] + '.linbox.dat'
-
-    with open(fname, 'wb') as outfile:
-
-        vardict = {}
-
-        vardict['ky'] = ky
-        vardict['g_exb'] = g_exb
-        vardict['Qratio_avg'] = Qratio_avg
-        vardict['gamma_max'] = gamma_max
-        vardict['gamma_max_fromSum'] = gamma_max_fromSum
-        vardict['gamma_avg'] = gamma_avg
-        vardict['gamma_avg_fromSum'] = gamma_avg_fromSum
-        vardict['gamma_inst'] = gamma_inst
-        vardict['gamma_inst_fromSum'] = gamma_inst_fromSum
-        vardict['dmid_list'] = dmid_list
-        vardict['itheta0_list'] = itheta0_list
-        vardict['theta0'] = theta0
-        vardict['theta0_star_for_inst'] = theta0_star_for_inst
-
-        pickle.dump(vardict, outfile)
-
-
-
-
-
-    
-    # Plotting
-
-
-    if make_plots:
-
-        # Plot max(phi2) in chain vs time, one dmid per plot
-
-        plt.figure(figsize=(12,8))
-
-        tmp_pdf_id = 1
-        pdflist = []
-        for idmid in range(len(dmid_list)):
-            my_legend = []
-            plt.semilogy(t[0:nt], max_phi2bloon[idmid], color=gplot.myblue, linewidth=3.0)
-            plt.title('$k_y=$'+gplot.str_ky(ky) + ', $\\theta_0=$'+gplot.str_tt0(theta0[itheta0_list[idmid]]))
-            my_legend.append('$\\max_{K_x}\\vert \\langle\\varphi\\rangle_\\theta \\vert ^2$')
-            # Add fits for average and maximum growthrates
-            plt.semilogy(t[0:nt], max_phi2bloon[idmid][it_start]*np.exp(2.0*gamma_avg[idmid]*t[0:nt]+offset_avg[idmid]),\
-                    color=gplot.myblue, linewidth=3.0, linestyle='--')
-            if g_exb != 0.0:
-                my_legend.append('$\\langle\\gamma\\rangle_t = {:.3f}$'.format(gamma_avg[idmid]))
-                bot, top = plt.ylim()
-                plt.semilogy(t[0:nt], max_phi2bloon[idmid][it_gamma_max[idmid]]*np.exp(2.0*gamma_max[idmid]*(t[0:nt]-t[it_gamma_max[idmid]])),\
-                        color=gplot.myblue, linewidth=3.0, linestyle=':')
-                my_legend.append('$\\gamma_{max} '+'= {:.3f}$'.format(gamma_max[idmid]))
-                plt.ylim(bot,top)
-            else:
-                my_legend.append('$\\gamma = {:.3f}$'.format(gamma_avg[idmid]))
-            plt.xlabel('$t$')
-            plt.grid(True)
-            gplot.legend_matlab(my_legend)
-            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-            gplot.save_plot(tmp_pdfname, run, ifile)
-            pdflist.append(tmp_pdfname)
-            tmp_pdf_id = tmp_pdf_id+1
-
-        merged_pdfname = 'maxphi_vs_t'
-        gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-        plt.clf()
-        plt.cla()
-
-
-
-        # Plot sum(phi2) in chain vs time, one dmid per plot
-
-        plt.figure(figsize=(12,8))
-
-        tmp_pdf_id = 1
-        pdflist = []
-        for idmid in range(len(dmid_list)):
-            my_legend = []
-            plt.semilogy(t[0:nt], sum_phi2bloon[idmid], color=gplot.myblue, linewidth=3.0)
-            plt.title('$k_y=$'+gplot.str_ky(ky) + ', $\\theta_0=$'+gplot.str_tt0(theta0[itheta0_list[idmid]]))
-            my_legend.append('$\\sum_{K_x}\\vert \\langle\\varphi\\rangle_\\theta \\vert ^2$')
-            # Add fits for average and maximum growthrates
-            plt.semilogy(t[0:nt], sum_phi2bloon[idmid][it_start]*np.exp(2.0*gamma_avg_fromSum[idmid]*t[0:nt]+offset_avg_fromSum[idmid]),\
-                    color=gplot.myblue, linewidth=3.0, linestyle='--')
-            if g_exb != 0.0:
-                my_legend.append('$\\langle\\gamma\\rangle_t = {:.3f}$'.format(gamma_avg_fromSum[idmid]))
-                bot, top = plt.ylim()
-                plt.semilogy(t[0:nt],sum_phi2bloon[idmid][it_gamma_max_fromSum[idmid]]*np.exp(2.0*gamma_max_fromSum[idmid]*(t[0:nt]-t[it_gamma_max_fromSum[idmid]])),\
-                        color=gplot.myblue, linewidth=3.0, linestyle=':')
-                my_legend.append('$\\gamma_{max} '+'= {:.3f}$'.format(gamma_max_fromSum[idmid]))
-                plt.ylim(bot,top)
-            else:
-                my_legend.append('$\\gamma = {:.3f}$'.format(gamma_avg_fromSum[idmid]))
-            plt.xlabel('$t$')
-            plt.grid(True)
-            gplot.legend_matlab(my_legend)
-            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-            gplot.save_plot(tmp_pdfname, run, ifile)
-            pdflist.append(tmp_pdfname)
-            tmp_pdf_id = tmp_pdf_id+1
-
-        merged_pdfname = 'sumphi_vs_t'
-        gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-        plt.clf()
-        plt.cla()
-
-
-
-        # plot phi2 vs t for each kx
-
-        plt.figure(figsize=(12,8))
-        plt.title('$k_y={:.2f}$'.format(ky))
-        plt.xlabel('$t\\ [r_r/v_{thr}]$')
-        my_ylabel = '$\\ln \\left(\\vert \\langle \\varphi \\rangle_\\theta \\vert ^2\\right)$'
-        plt.ylabel(my_ylabel)
-        plt.grid(True)
-        my_colorlist = plt.cm.plasma(np.linspace(0,1,kx_bar.size))
-        my_legend = []
-        kxs_to_plot=kx_bar
-        for ikx in range(kx_bar.size):
-            if kx_bar[ikx] in kxs_to_plot:
-                plt.plot(t[0:nt], np.log(phi2[0:nt,ikx]), color=my_colorlist[ikx])
-        axes=plt.gca()
-
-        pdfname = 'phi2_vs_t_by_kx'
-        pdfname = run.out_dir + pdfname + '_' + run.fnames[ifile] + '.pdf'
-        plt.savefig(pdfname)
-        
-        plt.clf()
-        plt.cla()
-
-
-
-        # Plot phi2 vs (theta-theta0), one dmid per plot, one series of plots per selected time
-
-        plt.figure(figsize=(12,8))
-        it_toPlot = [int(r*(nt-1)) for r in tRatio_toPlot]
-
-        for it in it_toPlot:
-
-            tmp_pdf_id = 1
-            pdflist = []
-            for idmid in range(len(dmid_list)):
-                if g_exb == 0.0:
-                    plt.title('$t=$' + gplot.str_t(t[it]) + ', $k_y=$' + gplot.str_ky(ky) + ', $\\theta_0 =$' + gplot.str_tt0(theta0[itheta0_list[idmid]]))
-                else:
-                    plt.title('$t=$' + gplot.str_t(t[it]) + ', $k_y=$' + gplot.str_ky(ky) + ', $\\theta_0^* =$' + gplot.str_tt0(theta0_star[it,itheta0_list[idmid]]))
-                lphi, = plt.plot(bloonang[idmid][it],phi2bloon[idmid][it], marker='o', color=gplot.myblue, \
-                        markersize=5, markerfacecolor=gplot.myblue, markeredgecolor=gplot.myblue, linewidth=3.0)
-                lphi.set_label('$\\vert \\varphi \\vert ^2$')
-                lbdry, = plt.plot(bloonang_bndry[idmid][it],phi2bloon_discont[idmid][it], linestyle='', \
-                        marker='d', markersize=15, markerfacecolor='r', markeredgecolor='r')
-                lbdry.set_label('_skip')
-                if g_exb == 0.0:
-                    plt.xlabel('$\\theta-\\theta_0$')
-                else:
-                    plt.xlabel('$\\theta-\\theta_0^*$')
-                plt.grid(True)
-                gplot.legend_matlab()
-                ax = plt.gca()
-                ax.yaxis.set_major_formatter(FormatStrFormatter('%.2E'))
-                tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-                gplot.save_plot(tmp_pdfname, run, ifile)
-                pdflist.append(tmp_pdfname)
-                tmp_pdf_id = tmp_pdf_id+1
-
-            merged_pdfname = 'phi_vs_theta_it_' + str(it)
-            gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-            plt.clf()
-            plt.cla()
-
-
-
-
-   # Snapshots and movies
-
-    for idmid in range(len(dmid_list)):
-    
-        dmid = dmid_list[idmid]
-
-        if (phi_t_present):
-
-            # Snapshots of phi
-
-            if (make_snaps):
-
-                if itSnap_max == -1:
-                    itSnap_max = nt
-
-                # find global min and max of ballooning angle
-                bloonang_min = 0.
-                bloonang_max = 0.
-                for it in range(max_it_for_snap):
-                    if np.min(bloonang[idmid][it]) < bloonang_min:
-                        bloonang_min = np.min(bloonang[idmid][it])
-                    if np.max(bloonang[idmid][it]) > bloonang_max:
-                        bloonang_max = np.max(bloonang[idmid][it])
-
-
-                # Snapshots of phi
-
-                plt.figure(figsize=(12,8))
-
-                tmp_pdf_id = 1
-                pdflist = []
-                for it in range(0,max_it_for_snap,it_step_for_snap):
-                    l1, = plt.plot(bloonang[idmid][it],phi2bloon[idmid][it], marker='o', color=gplot.myblue, \
-                            markersize=5, markerfacecolor=gplot.myblue, markeredgecolor=gplot.myblue, linewidth=3.0)
-                    l1.set_label('$\\vert \\varphi \\vert ^2$')
-                    l2, = plt.plot(bloonang_bndry[idmid][it],phi2bloon_discont[idmid][it], linestyle='', \
-                            marker='d', markersize=15, markerfacecolor='r', markeredgecolor='r')
-                    l2.set_label('_skip')
-                    plt.xlabel('$\\theta$')
-                    plt.grid(True)
-                    plt.gca().set_xlim(bloonang_min,bloonang_max)
-                    plt.gca().yaxis.set_major_formatter(FormatStrFormatter('%.1E'))
-                    ymin = np.amin(phi2bloon[idmid][it])
-                    ymax = np.amax(phi2bloon[idmid][it])
-                    ax = plt.gca()
-                    ax.set_ylim(ymin,ymax)
-                    ax.set_title('$\\theta_0={:.2f},\ $'.format(theta0[itheta0_list[idmid]]) + '$k_y={:.2f},\ t={:.2f}$'.format(ky,t[it]))
-                    ax.legend()
-                    tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-                    gplot.save_plot(tmp_pdfname, run, ifile)
-                    pdflist.append(tmp_pdfname)
-                    tmp_pdf_id = tmp_pdf_id+1
-
-                merged_pdfname = 'snaps_phibloon_dmid_' + str(dmid)
-                gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-                plt.clf()
-                plt.cla()
-
-
-            # Movie of phi
-
-            if (make_movies):
-
-                if itMov_max == -1:
-                    itMov_max = nt
-    
-                myfig = plt.figure(figsize=(12,8))
-
-                # find global min and max of ballooning angle
-                bloonang_min = 0.
-                bloonang_max = 0.
-                for it in range(itMov_min, itMov_max):
-                    if np.min(bloonang[idmid][it]) < bloonang_min:
-                        bAng_min = np.min(bloonang[idmid][it])
-                    if np.max(bloonang[idmid][it]) > bloonang_max:
-                        bAng_max = np.max(bloonang[idmid][it])
-                
-                # find phimax for each time step
-                phi2_max = np.zeros(nt)
-                for it in range(nt):
-                    phi2_max[it] = np.max(phi2bloon[idmid][it])
-                
-                # movie name
-                moviename = 'mov_phi_vs_theta' + '_dmid_' + str(dmid)
-                moviename = run.out_dir + moviename + '_' + run.fnames[ifile] + '.mp4'
-               
-                print("\ncreating movie of phi vs ballooning angle ...")
-
-                # intialise artists
-                xdata1, ydata1 = [], []
-                lphi, = plt.plot([],[], marker='o', color=gplot.myblue, \
-                        markersize=5, markerfacecolor=gplot.myblue, markeredgecolor=gplot.myblue, linewidth=3.0)
-                lphi.set_label('$\\vert \\varphi \\vert ^2/\\max_{K_x}\\vert\\varphi\\vert^2$')
-                xdata2, ydata2 = [], []
-                lbdry, = plt.plot([],[], linestyle='', \
-                        marker='d', markersize=15, markerfacecolor='r', markeredgecolor='r')
-                lbdry.set_label('_skip')
-
-                # Labels, limits, legend
-                if g_exb == 0.0:
-                    plt.xlabel('$\\theta-\\theta_0$')
-                else:
-                    plt.xlabel('$\\theta-\\theta_0^*$')
-                plt.grid(True)
-                plt.gca().set_xlim(bAng_min,bAng_max)
-                ax = plt.gca()
-                plt.gca().set_ylim(0.0,1.0)
-                gplot.legend_matlab()
-
-                # Update lines
-                def update_plot(data):
-
-                    # Unpack data from yield_data
-                    t, bAng, phi2bAng, bAng_bndry, phi2bAng_discont = data
-                    # Update phi2 chain
-                    lphi.set_data(bAng,phi2bAng)
-                    # Update discontinuities at 2pi interfaces
-                    lbdry.set_data(bAng_bndry,phi2bAng_discont)
-                    # Update title
-                    if g_exb == 0.0:
-                        plt.gca().set_title('$t=$' + gplot.str_t(t) + ', $k_y=$' + gplot.str_ky(ky) + ', $\\theta_0 =$' + gplot.str_tt0(theta0[itheta0_list[idmid]]))
-                    else:
-                        plt.gca().set_title('$t=$' + gplot.str_t(t) + ', $k_y=$' + gplot.str_ky(ky) + ', $\\theta_0^* =$' + gplot.str_tt0(theta0_star[it,itheta0_list[idmid]]))
-
-                    return lphi, lbdry
-
-                # "yield" = "return, and next time function is called, start from there"
-                def yield_data():
-
-                    for it in range(itMov_min, itMov_max, itMov_step):
-
-                        sys.stdout.write("\r{0}".format("\tFrame : "+str(it)+"/"+str(nt-1))) # comment out on HPC
-                        yield t[it], bloonang[idmid][it], phi2bloon[idmid][it]/phi2_max[it], bloonang_bndry[idmid][it], phi2bloon_discont[idmid][it]
-
-                mov = anim.FuncAnimation(myfig, update_plot, frames=yield_data, blit=False, save_count=len(range(itMov_min, itMov_max, itMov_step)))
-                writer = anim.writers['ffmpeg'](fps=15,bitrate=1800)
-                mov.save(moviename,writer=writer,dpi=100)
-                plt.clf()
-                plt.cla()
-
-                print("\n... movie completed.")
-                print('\n')
-
-
-            # Movie of discontinuities in phi
-
-            if make_movie_discont:
-
-                if itMov_max == -1:
-                    itMov_max = nt
-
-                ## movie of phi2 jump at interfaces between 2pi domains
-                moviename = 'phijump' + '_dmid_' + str(dmid)
-                moviename = run.out_dir + moviename + '_' + run.fnames[ifile] + '.mp4'
-
-                print("\ncreating movie of phijump vs ballooning angle ...")
-                xdata1, ydata1 = [], []
-                l1, = plt.plot([],[], marker='o', color=gplot.myred, \
-                        markersize=12, markerfacecolor=gplot.myred, markeredgecolor=gplot.myred, linewidth=3.0)
-                plt.xlabel('$\\theta$') # NDCPARAM: check for plot_against_theta0_star
-                plt.ylabel('$\\Delta\\vert \\varphi \\vert ^2/\\vert \\varphi \\vert ^2$')
-                plt.grid(True)
-                plt.gca().set_xlim(bloonang_min,bloonang_max)
-                plt.gca().set_ylim(0,1)
-                # Initialize lines
-                def init_mov_jump():
-                    l1.set_data([], [])
-                    return l1
-                # Update lines
-                def update_mov_jump(it):
-                    #sys.stdout.write("\r{0}".format("\tFrame : "+str(it)+"/"+str(nt-1))) # comment out for HPC
-                    # Update discontinuities at 2pi interfaces
-                    xdata1 = bloonang_bndry[idmid][it]
-                    ydata1 = phi2bloon_jump[idmid][it]
-                    plt.gca().set_title('$\\theta_0 = {:.2f},$'.format(theta0[itheta0_list[idmid]])+'$k_y={:.2f}, t={:.2f}$'.format(ky,t[it]))
-                    l1.set_data(xdata1,ydata1)
-                    return l1
-
-                mov = anim.FuncAnimation(myfig,update_mov_jump,init_func=init_mov_jump, \
-                        frames=range(0,max_it_for_mov,it_step_for_mov),blit=False)
-                writer = anim.writers['ffmpeg'](fps=10,bitrate=-1,codec='libx264')
-                mov.save(moviename,writer=writer,dpi=100)
-                plt.clf()
-                plt.cla()
-
-                print("\n... movie completed.")
-
-    plt.close()
-
-
-def leastsq_lin(x, y):
-    
-    # y_fit = a*x + b
-    # minimising sum((y - f_fit)^2)
-    N_x = x.size
-
-    a = 1./(N_x*np.sum(np.power(x,2)) - np.sum(x)**2) * (N_x*np.sum(np.multiply(x,y)) - np.sum(x)*np.sum(y))
-    
-    b = 1./(N_x*np.sum(np.power(x,2)) - np.sum(x)**2) * (-1.*np.sum(x)*np.sum(np.multiply(x,y)) + np.sum(np.power(x,2))*np.sum(y))
-
-    return [a, b]
-
-def get_growthrate(t,tofit,it_start):
-   
-    popt, pcov = opt.curve_fit(lin_func, t[it_start:], np.log(tofit[it_start:]))
-    return popt[0]
-
-def lin_func(x,a,b):
-    return a*x+b
-
diff --git a/tasks/linrange.py b/tasks/linrange.py
deleted file mode 100644
index 2448ac0..0000000
--- a/tasks/linrange.py
+++ /dev/null
@@ -1,418 +0,0 @@
-import numpy as np
-import scipy.optimize as opt
-from matplotlib import pyplot as plt
-from matplotlib.ticker import FormatStrFormatter
-import gs2_plotting as gplot
-import matplotlib.colors as mcolors
-import pickle
-import math
-
-def my_task_single(ifile, run, myin, myout, mytime):
-
-
-
-
-
-    # vvv User parameters vvv
-
-    # Fraction of time to be discarded when fitting
-    tRatio_init_dump = 0.8
-    tRatio_end_dump = 0.0
-
-    # Limit y-axis in growthrate plots ?
-    fix_ylim = False
-    ylim = (0.00, 0.11)
-
-    # Limit colorbar on gamma vs (theta0,ky) plot ?
-    fix_cbarlim = False
-    cbarmin = -0.05
-    cbarmax = 0.4
-
-    # Specify flow shear rate to compare Tfloq vs gamma
-    g_exb = 0.0
-
-    # ^^^ User parameters ^^^
-
-
-
-
-
-
-    # Process data
-
-
-    t = myout['t']
-    nt = t.size
-    it_start = int(nt*tRatio_init_dump)
-    tt0 = myout['theta0'][0]
-    ntt0 = tt0.size
-    ky = myout['ky']
-    naky = ky.size
-    theta = myout['theta']
-    # modulus squared, avged over theta (indices: [t,ky,tt0])
-    phi2 = myout['phi2_by_mode']
-    # with theta dependence: phi2_bytheta[t,ky,tt0,theta]
-    phi_t_present = myout['phi_t_present']
-    if phi_t_present:
-        phi2_bytheta = np.sum(np.power(myout['phi_t'],2), axis=4)
-    else:
-        print('\nCannot plot phi vs theta: write_phi_over_time was probably set to false.\n')
-    shat = myin['theta_grid_parameters']['shat']
-    # modulus squared of non-adiabatic part of the density at last time step [spec,ky,kx,theta]
-    if myout['density_present']:
-        dens2 =  np.sum(np.power(myout['density'],2), axis=4)
-    else:
-        print("\nCannot plot dens vs theta, 'density' was not found in output.\n")
-
-    # Store index of first NaN or +/- inf in it_stop
-    it = 0
-    it_stop = int(nt*(1-tRatio_end_dump))
-    no_nan_inf = True
-    while it < nt and no_nan_inf:
-        for itt0 in range(ntt0):
-            for iky in range(1,naky):
-                if not is_number(phi2[it,iky,itt0]):
-                    no_nan_inf = False
-                    it_stop = it
-        it = it + 1
-
-    # Fit phi^2 to get growthrates
-    gamma = np.zeros([naky,ntt0])
-    for iky in range(naky):
-        for itt0 in range(ntt0):
-            if ky[iky] == 0.0:
-                # Skip zonal modes
-                gamma[iky,itt0] = float('nan')
-            else:
-                # Factor of 0.5 because we fit phi^2
-                gamma[iky,itt0] = 0.5*get_growthrate(t,phi2,it_start,it_stop,itt0,iky)
-
-    # Read real frequency
-    omega = np.zeros([naky,ntt0])
-    for iky in range(naky):
-        for itt0 in range(ntt0):
-            # First idx = last time step, last idx = real part
-            omega[iky,itt0] = myout['omega_average'][-1,iky,itt0,0]
-
-    # Compute <Qe/Qi>_t
-    try:
-        Qe = myout['es_heat_flux'][:,1]
-        Qi = myout['es_heat_flux'][:,0]
-        Qratio = Qe/Qi
-        Qratio_avg = mytime.timeavg(Qratio)
-    except:
-        Qratio_avg = float('nan')
-    
-    # Save to .dat file
-    datfile_name = run.out_dir + run.fnames[ifile] + '.linrange.dat'
-    with open(datfile_name, 'wb') as datfile:
-        pickle.dump([tt0,ky,gamma,omega,Qratio_avg],datfile)
-
-
-
-
-
-
-
-    # Plotting
-
-
-    # Plot growthrate vs ky, one plot per theta0
-
-    if naky > 1:
-
-        plt.figure(figsize=(12,8))
-
-        tmp_pdf_id = 1
-        pdflist = []
-        for itt0 in range(ntt0):
-            l, = plt.plot(ky,gamma[:,itt0], color=gplot.myblue, linewidth=3.0)
-            l.set_label('$\\theta_0=$'+gplot.str_tt0(tt0[itt0]))
-            gplot.legend_matlab()
-            if fix_ylim:
-                plt.ylim(ylim)
-            plt.grid(True)
-            plt.xlabel('$k_y\\rho_i$')
-            plt.ylabel('$\\gamma \\ [v_{th}/a]$')
-            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-            gplot.save_plot(tmp_pdfname, run, ifile)
-            pdflist.append(tmp_pdfname)
-            tmp_pdf_id = tmp_pdf_id+1
-
-        merged_pdfname = 'gamma_vs_ky'
-        gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-        plt.clf()
-        plt.cla()
-
-
-    # Plot growthrate vs theta0, one plot per ky
-
-    if ntt0 > 1:
-
-        plt.figure(figsize=(12,8))
-
-        tmp_pdf_id = 1
-        pdflist = []
-        for iky in range(naky):
-            l, = plt.plot(tt0,gamma[iky,:], color=gplot.myblue, linewidth=3.0)
-            l.set_label('$k_y=$'+gplot.str_ky(ky[iky]))
-            gplot.legend_matlab()
-            if fix_ylim:
-                plt.ylim(ylim)
-            plt.grid(True)
-            plt.xlabel('$\\theta_0$')
-            plt.ylabel('$\\gamma \\ [v_{th}/a]$')
-            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-            gplot.save_plot(tmp_pdfname, run, ifile)
-            pdflist.append(tmp_pdfname)
-            tmp_pdf_id = tmp_pdf_id+1
-
-        merged_pdfname = 'gamma_vs_theta0'
-        gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-        plt.clf()
-        plt.cla()
-
-
-    # Contour gamma vs (theta0, ky)
-
-    if naky > 1 and ntt0 > 1:
-
-        xl = '$\\theta_0$'
-        yl = '$\\rho k_y$'
-        g = gamma
-        if not fix_cbarlim:
-            gmax = np.amax(g)
-            gmin = np.amin(g)
-        else:
-            gmin, gmax = [cbarmin, cbarmax]
-        gplot.plot_2d(g,tt0,ky,gmin,gmax,xlab=xl,ylab=yl,cmp='RdBu_c',title='$\\gamma\\ [v_{th}/a]$')
-        pdfname = 'gamma_vs_theta0_ky'
-        gplot.save_plot(pdfname, run, ifile)
-    
-
-    # Plot real frequency vs ky, one plot per theta0
-
-    if naky > 1:
-
-        plt.figure(figsize=(12,8))
-
-        tmp_pdf_id = 1
-        pdflist = []
-        for itt0 in range(ntt0):
-            l, = plt.plot(ky,omega[:,itt0], color=gplot.myblue, linewidth=3.0)
-            l.set_label('$\\theta_0=$'+gplot.str_tt0(tt0[itt0]))
-            gplot.legend_matlab()
-            plt.grid(True)
-            plt.xlabel('$k_y\\rho_i$')
-            plt.ylabel('$\\omega \\ [v_{th}/a]$')
-            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-            gplot.save_plot(tmp_pdfname, run, ifile)
-            pdflist.append(tmp_pdfname)
-            tmp_pdf_id = tmp_pdf_id+1
-
-        merged_pdfname = 'omega_vs_ky'
-        gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-        plt.clf()
-        plt.cla()
-
-
-    # Plot real frequency vs theta0, one plot per ky
-
-    if ntt0 > 1:
-
-        plt.figure(figsize=(12,8))
-
-        tmp_pdf_id = 1
-        pdflist = []
-        for iky in range(naky):
-            l, = plt.plot(tt0,omega[iky,:], color=gplot.myblue, linewidth=3.0)
-            l.set_label('$k_y=$'+gplot.str_ky(ky[iky]))
-            gplot.legend_matlab()
-            plt.grid(True)
-            plt.xlabel('$\\theta_0$')
-            plt.ylabel('$\\omega \\ [v_{th}/a]$')
-            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-            gplot.save_plot(tmp_pdfname, run, ifile)
-            pdflist.append(tmp_pdfname)
-            tmp_pdf_id = tmp_pdf_id+1
-
-        merged_pdfname = 'omega_vs_theta0'
-        gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-        plt.clf()
-        plt.cla()
-
-
-    # Contour real frequency vs (theta0, ky)
-
-    if naky > 1 and ntt0 > 1:
-
-        xl = '$\\theta_0$'
-        yl = '$\\rho k_y$'
-        z = omega
-        zmax = np.amax(z)
-        zmin = np.amin(z)
-        gplot.plot_2d(z,tt0,ky,zmin,zmax,xlab=xl,ylab=yl,cmp='RdBu_c',title='$\\omega\\ [v_{th}/a]$')
-        pdfname = 'omega_vs_theta0_ky'
-        gplot.save_plot(pdfname, run, ifile)
-
-
-    # Plot potential vs t for each ky, one plot per theta0
-
-    plt.figure(figsize=(12,8))
-
-    tmp_pdf_id = 1
-    pdflist = []
-    if naky > 1:
-        cmap = plt.get_cmap('nipy_spectral')
-        my_colors = [cmap(i) for i in np.linspace(0,1,naky)]
-    else:
-        my_colors = [gplot.myblue]
-    for itt0 in range(ntt0):
-        lgd = []
-        for iky in range(naky):
-            plt.semilogy(t[0:it_stop],phi2[0:it_stop,iky,itt0],color=my_colors[iky])
-            lgd.append('$k_y=$'+gplot.str_ky(ky[iky]))
-        gplot.legend_matlab(lgd)
-        plt.grid(True)
-        plt.xlabel('$t\\ [a/v_{th}]$')
-        plt.ylabel('$\\vert\\varphi\\vert^2$')
-        plt.title('$\\theta_0=$'+gplot.str_tt0(tt0[itt0]))
-        tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-        gplot.save_plot(tmp_pdfname, run, ifile)
-        pdflist.append(tmp_pdfname)
-        tmp_pdf_id = tmp_pdf_id+1
-
-    merged_pdfname = 'phi_vs_t'
-    gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-    plt.clf()
-    plt.cla()
-
-
-    # Plot potential at t[it_stop] vs theta for every ky, one plot per theta0
-
-    plt.figure(figsize=(12,8))
-
-    tmp_pdf_id = 1
-    pdflist = []
-    if naky > 1:
-        cmap = plt.get_cmap('nipy_spectral')
-        my_colors = [cmap(i) for i in np.linspace(0,1,naky)]
-    else:
-        my_colors = [gplot.myblue]
-    for itt0 in range(ntt0):
-        lgd = []
-        for iky in range(naky):
-            plt.plot(theta,phi2_bytheta[it_stop-1,iky,itt0,:],color=my_colors[iky])
-            lgd.append('$k_y=$'+gplot.str_ky(ky[iky]))
-        gplot.legend_matlab(lgd)
-        plt.grid(True)
-        plt.xlabel('$\\theta$')
-        plt.ylabel('$\\vert\\varphi\\vert^2$')
-        plt.title('$\\theta_0=$'+gplot.str_tt0(tt0[itt0]))
-        plt.gca().yaxis.set_major_formatter(FormatStrFormatter('%.2E'))
-        tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-        gplot.save_plot(tmp_pdfname, run, ifile)
-        pdflist.append(tmp_pdfname)
-        tmp_pdf_id = tmp_pdf_id+1
-
-    merged_pdfname = 'phi_vs_theta'
-    gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-    plt.clf()
-    plt.cla()
-
-
-    # Plot dens^2 at tfinal vs theta for every ky, one plot per theta0
-
-    plt.figure(figsize=(12,8))
-
-    tmp_pdf_id = 1
-    pdflist = []
-    if naky > 1:
-        cmap = plt.get_cmap('nipy_spectral')
-        my_colors_ion = [cmap(i) for i in np.linspace(0,1,naky)]
-        my_colors_elec = [cmap(i) for i in np.linspace(0,1,naky)]
-        elec_line = '--'
-    else:
-        my_colors_ion = [gplot.myblue]
-        my_colors_elec = [gplot.myred]
-        elec_line = '-'
-    for itt0 in range(ntt0):
-        lgd = []
-        for iky in range(naky):
-            # ion
-            plt.plot(theta,dens2[0,iky,itt0,:],color=my_colors_ion[iky])
-            lgd.append('ion $k_y=$'+gplot.str_ky(ky[iky]))
-            # electron
-            plt.plot(theta,dens2[1,iky,itt0,:],color=my_colors_elec[iky], linestyle=elec_line)
-            lgd.append('electron $k_y=$'+gplot.str_ky(ky[iky]))
-        gplot.legend_matlab(lgd)
-        plt.grid(True)
-        plt.xlabel('$\\theta$')
-        plt.ylabel('$\\vert\\delta n_{h}\\vert^2$')
-        plt.title('$\\theta_0=$'+gplot.str_tt0(tt0[itt0]))
-        plt.gca().yaxis.set_major_formatter(FormatStrFormatter('%.2E'))
-        tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-        gplot.save_plot(tmp_pdfname, run, ifile)
-        pdflist.append(tmp_pdfname)
-        tmp_pdf_id = tmp_pdf_id+1
-
-    merged_pdfname = 'dens_vs_theta'
-    gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-    plt.clf()
-    plt.cla()
-
-
-    # Plot TFloq*gamma vs ky, one plot per theta0
-
-    if g_exb != 0.0 and naky > 1:
-
-        # Floquet period
-        Tf = 2*math.pi*shat/g_exb
-
-        plt.figure(figsize=(12,8))
-
-        tmp_pdf_id = 1
-        pdflist = []
-        for itt0 in range(ntt0):
-            l, = plt.plot(ky,Tf*gamma[:,itt0], color=gplot.myblue, linewidth=3.0)
-            l.set_label('$\\theta_0=$'+gplot.str_tt0(tt0[itt0]))
-            gplot.legend_matlab()
-            plt.grid(True)
-            plt.xlabel('$k_y\\rho_i$')
-            plt.ylabel('$\\gamma T_F$')
-            my_title = '$T_F=' + str(round(Tf,3)) + '\ [r_r/v_{thr}]$'
-            plt.title(my_title)
-            tmp_pdfname = 'tmp'+str(tmp_pdf_id)
-            gplot.save_plot(tmp_pdfname, run, ifile)
-            pdflist.append(tmp_pdfname)
-            tmp_pdf_id = tmp_pdf_id+1
-
-        merged_pdfname = 'floq_vs_growth'
-        gplot.merge_pdfs(pdflist, merged_pdfname, run, ifile)
-        plt.clf()
-        plt.cla()
-
-
-
-
-
-
-def get_growthrate(t,phi2,it_start,it_stop,itt0,iky):
-   
-    popt, pcov = opt.curve_fit(lin_func, t[it_start:it_stop], np.log(phi2[it_start:it_stop,iky,itt0]))
-    return popt[0]
-
-def lin_func(x,a,b):
-    return a*x+b
-
-def is_number(x):
-    try:
-        x_str = str(float(x))
-        if x_str=='nan' or x_str=='inf' or x_str=='-inf':
-            return False
-    except ValueError:
-        try:
-            complex(x_str)
-        except ValueError:
-            return False
-    return True
